/*
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */

// jscs:disable
/**
 * @class Arrow.API
 */
// jscs:enable
var _ = require('lodash'),
	util = require('util'),
	fs = require('fs'),
	path = require('path'),
	events = require('events'),
	async = require('async'),
	Arrow = require('./arrow'),
	pluralize = require('pluralize'),
	Response = require('./response'),
	paths = require('./paths'),
	RequestTx = require('./request_tx'),
	formatters = require('./formatters'),
	express = require('express'),
	apis = [],
	apiPaths = {},
	APIClass = new events.EventEmitter();

// jscs:disable jsDoc

util.inherits(API, events.EventEmitter);

function API(impl, config, arrow) {
	impl && _.merge(this, impl);

	this.arrow = arrow;

	// incoming constructor config should overwrite implementation
	this.config = _.merge(impl && impl.config || {}, arrow.config, config);
	this.txenabled = this.config.logging && (this.config.logging.transactionLogEnabled === undefined || this.config.logging.transactionLogEnabled);
	this.enabled = impl.enabled === undefined ? true : impl.enabled;
	this.sort = impl.sort === undefined ? impl.generated ? impl.path.indexOf(':') < 0 ? -1 : -2 : 1 : impl.sort;

	// if we provided a constructor in our impl, use it
	if (this.constructor && this.constructor !== API && !this.constructor.super_) {
		this.constructor.call(this);
		API.constructor.call(this);
	}

	if (!this.group) {
		throw new Error('required group property missing on API');
	}
	if (!this.path) {
		throw new Error('required path property missing on API');
	}
	if (!this.action) {
		throw new Error('required action property missing on API');
	}
	if (!this.description) {
		throw new Error('required description property missing on API');
	}

	// turn the model into a Model object
	if (this.model && typeof(this.model) === 'string') {
		this.model = this.arrow.getModel(this.model, true);
	}

	// turn the models into a Model array
	if (this.models && Array.isArray(this.models)) {
		this.model = null;
		this.models = this.models.map(function (name) {
			return this.arrow.getModel(name, true);
		}.bind(this));
	}

	if (!this.response) {
		this.response = this.model;

		if (!this.response && this.models) {
			throw new Error('using more than one model requires a "response" property on the API to ' +
				'indicate how the response should be serialized. this value should be the Model name to use for the response.');
		}
	} else {
		// get the response model
		this.response = this.arrow.getModel(this.response, true);
	}

	var singular = this.singular,
		plural = this.plural;

	if (this.model) {
		this.singular = makeResponseKey(singular || this.model.singular || this.model.name, 1);
		this.plural = makeResponseKey(plural || this.model.plural || this.model.name);
	}
	if (this.response) {
		// use the response if multiple models
		this.singular = makeResponseKey(singular || this.response.singular || this.response.name, 1);
		this.plural = makeResponseKey(plural || this.response.plural || this.response.name);
	}

	// pre/post -> before/after.  you pick.
	this.pre = this.pre || this.before;
	this.post = this.post || this.after;

	function getBlock(name) {
		if (_.isFunction(name)) {
			return function blockMiddleware(req, resp, next) {
				try {
					var blockFn = name;
					if (blockFn) {
						if (blockFn.length === 3) {
							blockFn(req, resp, next);
						} else {
							blockFn(req, resp);
							next();
						}
					} else {
						return next();
					}
				}
				catch (E) {
					next(E);
				}
			}.bind(this);
		} else {
			return this.arrow.getBlock(name, true).getMiddleware();
		}
	}

	// load the pre block(s)
	if (this.pre) {
		if (typeof(this.pre) === 'string') {
			this.pre = [this.arrow.getBlock(this.pre, true).getMiddleware()];
		} else if (Array.isArray(this.pre)) {
			this.pre = this.pre.map(getBlock.bind(this));
		} else {
			throw new Error('unknown block type (pre)');
		}
		if (this.pre.length === 0) {
			delete this.pre;
		}
	}

	// load the post block(s)
	if (this.post) {
		if (typeof(this.post) === 'string') {
			this.post = [this.arrow.getBlock(this.post, true).getMiddleware()];
		} else if (Array.isArray(this.post)) {
			this.post = this.post.map(getBlock.bind(this));
		} else {
			throw new Error('unknown block type (post)');
		}
		if (this.post.length === 0) {
			delete this.post;
		}
	}

	// programmers are lazy, allow both
	this.parameters = this.parameters || this.params;

	var method = (this.method || 'GET').toUpperCase();
	if (!this.parameters && this.model && /(PUT|POST)/.test(method)) {
		var bodyfields = {},
			model = this.model,
			localSingular = this.singular;
		// we pull out our fields so that we can generate the PUT/POST parameters
		Object.keys(model.fields).forEach(function (name) {
			var field = model.fields[name],
				required = (field.optional === undefined && field.required === undefined && field.default) || field.required || !field.optional;
			if (!field.readonly) {
				bodyfields[name] = {
					description: field.description || 'the ' + localSingular + ' ' + name + ' field',
					type: 'body',
					optional: !required,
					required: required
				};
			}
		});
		if (method === 'PUT') {
			bodyfields.id = {description: 'primary key id', optional: false, type: 'body'};
		}
		this.parameters = bodyfields;
	}

	var params = this.path.split('/'),
		parts = [],
		foundParams = [];
	params.forEach(function (name) {
		if (name.charAt(0) === ':') {
			name = name.substring(1);
			var optional = false;
			if (name.charAt(name.length - 1) === '?') {
				name = name.substring(0, name.length - 1);
				optional = true;
			}
			var param = this.parameters && this.parameters[name];
			if (!param) {
				throw new Error('missing parameters definition for path parameter: ' + name);
			}
			param.optional = optional;
			param.name = name;
			param.type = 'path';
			foundParams.push(name);
		} else {
			parts.push(name);
		}
	}.bind(this));

	var key = parts.join('/');
	if (key in apiPaths) {
		apiPaths[key].push(this);
	} else {
		apiPaths[key] = [this];
	}
	arrow.logger.debug('registering' + (this.enabled ? '' : ' disabled') + ' api', this.method, this.path);

	// register by nickname as well as path
	if (this.nickname) {
		if (this.nickname in apiPaths) {
			apiPaths[this.nickname].push(this);
		} else {
			apiPaths[this.nickname] = [this];
		}
		arrow.logger.debug('registering api (nickname)', this.nickname);
	} else {
		// the nickname should just be the path so we have one
		this.nickname = method + ' ' + key;
	}
	this.key = key;

	this.parameters && Object.keys(this.parameters).forEach(function (name) {
		var param = this.parameters[name];
		if (!param.description) {
			throw new Error('missing description for parameter: ' + name);
		}
		param.optional = !!param.optional;
		param.name = name;
		param.type = param.type || 'query';
		if (!/^(query|body|path)$/.test(param.type)) {
			throw new Error('invalid type: ' + param.type.toString() + ' for ' + name + ' parameter. only \'body\', \'path\' and \'query\' are accepted');
		}
		if (param.type === 'path' && foundParams.indexOf(name) === -1) {
			throw new Error('found path parameter: ' + name + ' but not defined in route');
		}
	}.bind(this));

	// handle in built-in events
	if (this.beforeEvent) {
		if (!_.isString(this.beforeEvent)) {
			throw new Error('unsupported type for beforeEvent "' + this.beforeEvent + '". must be a string which is the name of the event');
		}
	}
	if (this.afterEvent) {
		if (!_.isString(this.afterEvent)) {
			throw new Error('unsupported type for afterEvent "' + this.afterEvent + '". must be a string which is the name of the event');
		}
	}
	if (this.eventTransformer) {
		if (_.isString(this.eventTransformer)) {
			var fn = path.resolve(process.cwd(), this.eventTransformer);
			if (!fs.existsSync(fn)) {
				throw new Error('path not found to eventTransformer module:  ' + fn);
			}
			this.eventTransformerSource = fn;
			this.eventTransformer = require(fn);
		} else if (!_.isFunction(this.eventTransformer)) {
			throw new Error('unsupported type for eventTransformer "' + this.eventTransformer + '". must be either path to a module or function');
		} else {
			this.eventTransformerSource = this.eventTransformer;
		}
	}
}

function makeResponseKey(value, count) {
	// remove any slashes in the case of something like appc.foo/modelname
	var i = value.lastIndexOf('/');
	if (i > 0) {
		value = value.substring(i + 1);
	}
	return pluralize(value.toLowerCase(), count);
}

API.on = function on() {
	APIClass.on.apply(APIClass, arguments);
};

API.removeListener = function removeListener() {
	APIClass.removeListener.apply(APIClass, arguments);
};

API.removeAllListeners = function removeAllListeners() {
	APIClass.removeAllListeners.apply(APIClass, arguments);
};

// NOTE: this is internal and only used by the test and should never be called directly
API.clearAPIs = function clearAPIs() {
	apis.length = 0;
};

/**
 * Returns an API for the given path.
 * @static
 * @param {String} path API path.
 * @returns {Array<Arrow.API>}
 */
API.getAPIsForPath = function (path) {
	return apiPaths[path];
};

/**
 * Returns a constructor function to generate a new API endpoint.
 * Pass the constructor an Arrow configuration object, Arrow instance, and optionally a filename.
 * @static
 * @param {Dictionary<Arrow.API>} impl Implementation object.
 * @returns {Function}
 * @throws {Error} Missing required parameter.
 */
API.extend = function classExtend(impl) {
	return function APIConstructor(config, arrow, fn) {
		if (!arrow) {
			throw new Error('invalid constructor. must be called with arrow instance as 2nd argument');
		}
		var api = new API(impl, config, arrow);
		api.filename = fn;
		fn && (api.timestamp = fs.statSync(fn).mtime);
		return api;
	};
};

/**
 * Returns a constructor function to generate a new API by extending this instance.
 * Pass the constructor an Arrow configuration object, Arrow instance, and optionally a filename.
 * @param {Dictionary<Arrow.API>} impl Implementation object.
 * @returns {Function}
 * @throws {Error} Missing required parameter.
 */
API.prototype.extend = function instanceExtend(impl) {
	return API.extend(_.merge(this, impl));
};

/**
 * Handles event transformation if a eventTransformer property is set on the API
 */
API.prototype.executeEventTransform = function (when, name, data, req, resp, callback) {
	if (this.eventTransformer) {
		var context = {
			when: when,
			name: name,
			request: req,
			response: resp,
			data: req.params,
			api: this,
			payload: _.cloneDeep(data)
		};
		if (this.eventTransformer.length > 1) {
			this.eventTransformer(context, callback);
		} else {
			var newdata = this.eventTransformer(context, this);
			callback(null, newdata);
		}
	} else {
		callback(null, data);
	}
};

/**
 * for a request, return a url
 */
function getRequestURL(req) {
	return 'http' + (req.secure ? 's' : '') + '://' + req.get('host') + req.originalUrl;
}

/**
 * Handles sending pubsub event if beforeEvent property is set on the API
 */
API.prototype.executeBeforeEvent = function (req, resp, callback) {
	var name = this.beforeEvent;
	if (req.server.pubsub) {
		var payload = {
			parameters: req.params,
			type: 'before',
			name: this.nickname,
			path: this.path,
			method: this.method,
			reqid: req.getId(),
			url: getRequestURL(req),
			serverid: process.env.serverId,
			appid: process.env.appid
		};
		var pubsub = req.server.pubsub;
		this.executeEventTransform('before', name, payload, req, resp, function (err, data) {
			if (err) { return callback(err); }
			if (data !== false) { pubsub.publish(name, data || payload); }
			callback();
		});
	} else {
		req.logger.warn('before event: ' + name + ' not fired since there is no configured pubsub connection');
		callback();
	}
};

/**
 * Handles sending pubsub event if afterEvent property is set on the API
 */
API.prototype.executeAfterEvent = function (req, resp, callback) {
	var name = this.afterEvent;
	if (req.server.pubsub) {
		var body = resp.unformattedBody || resp.rawbody || resp.body;
		var data = body && body.key && body[body.key] || body;
		var payload = {
			response: data,
			type: 'after',
			name: this.nickname,
			path: this.path,
			method: this.method,
			url: getRequestURL(req),
			serverid: process.env.serverId,
			appid: process.env.appid
		};
		var pubsub = req.server.pubsub;
		this.executeEventTransform('after', name, payload, req, resp, function (err, data) {
			if (err) { return callback(err); }
			if (data !== false) { pubsub.publish(name, data || payload); }
			callback();
		});
	} else {
		req.logger.warn('after event: ' + name + ' not fired since there is no configured pubsub connection');
		callback();
	}
};

function InteruptedError() {}

function invoke(api, fn, req, resp, tx, next, isBlock) {
	// console.log('invoke', fn, new Error().stack);
	// if we've already invoked an api, we only run it once
	if (!isBlock && req._alreadyCalled) {
		return next();
	}
	// if we have a callback, handle it async
	req.params && tx && tx.addArguments(req.params);
	if (fn.length === 3) {
		var alreadyCalled = false;
		var callback = function invokeCallback(err, results) {
			// Did we receive our results from an async waterfall?
			if (results && Array.isArray(results) && results.length === 2) {
				// If so, one will be truthy, and the other falsy, or both will be falsy.
				if ((!results[0] && results[1]) || (results[0] && !results[1]) || (!results[0] && !results[1])) {
					results = results[0];
				}
			}
			// only run the callback once and only invoke the first API available, otherwise fall through
			// to the next middleware in the stack
			if (!isBlock && (alreadyCalled || req._alreadyCalled)) {
				if (next) {
					try { next(); } catch (E) { req.logger.trace(E); }
				}
				next = null;
				return;
			}
			alreadyCalled = true;
			// this is an interrupted chain. stop processing
			if (err === false) {
				return next(new InteruptedError());
			}
			if (tx) {
				if (err) {
					tx.addError(err);
				}
				if (results) {
					tx.addResult(results);
				}
				tx.end();
			}
			if (resp._sendCalled || isBlock) {
				return next(err);
			}
			// err && console.log(err && err.stack);
			if (err) {
				if (!err.message && /trying to remove, couldn't find record with primary key:/.test(err)) {
					return resp.notFound(next);
				}
				return next(err);
			} else {
				var method = api.method,
					noResult = (results === undefined || results === null);
				switch (method) {
					case 'GET':
						if (!isBlock) { req._alreadyCalled = !noResult; }
						return noResult ? next() : resp.success(results, next);
					case 'POST':
						if (results && _.isFunction(results.getMeta) && results.getMeta('includeResponseBody')) {
							if (!isBlock) { req._alreadyCalled = true; }
							return resp.success(results, next);
						} else if (results && results.getPrimaryKey && api.generated) {
							if (!isBlock) { req._alreadyCalled = true; }
							if (api.nickname === 'Upsert' && api.generated && req.params.id) {
								return resp.noContent(next);
							} else {
								return resp.redirectPath(results.getPrimaryKey(), next, 201);
							}
						}
						break;
					case 'PUT':
					case 'DELETE':
						if (!isBlock) { req._alreadyCalled = true; }
						return resp.noContent(next);
					default:
						break;
				}
				// indicate we've already done an API so only one API is ever matched
				if (!isBlock) { req._alreadyCalled = !noResult; }
				return noResult ? next() : results ? resp.success(results, next) : resp.noContent(next);
			}
		};
		fn.apply(null, [req, resp, callback]);
	} else {
		// else if we don't have a callback we can just deal with it synchronously
		fn.apply(null, [req, resp]);
		tx && tx.end();
		next();
	}
}

/*
 * Gets the middleware block that provides access to the
 * API's action implementation.
 * Pass the function returned by this method an Express request object,
 * Express response object, Arrow Response object and the function to call next.
 * @returns {Function}
 */
API.prototype.getMiddleware = function getMiddleware() {
	var api = this,
		metadata,
		apiname = this.nickname,
		arrow = this.arrow;
	if (api.generated) {
		metadata = _.pick(api, 'path', 'method', 'parameters');
		if (api.pre) {
			metadata.pre = api.pre.name;
		}
		if (api.post) {
			metadata.post = api.post.name;
		}
		if (api.model) {
			metadata.model = api.model.name;
		}
	}
	return function MiddlewareConstructor(req, resp, r, next) {
		if (req._middlewareExecuted) {
			return next();
		}
		req._middlewareExecuted = true;
		var _next = next;
		req.logmetadata = true;
		return api.arrow.executeSecurityMiddleware(req, resp, function (err) {
			if (err) { return next(err); }
			// if the auth plugin changed the status code, bail
			if (resp.statusCode !== 200) {
				return next();
			}
			// if the api is not allowed, return 405
			if (!api.enabled) {
				return r.notAllowed(next);
			}
			try {
				next = function next() {
					// ensure next only ever gets called once
					if (_next) {
						var fn = _next;
						_next = null;
						return fn.apply(this, arguments);
					}
				};

				// we use our hidden variable from our main middleware because express
				// overwrites for each call to next. however, in route params it's there in params
				// so we have to merge them
				req.params = _.merge(_.merge({}, req._params), req.params);
				var qkeys = req.query && Object.keys(req.query),
					bkeys = req.body && _.isObject(req.body) && !(req.body instanceof Buffer) && Object.keys(req.body);

				// validate incoming parameters (query only)
				if (qkeys && qkeys.length && !this.parameters && !this.wildcardParameters) {
					return r.badRequest('query parameters sent but missing in API definition', next);
				}
				if (bkeys && bkeys.length && !this.parameters && !this.wildcardParameters) {
					return r.badRequest('body parameters sent but missing in API definition', next);
				}

				arrow.logger.trace('┌ Processing Request:');
				arrow.logger.trace('├ url', req.url);
				if (req.body && Object.keys(req.body).length) {
					if (req.body instanceof Buffer) {
						arrow.logger.trace('├ body', '<Buffer length:' + req.body.length + '>');
					} else {
						arrow.logger.trace('├ body', req.body);
					}
				}
				if (req.query && Object.keys(req.query).length) {
					arrow.logger.trace('├ query', req.query);
				}
				if (req.params && Object.keys(req.params).length) {
					arrow.logger.trace('├ params', req.params);
				}
				if (req.files) {
					arrow.logger.trace('├ files', req.files);
				}
				arrow.logger.trace('└');

				if (this.parameters) {
					var params = Object.keys(this.parameters);
					for (var c = 0; c < params.length; c++) {
						var key = params[c],
							param = this.parameters[key],
							required = (param.required === undefined && param.optional === undefined && param.default === undefined) || !param.optional || param.required;
						if (req.query && key in req.query) {
							qkeys.splice(qkeys.indexOf(key), 1);
							if (!(key in req.params)) {
								req.params[key] = req.query[key];
							}
						} else if (req.body && key in req.body) {
							bkeys.splice(bkeys.indexOf(key), 1);
							if (!(key in req.params)) {
								req.params[key] = req.body[key];
							}
						} else if (req.files && key in req.files) {
							req.params[key] = req.files[key].file;
						} else if (required && param.type !== 'path' && !(key in req.params)) {
							arrow.logger.trace('required params key not found: ' + key, param);
							return r.badRequest('required ' + param.type + ' parameter: ' + key + ' missing', next);
						}
					}
					if (qkeys && qkeys.length && !this.wildcardParameters) {
						arrow.logger.trace('required query key not found: ', qkeys);
						return r.badRequest('query parameters: ' + qkeys.join(', ') + ' missing in API definition', next);
					}
					if (bkeys && bkeys.length && !this.wildcardParameters) {
						arrow.logger.trace('required body key not found: ', bkeys);
						return r.badRequest('body parameters: ' + bkeys.join(', ') + ' missing in API definition', next);
					}
				}
				// NOTE: we don't need to validate path parameters since we get that for free
				// as part of express routing

				// map in our model if we have one
				if (this.model) {
					req.model = r.model = this.model.createRequest(req, resp);
				} else if (this.models) {
					req.models = r.models = this.models.forEach(function modelIterator(model) {
						return model.createRequest(req, resp);
					});
				}
				if (this.response) {
					req.responseModel = r.responseModel = this.response.createRequest(req, resp);
				}

				// if we have blocks, we need to execute them
				if (this.pre || this.post || this.beforeEvent || this.afterEvent) {
					var tasks = [];
					if (this.pre) {
						this.pre.forEach(function preIterator(block) {
							tasks.push(function preIteratorTask(next_) {
								try {
									var pretx = req.tx && req.tx.start('pre:' + block._name, false, block.filename, block.description);
									invoke(api, block, req, r, pretx, next_, true);
								}
								catch (E) {
									next_(E);
								}
							});
						});
					}
					if (this.beforeEvent) {
						tasks.push(function beforeEventTask(next_) {
							try {
								var pretx = req.tx && req.tx.start('preevent:' + api.beforeEventName, false, api.beforeEventSource);
								invoke(api, api.executeBeforeEvent.bind(api), req, r, pretx, next_, true);
							}
							catch (E) {
								next_(E);
							}
						});
					}
					var action_ = this.action;
					tasks.push(function actionTask(next_) {
						try {
							var actiontx = req.tx && req.tx.start('action:api:' + apiname, false, api.filename, api.description, metadata);
							invoke(api, action_, req, r, actiontx, next_);
						}
						catch (E) {
							next_(E);
						}
					});
					if (this.post) {
						this.post.forEach(function postIterator(block) {
							tasks.push(function postIteratorTask(next_) {
								try {
									var posttx = req.tx && req.tx.start('post:' + block._name, false, block.filename, block.description);
									invoke(api, block, req, r, posttx, next_, true);
								}
								catch (E) {
									next_(E);
								}
							});
						});
					}
					if (this.afterEvent) {
						tasks.push(function afterEventTask(next_) {
							try {
								var pretx = req.tx && req.tx.start('postevent:' + api.afterEventName, false, api.afterEventSource);
								invoke(api, api.executeAfterEvent.bind(api), req, r, pretx, next_, true);
							}
							catch (E) {
								next_(E);
							}
						});
					}
					return async.series(tasks, function callback(err) {
						if (err && err instanceof InteruptedError) {
							// this is OK, just used to stop processing
							err = null;
						}
						if (err) { r.error(err); }
						r.flushBody();
						if (!err) { next(); }
					}.bind(this));
				} else {
					var actiontx = req.tx && req.tx.start('action:api:' + apiname, false, api.filename, api.description, metadata);
					invoke(api, this.action, req, r, actiontx, function (err) {
						if (err && err instanceof InteruptedError) {
							// this is OK, just used to stop processing
							err = null;
						}
						if (err) {
							req.log.trace(err.stack);
							r.error(err, next);
						}
						r.flushBody();
						actiontx && actiontx.end();
						if (!err) { next(); }
					});
				}
			}
			catch (E) {
				console.error(E.stack);
				req.logger.error(E, E.stack);
				next(E);
			}
		}.bind(this));
	}.bind(this);
};

/**
 * Removes the API from the Arrow instance.
 * @param {Object} arrow Arrow instance.
 * @param {Function} [callback] Callback passed an Error object (or null if successful) and the removed API.
 */
API.prototype.remove = function (arrow, callback) {
	var self = this;
	arrow.apis = _.reject(arrow.apis, function (e) {
		return e === self;
	});
	// remove the routing entry from express
	var array = arrow.app._router.stack;
	var keys = Object.keys(formatters.extensions).join('|');
	var removeIndices = [];
	for (var c = 0; c < array.length; c++) {
		var entry = array[c],
			re = new RegExp('^' + this.path.replace(/\//g, '\\/') + '\\.(' + keys + ')$');
		if (entry.route && (entry.route.path === this.path || re.test(entry.route.path))) {
			var stack = entry.route.stack;
			for (var i = 0; i < stack.length; i++) {
				if (stack[i].method.toLowerCase() === this.method.toLowerCase()) {
					stack.splice(i, 1);
					break;
				}
			}
			// no more routes, mark to later remove it
			if (stack.length === 0) {
				removeIndices.push(entry);
			}
		}
	}
	if (removeIndices.length) {
		removeIndices.forEach(function (entry) {
			for (var c = 0; c < array.length; c++) {
				if (entry === array[c]) {
					array.splice(c, 1);
				}
			}
		});
	}
	callback && callback(null, this);
};

/**
 * Reloads the API for the Arrow instance.
 * @param {Object} arrow Arrow instance.
 * @param {Function} [callback] Callback passed an Error object (or null if successful) and the reloaded API.
 */
API.prototype.reload = function (arrow, callback) {
	if (this.filename) {
		this.timestamp = fs.statSync(this.filename).mtime;
		var old = this;
		// remove the route
		this.remove(arrow, function () {
			// remove it from the arrow
			arrow.loadApi(old.filename, function (err, api) {
				callback && callback(err, old, api);
			});
		});
	} else {
		callback && callback(null, this);
	}
};

/**
 * Binds this API to the app instance
 * @param {Object} app App instance.
 * @throws {Error} Missing app instance.
 */
API.prototype.bind = function (app) {
	if (!app) { throw new Error('app required for bind'); }
	var method = (this.method || 'GET').toLowerCase(),
		middleware = this.middleware = this.getMiddleware(),
		api = this;
	this.app = app;
	app.logger.debug('binding' + (this.enabled ? '' : ' disabled') + ' api (' + method + ') ' + this.path, this.generated ? '[model]' : '[api]', 'sort:' + this.sort);

	function createAPIBinding(preCallback) {
		return function apiBinding(req, resp, next) {
			if (preCallback) {
				preCallback(req);
			}
			var status = resp.statusCode,
				r = new Response(req, resp, api);
			middleware(req, resp, r, function middlewareCallback(err, result) {
				if (err) {
					return next(err);
				}
				if (result) {
					return next(null, result);
				}
				if (status === resp.statusCode) {
					next();
				} else {
					r.flushBody();
				}
				r.done();
			});
		};
	}

	// add a route for each extension
	Object.keys(formatters.extensions).forEach(function (extension) {
		var mimeType = formatters.extensions[extension];
		var extensionRoute = app[method](api.path + '.' + extension, createAPIBinding(function (req) {
			req.headers.accept = mimeType;
		}));
	});

	// add the explicit route
	this.route = app[method](this.path, createAPIBinding());
};

function emptyFn() {}

/**
 * Executes this API with the specified parameters.
 * Results are sent to to the callback.
 * @param {Object} params API parameters.
 * @param {Function} callback Callback passed an Error object (or null if successful) and the results.
 */
API.prototype.execute = function (params, callback) {
	if (_.isFunction(params)) {
		callback = params;
		params = {};
	}
	var request = {__proto__: this.app.request, app: this.app};
	var response = {__proto__: this.app.response, app: this.app};

	request.url = this.path;
	request.params = params;
	request.method = this.method;
	request.headers = {'accept': 'application/json'};
	response.headers = response._headers = {};
	response.setHeader = response.set = emptyFn;
	request.Arrow = {};
	request.session = response.session = request.Arrow;
	request.session.destroy = response.session.destroy = emptyFn;
	request.logger = response.logger = request.log = response.log = this.arrow.logger;
	request.tx = this.txenabled && new RequestTx(request, response, this.arrow.config.admin.prefix);
	request.skipSecurityCheck = true;
	request.server = this.arrow;

	var r = new Response(request, response, this);
	r.flushBody = emptyFn;
	r.skipFormatting = true;

	try {
		// execute the middleware
		this.middleware(request, response, r, function (err, result) {
			// handle error scenarios
			if (err) { return callback(err); }
			result = r.rawbody || result;
			if (result && result.success === false) {
				err = new Error(result.message || 'error');
				err.result = result;
				err.code = result.code;
				return callback(err);
			} else if (response.statusCode > 299) {
				var http = require('http');
				err = new Error(http.STATUS_CODES[response.statusCode]);
				err.body = r.rawbody;
				err.code = response.statusCode;
				return callback(err);
			}
			// make sure to convert any collection, models into JSON
			var value = result && result.key && result[result.key];
			if (value && (value instanceof Arrow.Instance || value instanceof Arrow.Collection || _.isFunction(value.toJSON))) {
				result[result.key] = value.toJSON();
			}
			return callback(null, result);
		});
	}
	catch (E) {
		callback(E);
	}
};

module.exports = API;
