/*
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */

// jscs:disable
/**
 * @class Arrow.Middleware
 */
// jscs:enable

var express = require('express'),
	path = require('path'),
	fs = require('fs'),
	async = require('async'),
	crypto = require('crypto'),
	cookieParser = require('cookie-parser'),
	bodyParser = require('body-parser'),
	compression = require('compression'),
	sessions = require('client-sessions'),
	busboy = require('connect-busboy'),
	_ = require('lodash'),
	Arrow = require('./arrow'),
	debug = require('debug')('appc:middleware'),
	tmpdir = require('os').tmpdir(),
	cache = {},
	renderers = {};

// jscs:disable jsDoc

function Middleware(app, dirname, sessionConfig, config) {
	config = config || {};
	this.app = app;
	app.set('x-powered-by', false);
	// setup a handler that will emit the 'after' event after the request completes
	var limit = (config.bodyParser || {}).limit || '1mb';
	var secret = config.cookieSecret;
	app.use(cookieParser(secret));
	app.use(bodyParser.text({limit: limit}));
	app.use(bodyParser.raw({limit: limit}));
	app.use(bodyParser.json({limit: limit}));
	app.use(bodyParser.urlencoded({extended: false, limit: limit}));
	app.use(busboy(config.busboy || {}));
	app.use(function (req, resp, next) {
		if (req.busboy && req.headers['content-type'] && req.headers['content-type'].indexOf('multipart/form-data') === 0) {
			req.files = {};
			req.fields = {};
			var total = 0, count = 0, finished;
			req.busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {
				var tmpfile = path.join(tmpdir, 'tmp-' + (Date.now()) + '_' + filename);
				total++;
				debug('file ' + fieldname + ', now total is', total);
				req.files[fieldname] = {
					file: tmpfile,
					filename: filename,
					encoding: encoding,
					mimetype: mimetype
				};
				var stream = fs.createWriteStream(tmpfile);
				stream.on('close', function () {
					debug('stream close, total=', total, 'count=', count);
					if (++count === total && finished) {
						total = -1;
						debug('calling next 0', req.fields);
						debug('files=', req.files);
						process.nextTick(next);
					}
				});
				file.pipe(stream);
			});
			req.busboy.on('field', function (fieldname, val, fieldnameTruncated, valTruncated) {
				debug('field', fieldname);
				req.fields[fieldname] = {
					value: val,
					fieldnameTruncated: fieldnameTruncated,
					valueTruncated: valTruncated
				};
			});
			req.busboy.on('finish', function (err) {
				finished = true;
				debug('finish called total=', total, 'count=', count);
				if (err) { return next(err); }
				if (total && count === total) {
					debug('calling next 1', req.fields);
					process.nextTick(next);
				} else if (total === 0) {
					debug('calling next 2', req.fields);
					process.nextTick(next);
				}
			});
			req.pipe(req.busboy);
		} else {
			next();
		}
	});
	app.use(function (req, resp, next) {
		if (req.body && _.isObject(req.body) && !(req.body instanceof Buffer)) {
			// we add to _params because express changes for each next
			req.params = req._params = _.merge(req.params, req.body);
		} else {
			req._params = req.params;
		}
		if (req.files || req.fields) {
			req.files && Object.keys(req.files).forEach(function (name) {
				req.params[name] = req.files[name].file;
			});
			req.fields && Object.keys(req.fields).forEach(function (name) {
				req.params[name] = req.fields[name].value;
			});
		}
		next();
	});
	app.use(compression());
	app.on('after', function (req, resp) {
		if (req && req.files) {
			setTimeout(function () {
				async.each(req.files, function (entry, cb) {
					fs.unlink(entry.file, cb);
				});
				req.files = null;
			}, 500);
		}
		if (req && req.res) {
			req.res.req = null;
		}
	});

	if (sessionConfig) {
		setupSession(app, sessionConfig);
	}

	var webDirectory = dirname && path.join(dirname, 'web'),
		publicDirectory = webDirectory && path.join(webDirectory, 'public');

	if (publicDirectory && fs.existsSync(publicDirectory)) {
		app.use(express.static(publicDirectory));
	}
	if (webDirectory) {
		registerRenderers(app, webDirectory);
	}

	var writeHead = express.response._originalWriteHead || express.response.writeHead;
	if (!express.response._originalWriteHead) {
		express.response._originalWriteHead = writeHead;
	}
	express.response.writeHead = function () {
		// if the user by passes this class and does their own writeHead, end, etc.
		// we need to catch it since it's out of order the way we do it in response.js
		// so just flag it and when we see this below, just assume we're good to go
		var called = this.bodyFlushed;
		this.bodyFlushed = this._flushBodyCalled = true;
		writeHead.apply(this, arguments);
		if (!called) {
			// if we get here it's because we're doing a non-API Route
			// in which case we need to trigger after event
			app.emit('after', this.req, this.req.res);
		}
	};
	// called by the response.js
	express.response._flushBody = function (content) {
		// var logger = (Arrow.getGlobal() || {}).logger;
		// logger && logger.trace('_flushBody', new Error().stack);
		if (this.bodyFlushed) { return; }
		addEndHeaders(this.req, this, content);
		this.bodyFlushed = this._flushBodyCalled = true;
		this.end(content);
		app.emit('after', this.req, this.req.res);
	};
	var setHeader = express.response._originalSetHeader || express.response.setHeader;
	if (!express.response._originalSetHeader) {
		express.response._originalSetHeader = setHeader;
	}
	express.response.setHeader = function (k, v) {
		this._headers = this._headers || {};
		if (v) {
			setHeader.apply(this, arguments);
			this._headers[k.toLowerCase()] = v;
		} else {
			this.removeHeader(k);
		}
	};
	var removeHeader = express.response._originalRemoveHeader || express.response.removeHeader;
	if (!express.response._originalRemoveHeader) {
		express.response._originalRemoveHeader = removeHeader;
	}
	express.response.removeHeader = function (k) {
		removeHeader.apply(this, arguments);
		if (this._headers) {
			delete this._headers[k.toLowerCase()];
		}
	};
	express.response.headers = function () {
		return this._headers;
	};
	Object.defineProperty(express.response, 'contentType', {
		set: function (value) {
			this.setHeader('Content-Type', value);
		},
		get: function () {
			return this._headers['content-type'] || this._headers['Content-Type'];
		}
	});
	var render = express.response._originalRender || express.response.render;
	if (!express.response._originalRender) {
		express.response._originalRender = render;
	}
	express.response.render = function (name, locals) {
		if (locals && _.isObject(locals)) {
			// make sure that we render any ORM objects as JSON instead of their real classes
			locals = _.cloneDeep(locals, objectCustomizer);
		}
		return render.apply(this, arguments);
	};
}

/*
 * Wrap response.send to add end headers.
 */
var expressResponseSend = express.response.send;
express.response.send = function wrappedResponseSend(content) {
	if (_.isNumber(arguments[0])) {
		throw new Error('don\'t use resp.send with number. call resp.status instead');
	}
	addEndHeaders(this.req, this, content);
	expressResponseSend.call(this, content);
};

/*
 * convert our value into a valid JSON object
 */
function objectCustomizer(value) {
	if (value === undefined || value === null) { return value; }
	// return serialized JSON versions of our ORM data objects
	if (value instanceof Arrow.Instance || value instanceof Arrow.Collection || _.isFunction(value.toJSON)) {
		return value.toJSON();
	} else if (Array.isArray(value)) {
		var array = [];
		value.forEach(function (o) {
			array.push(_.cloneDeep(o, objectCustomizer));
		});
		return array;
	} /* don't serialize functions*/ else if (_.isFunction(value)) {
		return undefined;
	} else if (_.isObject(value)) {
		var obj = {};
		Object.keys(value).forEach(function (k) {
			var v = _.cloneDeep(value[k], objectCustomizer);
			obj[k] = v;
		});
		return obj;
	}
	return value;
}

function addEndHeaders(req, resp, content) {
	if (req && req.tx) {
		resp.setHeader('Response-Time', String(Date.now() - req.tx.started));
	}
	if (content) {
		var c = String(content);
		resp.setHeader('Content-MD5', md5(c));
	}
}

function md5(value) {
	var hash = crypto.createHash('md5');
	hash.update(String(value));
	return hash.digest('hex');
}

function setupSession(app, sessionConfig) {
	app.use(
		sessions({
			// load from configuration
			encryptionAlgorithm: sessionConfig.encryptionAlgorithm || 'aes256',
			encryptionKey: new Buffer(sessionConfig.encryptionKey || '8yOAsrmwQ7jcUJC7SS1bBmGLRYW0g0ucOwSDjmSOnKg=', 'base64'),
			signatureAlgorithm: sessionConfig.signatureAlgorithm || 'sha512-drop256',
			signatureKey: new Buffer(sessionConfig.signatureKey || 'ub9VhdXWtQ6oN2UwhvkiRO0eS9S6OgAbHOAAPjKbW+Qd/A2OYGiZdjcrNliQU+ho4e5Dz5Wj4z2ggfefRjU3ug==', 'base64'),
			cookieName: 'Arrow', // cookie name dictates the key name added to the request object - do not changed this or you will get an error
			secret: sessionConfig.secret || crypto.randomBytes(24).toString('base64'), // should be a large unguessable string
			duration: sessionConfig.duration || 24 * 60 * 60 * 1000, // how long the session will stay valid in ms
			activeDuration: sessionConfig.activeDuration || 1000 * 60 * 5, // if expiresIn < activeDuration, the session will be extended by activeDuration milliseconds
			cookie: sessionConfig.cookie || {}
		})
	);
	app.use(function sessionMapper(req, resp, next) {
		// set the session value to the name of our sessions object
		req.session = req.Arrow;
		// alias destroy to reset
		req.session.destroy = req.Arrow.reset;
		try {
			next();
		}
		catch (E) {
		}
	});
}

function createRenderer(app, ext, engine) {
	var cacheable = app.enabled('view cache');
	app.engine(ext, function templateRender(filePath, options, callback) {
		var entry = cache[filePath];
		if (!entry || !cacheable) {
			entry = engine.createRenderer(engine.skipread ? null : fs.readFileSync(filePath).toString(), filePath, app);
			if (cacheable) {
				cache[filePath] = entry;
			}
		}
		if (entry.length === 3) {
			entry(filePath, options, callback);
		} else {
			callback(null, entry(options));
		}
	});
}

/**
 * Registers a renderer engine for this instance.
 * @param {ArrowRendererEngine} engine Renderer engine.
 */
Middleware.prototype.registerRendererEngine = function registerRendererEngine(engine) {
	return Middleware.registerRendererEngine(this.app, engine);
};

/**
 * Registers a renderer engine.
 * @static
 * @param {Object} app App instance.
 * @param {ArrowRendererEngine} engine Renderer engine.
 */
Middleware.registerRendererEngine = function registerRendererEngine(app, engine) {
	createRenderer(app, engine.extension, engine);
	renderers[engine.extension] = engine;
};

/**
 * @method getRendererEngine
 * @static
 * Returns a renderer engine for a given file extension.
 * @param {String} extension File extension to get a renderer engine for.
 * Built-in values are `ejs`, `hbs`, `html`, `jsx` and `md`.
 * @returns {ArrowRendererEngine}
 */
/**
 * @method getRendererEngine
 * @alias #static-method-getRendererEngine
 */
Middleware.prototype.getRendererEngine =
	Middleware.getRendererEngine = function getRendererEngine(extension) {
		return renderers[extension] || renderers[extension.substring(1)]; // in case they supplied a .
	};

function registerRenderers(app, webDirectory) {
	var viewDir = path.join(webDirectory, 'views');
	app.set('views', viewDir);
	var dir = path.join(__dirname, 'engines'),
		engines = fs.readdirSync(dir);
	engines.forEach(function (engine) {
		engine = require(path.join(dir, engine));
		if (engine.createRenderer) {
			Middleware.registerRendererEngine(app, engine);
		}
	});
	// we monkey patch express to make it easy to switch between different
	// templating engines without forcing us to register a default one
	var render = app.render;
	app.render = function (view, data, callback) {
		var ext = path.extname(view);
		if (!ext || ext === view) {
			// no extension, search for it
			var keys = Object.keys(renderers),
				found = false;
			for (var c = 0; c < keys.length; c++) {
				ext = keys[c];
				var fn = path.join(viewDir, view + '.' + ext);
				// we found a template for a specific engine, append the
				// extension to trick express into using this specific engine
				if (fs.existsSync(fn)) {
					view += '.' + ext;
					found = true;
					break;
				}
			}
			if (!found) {
				return callback(new Error('Unable to find layout "' + view + '"'));
			}
		}
		return render.call(app, view, data, callback);
	};
}

module.exports = Middleware;
