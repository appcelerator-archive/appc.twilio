/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var _ = require('lodash'),
	crypto = require('crypto'),
	async = require('async'),
	debug = require('debug')('response'),
	Formatters = require('./formatters'),
	Collection = require('./arrow').Collection;

// jscs:disable jsDoc

/**
 * This class encapsulates the all the logic for responding to
 * an HTTP request to ensure that all responses are uniform in
 * the way content is negotiated, how error codes and status
 * codes are set appropriately, etc.
 */
function Response(req, resp, api) {

	// merge in the response object
	_.merge(this, resp);

	this.request = req;
	this.response = resp;
	this.api = api;
	this.singular = api && api.singular || 'result';
	this.plural = api && api.plural || 'result';

	// map since it's easy to use logger instead of log and we want to make it transparent
	this.logger = this.log = req.log || req.server.logger;
	this.request.logger = this.request.log || this.logger;
	this.response.logger = this.response.log || this.logger;

	// make sure the session object is set
	req.session = resp.session = req.Arrow;
	req.session && (req.session.destroy = resp.session.destroy = req.Arrow.reset);

	// set utf-8 as default character set
	resp._charSet = 'utf-8';

	// these functions must be bound to the underlying correct response this
	['cookie', 'clearCookie', 'append', 'status', 'vary'].forEach(function (key) {
		this[key] = (this[key] || resp[key]).bind(resp);
	}.bind(this));

	// override so we use our function which doesn't try and go through
	// accept dance again since we want to use our own formatter engine
	// which orders formatters in the way we want
	var oldFormat = resp.format;
	resp.format = function format(body, cb) {
		if (body instanceof Error) {
			// let the restify format handle errors
			return oldFormat.apply(resp, arguments);
		}
		var type = this.contentType || this.getHeader('Content-Type');
		// append charset if we don't have one
		if (this._charSet && type.indexOf('charset=') === -1) {
			type = type + '; charset=' + this._charSet;
			// set to null so restify doesn't set it again
			this._charSet = null;
		}
		type && this.setHeader('Content-Type', type);
		return body;
	};

	// monkey patch our send so we can capture the response
	var realSend = this.response.send,
		realScope = this.response,
		self = this,
		sendBody,
		sendRawBody,
		alreadySent,
		statusCode,
		logger = this.logger;

	this.flushBody = function () {
		if (alreadySent || self.insideSend) { return; }
		alreadySent = true;
		// if sent in use that, otherwise what we have set, then fall back to 200
		var status = statusCode || realScope.statusCode || 200;
		realScope.status(status);
		var ct = realScope.contentType;
		if (ct && realScope.get('Content-Type') !== ct) {
			realScope.set('Content-Type', ct);
		}
		try {
			var content = sendBody || sendRawBody;
			if (content && typeof(content) === 'object') {
				content = JSON.stringify(content);
				this.response.setHeader('Content-Length', Buffer.byteLength(content));
			}
			realScope._flushBody(content);
		}
		catch (E) {
			logger && logger.error(E && E.stack || E);
		}
		if (logger) {
			var stopRecord = {
				headers: realScope.headers(),
				status: status,
				body: sendBody,
				ignore: true,
				type: 'response'
			};
			// this logs NOT TO CONSOLE but to our internal logger. important for transaction logging.
			logger.info(stopRecord);
		}
	};

	// allow the body to be mutated
	Object.defineProperty(this, 'body', {
		set: function (value) {
			sendBody = value;
			if (_.isString(value)) {
				this.response.setHeader('Content-Length', Buffer.byteLength(value));
			} else {
				sendRawBody = sendBody;
			}
		},
		get: function () {
			return sendBody;
		}
	});

	// allow the body to be mutated
	Object.defineProperty(this, 'rawbody', {
		set: function (value) {
			sendRawBody = value;
		},
		get: function () {
			return sendRawBody;
		}
	});

	// monkey patch send to delay sending until flushBody
	// is called by the api once all the blocks have run
	// to allow post blocks to potentially change the response
	this.response.send = function (code, body) {
		if (!_.isNumber(code)) {
			body = code;
			code = this.statusCode;
		} else {
			statusCode = code;
		}
		if (body && body instanceof Error) {
			body = body.message || body;
		}
		// overwrite the body
		sendBody = body;
		self._sendCalled = true;
	};

	if (this.logger) {
		// send the request data
		var startRecord = {
			ignore: true,
			type: 'request',
			headers: this.request.headers,
			body: this.request.body,
			method: this.request.method
		};
		// this logs NOT TO CONSOLE but to our internal logger. important for transaction logging.
		this.logger.info(startRecord);
	}
}

/**
 * called when the resonse is done and can be cleaned up
 */
Response.prototype.done = function () {
	var self = this;
	// delay cleanup to ensure that we're all done
	setTimeout(function () {
		if (self.request.model) {
			self.request.model.endRequest();
			self.request.model = null;
		}
		if (self.request.models) {
			self.request.models.forEach(function (model) {
				model.endRequest();
			});
			self.request.models = null;
		}
		if (self.request.responseModel) {
			self.request.responseModel.endRequest();
			self.request.responseModel = null;
		}
		self.response = null;
		self.request = null;
		self.logger = null;
		self.api = null;
		self.singular = null;
		self.plural = null;
		self.rawbody = null;
		self.body = null;
		self.unformattedBody = null;
	}, 1000);
};

Response.prototype.setHeader =
	Response.prototype.set = function (k, v) {
		this.response.set(k, v);
	};

/**
 * response is responsible for perform content negotiation with the client
 * and sending the appropriate response back based on the 'Accept' header
 */
Response.prototype.send = function send(body, key, callback) {
	this.rawbody = this.body = this.unformattedBody = body;
	if (body instanceof Error || body instanceof Buffer) {
		this.response.send(body);
		return callback && callback();
	} else if (typeof(body) === 'string') {
		this.response.send(body);
		return callback && callback();
	} else {
		try {
			var formatType = this.request.accepts(Formatters.formats);
			if (!formatType && this.request.headers.accept) {
				// we provide a more loose accept parsing then the built-in module
				for (var c = 0; c < Formatters.formats.length; c++) {
					var fmt = Formatters.formats[c];
					if (this.request.headers.accept.indexOf('/' + fmt) > 0 || this.request.headers.accept === fmt) {
						formatType = fmt;
						break;
					}
				}
			}
			if (formatType) {
				this.request.formatType = formatType;
				var formatter = Formatters.formatters[formatType];
				// since this is async, we need to indicate we're still processing so that
				// flushBody doesn't go ahead and try and send the body
				this.insideSend = true;
				formatter(this.request, this.response, body, this.singular || key, this.plural || key, function formatCallback(err, body) {
					this.insideSend = false;
					if (err) {
						this.logger.debug(err);
						// error while formatting - probably cannot format to that type (usually csv)
						this.response.send(406);
						return callback && callback();
					}
					if (body) {
						if (!this.skipFormatting) {
							this.rawbody = this.body = body;
							this.response.setHeader('Content-Length', Buffer.byteLength(body));
						}
						this.response.send(body);
					} else {
						this.response.send(204);
					}
					callback && callback();
				}.bind(this));
			} else {
				this.response.send(406);
				return callback && callback();
			}
		}
		catch (E) {
			this.logger.debug(E.stack);
			this.error(E);
			return callback && callback();
		}
	}
};

Response.prototype.ok =
	Response.prototype.success = function success(object, properties, callback) {
		// if we just passed in a callback, just assume an empty object
		if (arguments.length === 1 && _.isFunction(arguments[0]) && !arguments[0].toJSON) {
			callback = object;
			properties = {};
			object = {};
		}
		if (_.isFunction(properties)) {
			callback = properties;
			properties = {};
		}
		var response = _.merge({success: true, 'request-id': this.request.getId()}, properties || {}),
			isCollection = (object && typeof(object) === 'object' && object.length !== undefined),
			key = (isCollection || Array.isArray(object)) ? this.plural : this.singular;

		if (isCollection && object.length === 0 && this.request.method !== 'GET') {
			return this.noContent(callback);
		}
		if (this.request.method === 'PUT' || this.request.method === 'DELETE') {
			return this.noContent(callback);
		}
		response.key = key;
		response[key] = object;
		// console.log('sending ', this.request.method, this.request.path);
		// console.log('sending response', typeof(response), response, new Error().stack);
		this.send(response, key, callback);
	};

Response.prototype.failure = function failure(status, message, code, url, callback) {
	if (_.isObject(status) && arguments.length === 2) {
		return this.failed(status, message);
	}
	var response = {
		message: message,
		code: code,
		success: false,
		'request-id': this.request.getId()
	};
	// console.log(response, new Error().stack);
	if (url) {
		response.url = url;
	}
	if (status !== 200) {
		this.response.status(status);
	}
	this.response.logger.info({
		ignore: true,
		response: response,
		error: true,
		status: status,
		headers: this.response.headers
	});
	this.send(response, null, callback);
};

Response.prototype.notfound =
	Response.prototype.notFound = function notfound(code, url, callback) {
		if (_.isFunction(code)) {
			callback = code;
			code = 404;
			url = null;
		}
		return this.failure(404, 'Not Found', code, url, callback);
	};

Response.prototype.notallowed =
	Response.prototype.notAllowed = function notAllowed(callback) {
		return this.failure(405, 'Not Allowed', 405, null, callback);
	};

Response.prototype.created = function created(callback) {
	return this.failure(201, 'Created', null, null, callback);
};

Response.prototype.badrequest =
	Response.prototype.badRequest = function badRequest(message, code, url, callback) {
		if (_.isFunction(code)) {
			callback = code;
			code = 400;
			url = null;
		}
		return this.failure(400, message, code, url, callback);
	};

Response.prototype.nocontent =
	Response.prototype.noContent = function noContent(callback) {
		//HTTP spec says you MUST not send content on 204
		this.response.logger.info({ignore: true, nocontent: true, status: 204, headers: this.response.headers});
		this.response.send(204);
		callback && callback();
	};

Response.prototype.createCallback = function createCallback(next, success, after) {
	return function responseCallback(err, result) {
		var self = this;
		if (next === after) {
			// only run one of them
			next = null;
		}
		var tasks = [
			function (cb) {
				if (err) { return self.error(err, cb); }
				if (result === undefined || result === null) { return self.notFound(cb); }
				if (success) {
					if (success.length > 1) {
						return success(result, cb);
					} else {
						success(result);
						return cb();
					}
				}
				self.success(result, cb);
			},
			function (cb) {
				next && next();
				cb();
			}
		];
		async.series(tasks, after);
	}.bind(this);
};

Response.prototype.redirect =
	Response.prototype.redirectPath = function redirect(path, callback, status) {
		var url = path;
		if (!/https?:/.test(path)) {
			url = this.request.path;
			if (/\/$/.test(path)) {
				url += path;
			} else {
				url += '/' + path;
			}
		}
		status = status || 302;
		this.response.set('Location', url);
		this.response.logger.info({
			ignore: true,
			nocontent: true,
			status: status,
			headers: this.response.headers,
			path: path
		});
		this.response.send(status);
		callback && callback();
	};

Response.prototype.unauthorized = function unauthorized(callback) {
	this.response.logger.info({ignore: true, nocontent: true, status: 401, headers: this.response.headers});
	this.failure(401, 'Unauthorized', 401, null, callback);
};

Response.prototype.json = function jsonResponse(json, callback) {
	this.response.logger.info({ignore: true, nocontent: true, status: 200, headers: this.response.headers, json: json});
	this.response.setHeader('Content-Type', 'application/json');
	this.send(json);
	callback && callback();
};

Response.prototype.fail =
	Response.prototype.failed =
		Response.prototype.error = function error() {
			var err = arguments[0],
				next = arguments[1];
			// console.log('error', err.stack);
			if (err instanceof Error) {
				this.log.trace(err.stack);
				this.failure(err.status || 500, err.message, err.code, err.url, next);
			} else {
				var args = Array.prototype.slice.call(arguments);
				args.unshift(500);
				this.failure.apply(this, args);
				next && next();
			}
		};

/**
 * invoke Function fn and stream results back as response. optional pass
 * additional arguments that will be also passed to fn
 */
Response.prototype.stream = function stream(fn) {
	var callback = arguments[arguments.length - 1];
	if (typeof(fn) !== 'function') {
		return this.error('called Response.stream with something that\'s not a function', callback);
	}
	try {
		if (fn.name in this.api.model) {
			// if this function is defined in the model, make sure we bind
			// the model instance to the function.
			fn = fn.bind(this.api.model);
		}
		var args;
		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments, 1, arguments.length - 1);
		} else {
			args = [];
		}
		args.push(this.createCallback(callback, function (result) {
			this.success(result, function (err) {
				callback(err, result);
			});
		}.bind(this), callback));
		process.nextTick(function responseTick() {
			try {
				fn.apply(null, args);
			}
			catch (E) {
				this.error(E, callback);
			}
		}.bind(this));
	}
	catch (E) {
		this.logger.error(E);
		this.error(E, callback);
		callback();
	}
};

exports = module.exports = Response;
