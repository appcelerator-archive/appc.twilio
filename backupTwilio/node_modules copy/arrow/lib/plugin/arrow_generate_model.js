/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var async = require('async'),
	path = require('path'),
	fs = require('fs'),
	util = require('./util');

// jscs:disable jsDoc

module.exports = {
	type: 'arrow_generate',
	name: 'Arrow Model',
	execute: function (appc, opts, callback) {
		if (util.canResolveArrowProject(opts)) {
			generateModelForProject(appc, opts, callback);
		} else {
			generateNewModelProject(appc, opts, callback);
		}
	}
};

function getObjectModel(appc, projectdir, callback) {
	var Arrow = appc.arrow;
	var cwd = process.cwd();
	var server = new Arrow({port: 0, dir: projectdir, logLevel: 'error', disableAutoLogin: true});
	for (var key in server.config.connectors) {
		if (server.config.connectors.hasOwnProperty(key)) {
			// force generateModelsFromSchema to be true so we get the built in types, regardless of config.
			server.config.connectors[key].generateModelsFromSchema = true;
		}
	}
	process.chdir(projectdir);
	// we must wait for our components to be loaded
	server.start(function (err) {
		if (err) { return callback(err); }
		var objectModel = require('arrow-objectmodel');
		objectModel = new objectModel.ObjectModel(server);

		// add the connector specific models to each connector in the objectModel.
		for (var modelName in objectModel.models) {
			if (objectModel.models.hasOwnProperty(modelName)) {
				if (modelName.indexOf('/') > 0) {
					var connector = objectModel.connectors[modelName.split('/')[0]];
					if (connector) {
						if (!connector.models) {
							connector.models = [];
						}
						connector.models.push(objectModel.models[modelName]);
					}
				}
			}
		}
		process.chdir(cwd);
		server.stop(function (err) {
			callback(null, objectModel);
		});
	});
}

function generateModelForProject(appc, opts, callback) {
	var projectdir = util.getProjectDir(opts),
		modeldir = path.join(projectdir, 'models'),
		inquirer = appc.inquirer,
		objectModel;

	// make sure we have models directory
	if (!fs.existsSync(modeldir)) {
		fs.mkdirSync(modeldir);
	}

	async.waterfall([

		// load the object model
		function (cb) {
			getObjectModel(appc, projectdir, function (err, om) {
				if (err) { return cb(err); }
				objectModel = om;
				cb();
			});
		},

		function (cb) {
			inquirer.prompt([
				{
					type: 'list',
					name: 'type',
					message: 'Which type of Model would you like to generate?',
					choices: [
						{name: 'Create New Model', value: 'new'},
						{name: 'Inherit from an existing Model', value: 'extend'}
					]
				}
			], function (err, answers) {
				if (arguments.length === 1) {
					answers = err;
					err = null;
				}
				cb(err, answers.type);
			});
		},

		function (type, cb) {
			switch (type) {
				case 'new':
					return createNewModelForProject(appc, opts, projectdir, modeldir, objectModel, cb);
				case 'extend':
					return createExtendModelForProject(appc, opts, projectdir, modeldir, objectModel, cb);
				default:
					break;
			}
		}

	], callback);

}

function promptModelName(appc, cb) {
	appc.inquirer.prompt([
		{
			type: 'input',
			name: 'name',
			message: 'What is the new model name?',
			required: true,
			validate: function (input) {
				if (!input) {
					return 'You must specify a model name';
				} else if (!/^[a-z][a-z\d\-]*$/i.test(input)) {
					return 'Must only use alphanumeric characters or dash. ' +
						'First character must be a letter.';
				} else {
					return true;
				}
			}
		}
	], function (err, answers) {
		if (arguments.length === 1) {
			answers = err;
			err = null;
		}
		cb(err, answers.name);
	});
}

function promptModelDescription(appc, cb) {
	appc.inquirer.prompt([
		{
			type: 'input',
			name: 'description',
			message: 'What is the model description?',
			required: false
		},
	], function (err, answers) {
		if (arguments.length === 1) {
			answers = err;
			err = null;
		}
		cb(err, answers.description);
	});
}

function createNewModelForProject(appc, opts, projectdir, modeldir, objectModel, callback) {
	async.waterfall([

		function (cb) {
			promptModelName(appc, cb);
		},

		function (name, cb) {
			promptModelDescription(appc, function (err, description) {
				cb(err, name, description);
			});
		},

		function (name, description, cb) {
			var connectors = Object.keys(objectModel.connectors);
			if (connectors.length) {
				appc.inquirer.prompt([
					{
						type: 'list',
						name: 'connector',
						message: 'Which connector to use?',
						required: true,
						choices: ['No connector'].concat(connectors).map(function (value) {
							return {value: value, name: value};
						})
					}
				], function (err, answers) {
					if (arguments.length === 1) {
						answers = err;
						err = null;
					}
					var connector = answers && answers.connector;
					if (connector === 'No connector') {
						connector = null;
					}
					cb(err, name, description, connector);
				});
			} else {
				cb(null, name, description, null);
			}
		},

		function (name, description, connector, cb) {
			generateModelFilename(appc, modeldir, name, description, connector, cb);
		},

		function (name, description, connector, filename, cb) {
			var content = ['var Arrow = require(\'arrow\');'];
			content.push('');
			content.push('var Model = Arrow.Model.extend(\'' + name + '\',{');
			description && content.push('\tdescription: "' + description + '",');
			content.push('\tfields: {');
			content.push('\t}' + (connector ? ',' : ''));
			if (connector && name.indexOf(connector) === -1) {
				content.push('\tconnector: \'' + connector + '\',');
				content.push('\tmetadata: {');
				content.push('\t\t\'' + connector + '\': {');
				content.push('\t\t}');
				content.push('\t}');
			}
			content.push('});');
			content.push('');
			content.push('module.exports = Model;');
			fs.writeFile(filename, content.join('\n'), cb);
		},

		function (cb) {
			console.log(appc.chalk.cyan('\n*** new model created. ***\n'));
			cb();
		}

	], callback);
}

function generateModelFilename(appc, modeldir, name, description, connector, callback) {
	var fn = path.join(modeldir, name + '.js');
	if (!fs.existsSync(fn)) {
		return callback(null, name, description, connector, fn);
	}
	appc.inquirer.prompt([
		{
			type: 'confirm',
			name: 'confirm',
			message: 'Delete existing model at ' + fn + '?',
			required: true,
			default: 'Y'
		}
	], function (err, answers) {
		if (arguments.length === 1) {
			answers = err;
			err = null;
		}
		if (!answers.confirm) {
			callback(new Error('cancelled'));
		}
		callback(null, name, description, connector, fn);
	});
}

function createExtendModelForProject(appc, opts, projectdir, modeldir, objectModel, callback) {
	var models = Object.keys(objectModel.models),
		connectors = Object.keys(objectModel.connectors);

	async.waterfall([

		function pickWhatToExtend(cb) {

			var choices = [];

			if (models.length) {
				choices.push({name: 'Extend an existing project model', value: 'project'});
			}

			if (connectors.length) {
				choices.push({name: 'Extend from a connector scoped model', value: 'connector'});
			}

			if (choices.length < 1) {
				// just fall back to new model if we can't find any to extend
				return createNewModelForProject(appc, opts, projectdir, modeldir, objectModel, cb);
			} else if (choices.length === 1) {
				return cb(null, 'project');
			}

			appc.inquirer.prompt([
				{
					type: 'list',
					name: 'type',
					message: 'What type of model to extend?',
					choices: choices
				}
			], function (err, answers) {
				if (arguments.length === 1) {
					answers = err;
					err = null;
				}
				cb(null, answers.type);
			});
		},

		function pickAProjectModelOrConnector(type, cb) {
			var prompts = [];

			switch (type) {
				case 'connector':
					prompts.push({
						type: 'list',
						name: 'connector',
						message: 'Which connector to extend from?',
						choices: connectors.map(function (v) {
							return {name: v, value: v};
						})
					});
					break;
				case 'project':
					prompts.push({
						type: 'list',
						name: 'model',
						message: 'Which model to extend from?',
						choices: models.map(function (v) {
							return {name: v, value: v};
						})
					});
					break;
			}

			appc.inquirer.prompt(prompts, function (err, answers) {
				if (arguments.length === 1) {
					answers = err;
					err = null;
				}
				cb(null, type, answers);
			});
		},

		function pickAConnectorModel(type, answers, cb) {
			var connectorName = answers.connector;
			if (!connectorName) {
				return cb(null, type, answers.model, null);
			}
			var connector = objectModel.connectors[connectorName],
				prompts = [
					{
						type: 'list',
						name: 'model',
						message: 'Which model to extend from?',
						choices: connector.models.map(function (model) {
							return {name: model.name, value: model.name};
						})
					}
				];
			appc.inquirer.prompt(prompts, function (err, answers) {
				if (arguments.length === 1) {
					answers = err;
					err = null;
				}
				cb(null, type, answers.model, connectorName);
			});
		},

		function pickAModelName(type, modelName, connectorName, cb) {
			var model = objectModel.models[modelName];
			connectorName = connectorName || (model && model.connector);
			promptModelName(appc, function (err, name) {
				cb(null, type, model, name, connectorName);
			});
		},

		function pickAModelDescription(type, model, name, connectorName, cb) {
			promptModelDescription(appc, function (err, description) {
				cb(null, type, model, name, description, connectorName);
			});
		},

		function pickExtendOrReduce(type, model, name, description, connectorName, cb) {
			appc.inquirer.prompt([
				{
					type: 'list',
					name: 'operation',
					message: 'Do you want to extend the model or reduce it?',
					choices: [
						{name: 'Extend', value: 'extend'},
						{name: 'Reduce', value: 'reduce'}
					]
				}
			], function (err, answers) {
				if (arguments.length === 1) {
					answers = err;
					err = null;
				}
				cb(null, type, model, name, description, connectorName, answers.operation);
			});
		},

		function (type, model, name, description, connectorName, operation, cb) {
			generateModelFilename(appc, modeldir, name, description, connectorName, function (err, name, description, connector, fn) {
				cb(err, type, model, name, description, connector, operation, fn);
			});
		},

		function writeCode(type, model, name, description, connectorName, operation, filename, cb) {
			var content = ['var Arrow = require(\'arrow\');'];
			content.push('');
			content.push('var Model = Arrow.Model.' + operation + '(\'' + model.name + '\',\'' + name + '\',{');
			description && content.push('\tdescription: \'' + description + '\',');
			content.push('\tfields: {');
			content.push('\t}');
			content.push('});');
			content.push('');
			content.push('module.exports = Model;');
			fs.writeFile(filename, content.join('\n'), cb);
		},

		function reportSuccess(cb) {
			console.log(appc.chalk.cyan('\n*** new model created. ***\n'));
			cb();
		}

	], callback);
}

function generateNewModelProject(appc, opts, callback) {
	var CLI = require('../cli');
	var cli = new CLI(appc.commander, appc.inquirer);
	cli.logger.level(appc.log.level());
	cli.runCommand('new', util.generateArgs('model', opts), callback);
}
