/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
// will get set in execute
var appc;

// jscs:disable jsDoc

var _ = require('lodash'),
	async = require('async'),
	chalk = require('chalk'),
	exec = require('child_process').exec,
	fs = require('fs'),
	path = require('path'),
	util = require('./util');

var exports = module.exports = {
	name: 'Arrow',
	type: 'arrow_publish',
	find: find,
	execute: publish
};

function find(appc, opts) {
	return util.findArrowComponent(appc, opts, module.exports);
}

function publish(_appc, args, opts, callback) {

	appc = _appc;
	opts = _.clone(opts || {});

	var inquirer = appc.inquirer;

	// validate required fields
	if (!opts.component) {
		appc.log.trace('no component specified for ' + exports.name + ' publish, skipping...');
		return callback();
	}
	var component = opts.component;
	opts.publishDir = component.dir;
	var pkgFile = path.join(opts.publishDir, 'package.json');
	appc.log.trace('loading for publish ' + chalk.yellow(pkgFile));
	try {
		opts.pkg = JSON.parse(fs.readFileSync(pkgFile, 'utf8'));
	} catch (e) {
		return callback(new Error('unable to parse package.json\n' + e.toString()));
	}

	// if this is an API Project, we want to use ACS for publish
	if (component.type === 'api') {

		// entitlement checks --- don't worry, if you hack this code, we'll check it on the server too :<
		var entitlements = JSON.parse(process.env.APPC_SESSION_ENTITLEMENTS || '{}');
		var entitled = entitlements && entitlements.arrowPublish;
		if (!entitled) {
			return callback(new Error('Your current login session is not entitled to publish to production. ' +
				'Please login to a different organization with entitlements or upgrade to a plan that supports ' +
				'production deployment.'));
		}

		var productionNodeVersion = opts.pkg.engines && opts.pkg.engines.node;
		util.printSpecifyNodeVersionWarningIfRequired(productionNodeVersion, appc.log);

		var ArrowCloud = require('../cloud');
		var org_id = opts.session && opts.session.org_id || opts.config && opts.config.org_id;
		var cloud = new ArrowCloud(opts.pkg.name, org_id, appc);
		if (args && args.length) {
			var url = require('url').parse(args[0]);
			var sid = _appc.commands.config.get('sid');
			cloud.host = url.protocol  + '//' + url.hostname;
			cloud.port = url.port;
			cloud.path = url.path === '/' ? '' : url.path;
			cloud.username = opts.session.username;
			cloud.password = 'sid:' + sid;
		}
		cloud.publish(opts.publishDir, opts.force, function (err, result) {
			// check if the error message contains App not found!
			if (err && err.message === 'App not found!') {
				appc.log.debug(err);
				appc.log.warn('The Arrow app needs to be registered before it is published.');
				return inquirer.prompt([
					{
						type: 'confirm',
						name: 'import',
						message: 'Would you like to register the Arrow app?'
					}
				], function (err, answers) {
					if (arguments.length === 1) {
						answers = err;
						err = null;
					}
					if (err) { return callback(err); }
					if (!answers.import) { return callback(new Error('The Arrow app must be registered before it can be published.')); }

					// import the service
					appc.spinner.start(); // start spinner
					return require('./new').acsNew(appc, opts, opts.pkg.name, opts.publishDir, function (err) {
						appc.spinner.stop(); // stop spinner
						if (err) { return callback(err); }

						appc.log.info('Arrow service successfully imported');
						return publish(appc, args, opts, callback);
					});
				});
			}

			if (err) { return callback(err); }
			cloud.getCName(function (err, details) {
				var url = result.url;
				if (details && details.domain && details.domain.length) {
					url = details.domain[0];
				}
				appc.log.info('Application deployed to', appc.chalk.green(url));
				callback(null, {
					url: url,
					type: 'api',
					name: opts.pkg.name,
					version: opts.pkg.version
				});
			});
		}, function (dir, next) {
			var deploy = {
				username: opts.session.username,
				org_id: opts.session.org_id,
				name: opts.pkg.name,
				version: opts.pkg.version,
				//FIXME: switch to cname url and refactor into appc-cli
				//logserver: 'https://83686902dbe1eddf1cc178f3ef1e95f34fb2cbf8.cloudapp-enterprise-preprod.appctest.com'
			};
			// write out the deployment which is used in production by logmanager
			var deployFn = path.join(dir, 'conf', 'deploy.json');
			appc.log.trace('writing deploy.json for deployment\n', JSON.stringify(deploy, null, 2), 'filename=', deployFn);
			fs.writeFile(deployFn, JSON.stringify(deploy, null, 2), next);
		});
	} /* publish to registry*/ else if (_.contains(['block', 'model', 'connector'], component.type)) {

		// load the package.json

		async.waterfall([

			// feed opts into waterfall
			function (cb) { return cb(null, opts); },

			// package the module, via npm pack
			packModule,

			// sha1 the dist
			sha1Dist,

			// upload packaged module to registry
			uploadModule

		], function (err, result) {
			if (opts.packFile) {
				try { fs.unlinkSync(opts.packFile); } catch (e) {}
			}
			return callback(err, result);
		});
	} /* invalid publish type*/ else {
		return callback(new Error('invalid publish type "' + component.type +
			'" for plugin ' + exports.name));
	}

}

function packModule(opts, callback) {
	appc.log.info('Packaging ' + opts.pkg.name);
	appc.spinner.start();

	exec('npm pack', {cwd: opts.publishDir}, function (err, stdout, stderr) {
		appc.spinner.stop();
		if (err) { return callback(err); }
		opts.packFile = path.join(opts.publishDir, (stdout || '').trim());
		return callback(null, opts);
	});
}

function sha1Dist(opts, callback) {
	appc.log.info('Encoding ' + opts.pkg.name);
	var hash = require('crypto').createHash('sha1');
	hash.setEncoding('hex');
	var fd = fs.createReadStream(opts.packFile);
	fd.on('end', function () {
		hash.end();
		opts.shasum = hash.read();
		callback(null, opts);
	});
	fd.pipe(hash);
}

function uploadModule(opts, callback) {
	var file = opts.packFile;
	appc.spinner.start();

	// add the shasum to the package.json
	opts.pkg._shasum = opts.shasum;

	// attempt to find a suitable README and bring it in like npm publish does
	var readmeNames = ['README.md', 'README', 'README.txt'];
	for (var c = 0; c < readmeNames.length; c++) {
		var readme = path.join(opts.publishDir, readmeNames[c]);
		if (fs.existsSync(readme)) {
			opts.pkg.readme = fs.readFileSync(readme).toString();
			opts.pkg.readmeFilename = readmeNames[c];
			break;
		}
	}

	// get the TYPE if there's one and this is a appc-cli-plugin
	if (opts.pkg && opts.pkg.keywords && opts.pkg.keywords.indexOf('appc-cli-plugin') !== -1) {
		var appcfn = path.join(opts.publishDir, 'appc.js');
		if (fs.existsSync(appcfn)) {
			try {
				var m = require(appcfn);
				opts.subtype = m.TYPE;
			}
			catch (E) {
				appc.log.debug('Error attempting to determine appc-cli-plugin TYPE by loading', appcfn, '. Error: ', E);
			}
		}
	}

	var appcFile = path.join(opts.publishDir, 'appc.json');

	appc.publish.validateAppC(appcFile, opts.pkg, opts.session, function (err, appcJSON, saveappcJSON, savePKG) {
		if (err) {
			appc.spinner.stop();
			return callback(err);
		}
		opts.appcJSON = appcJSON;
		appc.publish.uploadModule(opts, callback);
	});

}
