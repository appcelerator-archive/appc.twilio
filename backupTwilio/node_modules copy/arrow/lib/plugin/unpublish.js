/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
// will get set in execute
var appc;

// jscs:disable jsDoc

var _ = require('lodash'),
	async = require('async'),
	chalk = require('chalk'),
	fs = require('fs'),
	path = require('path'),
	util = require('./util');

var exports = module.exports = {
	name: 'Arrow',
	type: 'arrow_unpublish',
	find: find,
	execute: unpublish,
	command: function (program, appc) {
		program.option('--remove', 'remove the app from the cloud permanently');
	}
};

function find(appc, opts) {
	return util.findArrowComponent(appc, opts, module.exports);
}

function unpublishApi(opts, args, callback) {
	var ArrowCloud = require('../cloud');
	var org_id = opts.session && opts.session.org_id || opts.config && opts.config.org_id;
	var cloud = new ArrowCloud(opts.pkg.name, org_id, appc);
	if (args && args.length) {
		var url = require('url').parse(args[0]);
		var sid = appc.commands.config.get('sid');
		cloud.host = url.protocol  + '//' + url.hostname;
		cloud.port = url.port;
		cloud.path = url.path === '/' ? '' : url.path;
		cloud.username = opts.session.username;
		cloud.password = 'sid:' + sid;
	}
	if (opts.remove) {
		appc.log.info('Removing the application from the Appcelerator Cloud. One moment...');
		cloud.remove(function (err, result) {
			if (err) { return callback(err); }
			callback(null, {
				type: 'api',
				name: opts.pkg.name,
				version: opts.pkg.version
			});
		});
	} else {
		appc.log.info('Unpublishing the application from the Appcelerator Cloud. One moment...');
		cloud.unpublish(function (err, result) {
			if (err) { return callback(err); }
			callback(null, {
				type: 'api',
				name: opts.pkg.name,
				version: opts.pkg.version
			});
		});
	}
}

function unpublish(_appc, args, opts, callback) {

	appc = _appc;
	opts = _.clone(opts || {});

	// validate required fields
	if (!opts.component) {
		appc.log.trace('no component specified for ' + exports.name + ' unpublish, skipping...');
		return callback();
	}
	var component = opts.component;
	opts.publishDir = component.dir;
	var pkgFile = path.join(opts.publishDir, 'package.json');
	appc.log.trace('loading for unpublish ' + chalk.yellow(pkgFile));
	try {
		opts.pkg = JSON.parse(fs.readFileSync(pkgFile, 'utf8'));
	} catch (e) {
		return callback(new Error('unable to parse package.json\n' + e.toString()));
	}

	// if this is an API Project, we want to use ACS for unpublishing
	if (component.type === 'api') {
		async.waterfall([
			// feed opts into waterfall
			function (cb) { return cb(null, opts); },

			// get necessary auth for install
			appc.registry.getCredentials,

			// do the unpublish
			function (opts, cb) {
				unpublishApi(opts, args, cb);
			}

		], callback);
	} /* unpublish from the registry*/ else if (_.contains(['block', 'model', 'connector', 'appc-cli'], component.type)) {

		async.waterfall([

			// feed opts into waterfall
			function (cb) { return cb(null, opts); },

			// get necessary auth for install
			appc.registry.getCredentials,

			// unpublish a module
			unpublishComponent

		], callback);

	} /* invalid publish type*/ else {
		return callback(new Error('invalid component type for unpublish "' + component.type +
			'" for plugin ' + exports.name));
	}

}

function unpublishComponent(opts, callback) {
	appc.log.trace('unpublishComponent - type:' + opts.component.type + ' name:' + opts.pkg.name + ' version:' + opts.pkg.version);
	return appc.registry.unpublish(opts.session, opts.component.type, opts.pkg.name, opts.pkg.version, callback);
}
