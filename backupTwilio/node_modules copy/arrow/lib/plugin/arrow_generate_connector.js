/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var async = require('async'),
	exec = require('child_process').exec,
	path = require('path'),
	fs = require('fs');

// jscs:disable jsDoc

module.exports = {
	type: 'arrow_generate',
	name: 'Arrow Connector',
	fields: [],
	execute: function (appc, opts, callback) {
		var plugins,
			plugin,
			_ = appc.lodash,
			chalk = appc.chalk,
			inquirer = appc.inquirer;

		async.series([

			// get a list of plugins that subscribe to arrow generation
			function (cb) {

				// TODO: dirty hack to get commander in here, need to pass this thru proper
				appc.core.loadPlugins(require('commander'), 'arrow_connector_generator',
					opts.pluginPaths, function (err, _plugins) {
						if (err) { return cb(err); }
						plugins = _.reject(_plugins, function (p) {return !p.generator;});
						cb();
					});
			},

			// determine which connector
			function (cb) {
				var choices = _.map(plugins, function (plugin) {
					return {name: plugin.name, value: plugin};
				});
				choices.unshift({name: 'Search for a Connector from the registry', value: '__search__'});
				inquirer.prompt([
					{
						type: 'list',
						name: 'plugin',
						message: 'Which Connector would you like to generate?',
						choices: choices,
						when: function () {
							return !opts.connector;
						}
					}
				], function (err, answers) {
					if (arguments.length === 1) {
						answers = err;
						err = null;
					}
					plugin = answers.plugin || opts.connector;
					cb();
				});
			},

			function (cb) {
				// if we didn't choose search, just continue
				if (plugin !== '__search__') {
					return cb();
				}
				appc.registry.findPlugins(opts, 'connector', 'arrow_connector_generator', function (err, result) {
					if (err) { return cb(err); }

					if (result.length === 0) {
						plugin = null;
						appc.log.warn('No connector generator plugins found in registry');
						return cb();
					}

					var choices = _.map(result, function (entry) {
						return {
							name: entry.description + ' ' + chalk.yellow(entry.name + '@' + entry.version),
							value: entry
						};
					});

					inquirer.prompt([
						{
							type: 'list',
							name: 'plugin',
							message: 'Which Connector would you like to use?',
							choices: choices
						}
					], function (err, answers) {
						if (arguments.length === 1) {
							answers = err;
							err = null;
						}
						var entry = answers.plugin,
							component = entry.type + '/' + entry.name + '@' + entry.version;
						console.log('\nOne moment, installing... ' + chalk.yellow(component));
						appc.spinner.start();
						exec('appc install ' + component + ' -g', function (err, stdout, stderr) {
							appc.spinner.stop();
							if (err) { return cb(err); }
							// now attempt to load
							var pp = path.join(appc.constants.getGlobalCacheDir(), 'node_modules', 'connectors', entry.name, 'appc.js');
							if (!fs.existsSync(pp)) {
								appc.log.error(stderr || stdout);
								return cb('Error installing plugin');
							}
							// point to the right generate entry point
							plugin = require(pp).generate;
							opts = {};
							cb();
						});
					});
				});
			},

			function (cb) {
				if (!plugin) { return cb(); }
				var fields = plugin.fields;

				// make sure fields are unique and not in opts
				var tmpOpts = {};
				fields = _.reject(fields, function (field) {
					if (tmpOpts[field.name]) {
						return true;
					} else {
						tmpOpts[field.name] = true;
					}
					return opts[field.name] != null;
				});

				// prompt for missing fields, if necessary
				if (fields.length) {
					inquirer.prompt(fields, function (err, answers) {
						if (arguments.length === 1) {
							answers = err;
							err = null;
						}
						opts = _.extend(opts, answers);
						return cb();
					});
				} else {
					return cb();
				}
			},

			function (cb) {
				if (!plugin) { return cb(); }
				plugin.execute(appc, opts, cb);
			}

		], callback);
	}
};
