/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var wrench = require('wrench'),
	path = require('path'),
	fs = require('fs'),
	_ = require('lodash'),
	util = require('./util'),
	mustache = require('mustache'),
	Arrow = require('../arrow'),
	om = require('arrow-objectmodel');

// jscs:disable jsDoc

var SDKTYPES = crawlSDKTypes();

module.exports = {
	name: 'Arrow SDK',
	type: 'sdk',
	execute: generate,
	when: util.canResolveArrowProject,
	order: 1,
	fields: [
		{
			flags: '--sdktype <sdktype>',
			description: 'set the SDK type. can be one of ' + _.pluck(SDKTYPES, 'value').map(injectOr).join(', '),
			type: 'list',
			name: 'sdktype',
			message: 'Which type of App SDK?',
			choices: SDKTYPES
		},
		{
			flags: '--sdkname <sdkname>',
			description: 'set the SDK name',
			name: 'sdkname',
			message: 'What should the name of the SDK be?',
			'default': function () {
				var pkg = path.join(process.cwd(), 'package.json');
				if (fs.existsSync(pkg)) {
					var pkgContents = JSON.parse(fs.readFileSync(pkg));
					return safeName(pkgContents.name);
				}
				return 'Arrow';
			}
		},
		{
			flags: '--sdkdir <sdkdir>',
			description: 'set the SDK project directory to generate into',
			name: 'sdkdir',
			message: 'Generate files into which directory?',
			'default': 'sdk',
			filter: function (value) {
				return path.resolve(process.cwd(), value);
			}
		}
	]
};

function crawlSDKTypes() {
	var dir = path.join(__dirname, '..', '..', 'templates', 'sdk');
	return fs.readdirSync(dir)
		.filter(function (value) {
			return value[0] !== '.' && value[0] !== '_';
		})
		.map(function (value) {
			var config = readModule('config', value) || {};
			return {
				name: (config.name || value) + ' (' + value + ')',
				value: value
			};
		});
}

function generate(appc, args, opts, callback) {
	if (_.where(SDKTYPES, {value: opts.sdktype}).length === 0) {
		return callback(new Error('"' + opts.sdktype + '" is not a recognized sdktype; please instead use one of the following: ' + _.pluck(SDKTYPES, 'value').map(injectOr).join(', ') + '.'));
	}

	var dir = opts.workspace || process.cwd(),
		platformConfig = _.defaults(readModule('config', opts.sdktype) || {}, {
			typeMap: {},
			standardArgsMap: {}
		}),
		server = new Arrow({
			dir: dir,
			port: 0,
			overrideLevel: opts.logLevel === 'info' && 'error',
			disableAutoLogin: true
		});

	appc.spinner.start();
	server.start(function (err) {
		if (err) {
			appc.spinner.stop();
			return callback(err);
		}

		var objectModel = new om.ObjectModel(server),
			models = objectModel.models,
			apis = objectModel.apis;

		// Generate configuration.
		objectModel.port = new Arrow({dir: dir, disableAutoLogin: true}, true).port;
		objectModel.sdktype = opts.sdktype;
		objectModel.platformConfig = platformConfig;
		objectModel.sdkname = opts.sdkname;
		objectModel.sdknameLower = opts.sdkname.toLowerCase();
		if (!objectModel.domain) {
			objectModel.domain = 'http://localhost';
		}

		// Security.
		objectModel.authByBasic = 'basic' === objectModel.config.APIKeyAuthType;
		objectModel.authByAPIKey = 'apikey' === objectModel.config.APIKeyAuthType;
		objectModel.authByPlugin = 'plugin' === objectModel.config.APIKeyAuthType;
		if (objectModel.authByPlugin) {
			var pluginFn = path.resolve(dir, objectModel.config.APIKeyAuthPlugin);
			if (fs.existsSync(pluginFn)) {
				var plugin = require(pluginFn);
				if (plugin.securityREADME && _.isFunction(plugin.securityREADME)) {
					objectModel.securityPluginREADME = plugin.securityREADME(opts.sdkname, objectModel, opts.sdktype, 'config');
				}
				if (plugin.generateSDKCode && _.isFunction(plugin.generateSDKCode)) {
					objectModel.securityPluginCode = plugin.generateSDKCode(opts.sdkname, objectModel, opts.sdktype, 'config');
				}
			}
		}

		// APIs and Models.
		objectModel.apis = [];
		objectModel.models = [];
		for (var apiName in apis) {
			if (apis.hasOwnProperty(apiName)) {
				for (var i = 0; i < apis[apiName].endpoints.length; i++) {
					var endpoint = apis[apiName].endpoints[i];
					objectModel.apis.push(translateEndpoint(endpoint));
				}
			}
		}
		for (var modelName in models) {
			if (models.hasOwnProperty(modelName)) {
				var modelAPI = apis[modelName];
				if (!modelAPI || !modelAPI.endpoints) {
					continue;
				}
				var model = models[modelName],
					endpoints = modelAPI.endpoints.map(translateEndpoint);
				if (endpoints && endpoints.length) {
					endpoints[endpoints.length - 1].endpointIsLast = true;
				}
				objectModel.models.push({
					name: modelName,
					safeName: safeName(modelName),
					modelSafeName: safeName(modelName),
					model: model,
					fields: translateFields(model.fields),
					endpoints: endpoints,
					baseURL: endpoints && _.pluck(endpoints, 'path').sort()[0]
				});
			}
		}

		if (objectModel.apis && objectModel.apis.length) {
			objectModel.apis[objectModel.apis.length - 1].isLast = true;
		}
		if (objectModel.models && objectModel.models.length) {
			objectModel.models[objectModel.models.length - 1].isLast = true;
		}
		var code = mustache.render(readTemplate(opts.sdktype, '_init'), objectModel, readTemplates());

		wrench.mkdirSyncRecursive(opts.sdkdir);

		/*
		 Check if the template has its own filename splits defined.
		 They will follow this strict breakdown:
		 \/** filename: someName.m **\/
		 */
		if (code.indexOf('/** filename:') >= 0) {
			var splits = code.split('/** filename:');
			for (var j = 1; j < splits.length; j++) { // Note: We skip the first (blank) split.
				var split = splits[j],
					filename = split.slice(1, split.indexOf(' **/')),
					content = split.slice(split.indexOf(' **/') + 5);

				if (filename.indexOf('/') >= 0) {
					wrench.mkdirSyncRecursive(path.join(opts.sdkdir, filename.split('/').slice(0, -1).join('/')));
				}
				fs.writeFileSync(path.join(opts.sdkdir, filename), content);
			}
		} else {
			fs.writeFileSync(path.join(opts.sdkdir, opts.sdkname + '.js'), code);
		}

		allDone();
	});

	function readTemplates() {
		var retVal = {},
			files;

		// Read in the base template files.
		files = fs.readdirSync(path.join(__dirname, '..', '..', 'templates', 'sdk', '_base')).filter(ignoreDotFiles);
		for (var i = 0; i < files.length; i++) {
			retVal[files[i]] = readTemplate('_base', files[i]);
		}

		// Then, load in SDK specific files.
		files = fs.readdirSync(path.join(__dirname, '..', '..', 'templates', 'sdk', opts.sdktype)).filter(ignoreDotFiles);
		for (var j = 0; j < files.length; j++) {
			retVal[files[j]] = readTemplate(opts.sdktype, files[j]);
		}

		return retVal;
	}

	function ignoreDotFiles(file) {
		return file[0] !== '.';
	}

	function translateFields(fields) {
		var retVal = [];
		retVal.push({
			name: 'id',
			safeName: 'ID',
			type: platformConfig.typeMap.string || 'string'
		});
		for (var fieldName in fields) {
			if (fields.hasOwnProperty(fieldName)) {
				var field = fields[fieldName];
				retVal.push({
					name: fieldName,
					safeName: safeName(fieldName),
					type: platformConfig.typeMap[field.type] || field.type,
					field: field
				});
			}
		}
		retVal[retVal.length - 1].fieldIsLast = true;
		return retVal;
	}

	function translateEndpoint(endpoint) {
		// We need to translate the parameters to the consistent programmatic args.
		var params = endpoint.parameters,
			pathParams = _.where(params, {type: 'path'}),
			queryParams = _.where(params, {type: 'query'}),
			bodyParams = _.where(params, {type: 'body'});

		endpoint.args = [];
		endpoint.argNames = [];
		endpoint.isGET = 'GET' === endpoint.method;
		endpoint.safeName = safeName(endpoint.method + '/' + endpoint.path);

		// Path parameters become their own full argument.
		if (Object.keys(pathParams).length > 0) {
			var pathNames = _.pluck(pathParams, 'name');
			endpoint.args = endpoint.args.concat(platformConfig.pluckPathParams && platformConfig.pluckPathParams(pathParams) || pathNames);
			endpoint.argNames = endpoint.argNames.concat(pathNames);
			endpoint.hasPath = true;
			endpoint.pathParams = platformConfig.translatePathName ? pathNames.map(platformConfig.translatePathName) : pathNames;
		}
		if (platformConfig.translatePathName) {
			/* /api/user/:id */
			endpoint.path = endpoint.path.split('/').map(function (item) {
				return item[0] === ':' ? ':' + platformConfig.translatePathName(item.slice(1)) : item;
			}).join('/');
		}

		// Query parameters get grouped together.
		if (Object.keys(queryParams).length > 0) {
			endpoint.args.push(platformConfig.standardArgsMap.query || 'query');
			endpoint.argNames.push('query');
			endpoint.hasQuery = true;
			endpoint.queryParams = _.values(queryParams);
		}
		// Body parameters get grouped together.
		if (Object.keys(bodyParams).length > 0) {
			endpoint.args.push(platformConfig.standardArgsMap.body || 'body');
			endpoint.argNames.push('body');
			endpoint.hasBody = true;
			endpoint.bodyParams = _.values(bodyParams);
		}
		if (platformConfig.translatePathName) {
			endpoint.argNames = endpoint.argNames.map(platformConfig.translatePathName);
		}

		endpoint.hasQueryAndBody = endpoint.hasQuery && endpoint.hasBody;
		endpoint.hasNoQueryOrBody = !endpoint.hasQuery && !endpoint.hasBody;

		var response200 = endpoint.responses && endpoint.responses[200];
		if (response200) {
			var type = response200.schema.type;
			if (type === 'array') {
				var arrayType,
					itemType = response200.schema.items && response200.schema.items.type;
				if (itemType) {
					arrayType = platformConfig.typeMap[itemType] || itemType;
				}
				endpoint.response200 = {
					array: true,
					type: arrayType,
					response: response200
				};
			} else {
				endpoint.response200 = {
					array: false,
					type: platformConfig.typeMap[type],
					response: response200
				};
			}
		}

		return endpoint;
	}

	function readTemplate(dir, name) {
		return fs.readFileSync(path.join(__dirname, '..', '..', 'templates', 'sdk', dir, name), 'UTF-8');
	}

	function allDone(_err) {
		server.stop(function (err) {
			appc.spinner.stop();
			if (_err || err) {
				return callback(_err || err);
			} else {
				return callback();
			}
		});
	}
}

function safeName(name) {
	// TODO: There must be a better way to prettify these strings...
	name = name
		.replace('appc.', '')
		.replace(/^id$/, 'ID')
		.replace('md5', 'MD5')
		.replace('urls', 'URLs')
		.replace('acls', 'ACLs')
		.replace('db/', 'DB/')
		.replace('sql/', 'SQL/')
		.replace('/acl', '/ACL')
		.replace(/[\W_]/g, ' ')
		.replace(/[-_\s]+(.)?/g, function (match, char) {
			return char ? char.toUpperCase() : '';
		})
		.replace(/\s/g, '');
	name = name[0].toUpperCase() + name.slice(1);
	return name;
}

function readModule(name, sdkType) {
	var file = path.join(__dirname, '..', '..', 'templates', 'sdk', sdkType, name + '.js');
	if (fs.existsSync(file)) {
		return require(file);
	} else {
		return false;
	}
}

function injectOr(item, index, array) {
	return array.length === index + 1 ? 'or ' + item : item;
}
