/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var fs = require('fs'),
	path = require('path'),
	util = require('./util'),
	wrench = require('wrench'),
	CLI = require('../cli'),
	ArrowCloud = require('../cloud');

// jscs:disable jsDoc

var ROOT = path.resolve(__dirname, '..', '..');

module.exports = {
	type: 'arrow',
	order: 100,
	subtype: 'server',
	name: 'Arrow',
	skipACS: true,
	fields: [
		{
			type: 'input',
			name: 'name',
			message: 'What\'s the project name?',
			validate: function (input) {
				if (!input) {
					return 'You must specify a name!';
				}
				if (input.match(/[^a-z0-9\-_]/i)) {
					return 'Names can only contain A-Z, 0-9, - and _ characters.';
				}
				return true;
			},
			flags: '-n, --name <name>',
			description: 'name of the project'
		}
	],
	execute: execute,
	provisioned: provisioned,
	acsNew: acsNew
};

function acsNew(appc, opts, name, dir, callback) {
	var org_id = opts.session && opts.session.org_id || opts.config && opts.config.org_id;
	var cloud = new ArrowCloud(name, org_id, appc);
	cloud.create(function (err, result) {
		if (err && err.errcode === 230) {
			// already exists with same name.
			if (opts.force) {
				// delete it and then call again
				return cloud.remove(function () {
					acsNew(appc, opts, name, dir, callback);
				});
			}
			return callback(err);
		}
		cloud.getDetails(function (err, result) {
			if (err) { return callback(err); }
			opts.appguid = result.app._id;
			callback(null, result);
		});
	});
}

function execute(appc, args, opts, callback) {
	appc.log.level(opts.logLevel || 'info');

	var dir = opts.projectDir || path.join(process.cwd(), opts.name),
		binargs = ['api', '--name', opts.name, '--dir', dir, '--no-confirm'];

	if (opts.description) {
		binargs.push('--description');
		binargs.push(opts.description);
	}

	if (opts.author) {
		binargs.push('--author');
		binargs.push(opts.author);
	}

	if (opts.force) { binargs.push('--force'); }

	if (opts.config) {
		binargs.push('--config');
		binargs.push(opts.config);
	}

	var cli = new CLI(appc.commander, appc.inquirer);
	cli.logger.level(appc.log.level());
	cli.runCommand('new', binargs, function (err, result, data) {
		if (err) { return callback(err); }
		var serverDir = dir,
			pkgFile = path.join(serverDir, 'package.json');
		try {
			var pkg = JSON.parse(fs.readFileSync(pkgFile, 'utf8'));
			if (!pkg.main) {
				pkg.main = 'app.js';
				fs.writeFileSync(pkgFile, JSON.stringify(pkg, null, 2));
			}
		} catch (e) {
			appc.log.trace(e);
			appc.log.trace(e.stack);
			appc.log.warn('unable to write main to package.json');
		}

		// run ACS new to create the Node.ACS project
		appc.spinner.start();
		acsNew(appc, opts, opts.name, dir, function (err) {
			appc.spinner.stop();
			if (err) { return callback(err); }
			return callback(null, data);
		});
	});
}

/**
 * called for each provisioning step.  at the end, we want to
 * check and see if we got a acs provisioned. if not, provision it
 * since that means this is an Arrow only project and won't have
 * already created one
 */
function provisioned(appc, type, opts, config, callback) {

	if (type === 'completed') {
		appc.log.trace('calling createACSApp', opts.appguid);
		appc.provisioning.createACSApp(config.session, opts.name, opts.appguid, function (err, apps, usernames, passwords, names) {
			if (err) { return callback(err); }

			var dir = path.join(process.cwd(), opts.name),
				apis = dir && path.join(dir, 'apis'),
				sdk = appc.sdk;

			if (fs.existsSync(apis)) {

				// add the ACS connector to appc.json
				var pkgfile = path.join(dir, 'appc.json'),
					pkg = JSON.parse(fs.readFileSync(pkgfile).toString());
				pkg.dependencies = {
					'connector/appc.arrowdb': '*',
					'connector/appc.composite': '*'
				};
				// add typically customized cloud settings
				pkg.cloud = {
					guid: opts.appguid,
					container: 'Dev',
					minimum: 1,
					maximum: 1,
					maxqueuesize: 50,
					environment: {},
					cname: null,
					certificate: null,
					nodeargs: []
				};
				fs.writeFileSync(pkgfile, JSON.stringify(pkg, '\t', 4));

				// write out configuration for each environment
				Object.keys(apps).forEach(function (env) {
					var app = apps[env] || apps.development,
						configfile = path.join(dir, 'conf', 'appc.arrowdb.' + names[env] + '.js'),
						envobj = {
							connectors: {
								'appc.arrowdb': {
									enabled: true,
									connector: 'appc.arrowdb',
									environment: env,
									key: app.key,
									baseurl: app.acsBaseUrl,
									username: usernames[env] || usernames.development,
									password: passwords[env] || passwords.development
								}
							}
						},
						cfg = '/**\n' +
							' * Generated Arrow DB configuration for ' + env + '\n' +
							' */\n' +
							'module.exports = ' + JSON.stringify(envobj, null, 2) + ';';
					fs.writeFileSync(configfile, cfg);
				});

				// update model to use acs connector
				var modelDir = path.join(dir, 'models'),
					modelFile = path.join(modelDir, 'testuser.js'),
					model = fs.readFileSync(modelFile).toString().replace('\'memory\'', '\'appc.arrowdb\'');

				fs.writeFile(modelFile, model, callback);
			} else {
				callback();
			}
		});
	} else {
		callback();
	}
}
