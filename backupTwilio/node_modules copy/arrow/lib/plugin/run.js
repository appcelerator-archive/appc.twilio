/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var _ = require('lodash'),
	fs = require('fs'),
	path = require('path'),
	spawn = require('child_process').spawn,
	util = require('./util');

// jscs:disable jsDoc

var ROOT = path.resolve(__dirname, '..', '..');

module.exports = {
	type: 'arrow',
	subtype: 'server',
	execute: run,
	when: util.canResolveArrowProject,
	order: 1,
	command: function (program, appc) {
		program.option('--workers <workers>', 'number of cluster workers to run (defaults to 1 in development or # of cores in production)');
		program.option('--repl', 'start a repl console once the server is started');
		program.option('-p, --port <port>', 'port to listen on');
	}
};

/**
 * read up to 2 levels of nested directory contents such that we
 * pick up node_modules/connectors/appc.mysql for example not just
 * node_modules/connectors
 */
function readTwoLevelsOfDir(dir) {
	var dirs = [];
	fs.readdirSync(dir).forEach(function (d) {
		if (d === '.npminstall') { return; }
		var nd = path.join(dir, d);
		if (fs.statSync(nd).isDirectory()) {
			fs.readdirSync(nd).forEach(function (cd) {
				dirs.push(path.join(nd, cd));
			});
		} else {
			dirs.push(nd);
		}
	});
	return dirs;
}

function generateInstallToken(appc, nmd, pkg, appcpkg) {
	// create a predictable directory listing
	var dirs = fs.existsSync(nmd) && readTwoLevelsOfDir(nmd) || [],
		nmdToken = appc.misc.sha1(dirs.join('')),
		pkgc = appc.misc.sha1(fs.existsSync(pkg) && fs.readFileSync(pkg).toString()),
		appcp = appc.misc.sha1(fs.existsSync(appcpkg) && fs.readFileSync(appcpkg).toString());
	dirs.sort();
	var result = appc.misc.sha1(appc.version +
		process.env.APPC_SESSION_SID +
		process.env.APPC_SESSION_ENV +
		process.version +
		pkgc +
		appcp
	);
	appc.log.trace('generated npm install token', result, nmdToken);
	return result + ' ' + nmdToken;
}

function install(appc, opts, dir, callback) {
	var pkg = path.join(dir, 'package.json'),
		appcpkg = path.join(dir, 'appc.json'),
		nmd = path.join(dir, 'node_modules'),
		tokenFile = path.join(nmd, '.npminstall'),
		child,
		runopts;

	// if same package.json, same session and same node_modules, we can assume
	// we don't need to run npm install since nothings changed. however, change in the node
	// version, the appc cli version or the arrow version will cause a re-install
	var installToken = generateInstallToken(appc, nmd, pkg, appcpkg);

	// if we have a token and its the same, just skip it...
	if (fs.existsSync(tokenFile)) {
		var token = fs.readFileSync(tokenFile).toString();
		if (token === installToken) {
			appc.log.trace('skipping appc install, install token is the same', installToken);
			return callback();
		} else {
			appc.log.trace('forcing a rebuild, install token is different, is:', installToken, ', was:', token);
			fs.unlinkSync(tokenFile);
			runopts = {stdio: 'ignore', cwd: dir};
			if (/^win/.test(process.platform)) {
				child = spawn(process.env.comspec, ['/c', 'npm'].concat(['rebuild']), runopts);
			} else {
				child = spawn('npm', ['rebuild'], runopts);
			}
			child.on('exit', function (exit) {
				if (exit === 0) {
					return install(appc, opts, dir, callback);
				} else {
					callback(new Error('install failed, npm rebuild exit with exit code', exit));
				}
			});
			return;
		}
	}

	var args = ['install', '--quiet', '--no-banner'];
	!appc.chalk.enabled && args.push('--no-colors');

	runopts = {stdio: 'inherit', cwd: dir};
	if (/^win/.test(process.platform)) {
		child = spawn(process.env.comspec, ['/c', 'appc'].concat(args), runopts);
	} else {
		child = spawn('appc', args, runopts);
	}

	child.on('exit', function (exit) {
		var err = exit ? new Error('exited with non-zero exit code') : null;
		if (!err) {
			// if no error, write out our token file
			// re-generate the token file since appc install likely changed the contents of node_modules
			installToken = generateInstallToken(appc, nmd, pkg, appcpkg);
			return fs.writeFile(tokenFile, installToken, callback);
		}
		callback(err);
	});
}

function run(appc, args, opts, callback) {
	var bin = process.execPath,
		binArgs = ['--no-banner'],
		workers = opts.workers,
		logLevel = appc.log.toLevel() || opts.logLevel || 'info';

	if (appc.chalk.enabled) {
		binArgs = binArgs.concat(['--color', '--colorize']);
	}

	if (opts.repl) {
		binArgs.push('--repl');
	}

	// are we running arrow directly as via an appc project?
	opts.dir = opts.projectDir || process.cwd();
	delete opts.projectDir;

	opts = _.pick(opts, 'dir', 'port', 'random', 'dates');
	Object.keys(opts).forEach(function (opt) {
		if (opt === 'dir') { return; }
		binArgs.push('--' + opt);
		if (opt !== 'random' && opt !== 'dates') {
			binArgs.push(opts[opt]);
		}
	});

	// attempt to install any dependencies
	// we run this manually since it looks like acs run will execute
	// npm install *before* our start script and if there is a start script and
	// a main entry in package.json, acs skips start.  this will ensure that on the
	// first install it gets run
	var calledBack;
	install(appc, opts, opts.dir, function (err) {
		if (err) { return callback(err); }
		var modifiedNodePath = path.join(opts.dir, 'node_modules');
		if (process.env.APPC_INSTALL_BIN_DIR) {
			modifiedNodePath += path.delimiter + path.resolve(path.join(process.env.APPC_INSTALL_BIN_DIR, '..', '..', 'node_modules'));
		}
		var args = binArgs.concat(args || []),
			env = _.merge(process.env, {
				APPC_LOG_LEVEL: logLevel || process.env.APPC_LOG_LEVEL,
				PORT: /^\d+$/.test(opts.port) ? opts.port : undefined,
				NODE_PATH: modifiedNodePath
			});

		if (workers) {
			process.env.APPC_WORKER_COUNT = workers;
		}

		var child,
			stopped,
			restarting,
		// these signals should cause us to kill the server
			signals = ['SIGTERM', 'SIGINT', 'SIGHUP', 'SIGQUIT', 'SIGABRT', 'exit'],
		// these signals should cause us to reload the server
			reload = ['SIGUSR2'];

		/**
		 * Kills the process.
		 */
		function createSignalHandler(name) {
			return function signalHandler(ec) {
				appc.log.trace('signal received', name, 'exit was', ec);
				stopped = true;
				if (child) {
					child.kill(name);
					child.stop();
					child = null;
				}
			};
		}

		signals.forEach(function (name) {
			process.on(name, createSignalHandler(name));
		});

		reload.forEach(function (name) {
			process.on(name, function () {
				appc.log.trace('plugin/run.js: signal received', name, 'restarting');
				restarting = true;
				child && child.restart();
			});
		});

		try {
			var watchIgnorePatterns = [
				'node_modules',
				'node_modules/**/*',
				'logs',
				'.git',
				'.idea',
				'logs/**/*',
				'*.log',
				'web/public/**/*',
				'web/views/**/*',
				'test/**/*',
				'README*',
				'Gruntfile.js',
				'package.json'
			];
			var ignoreFile = path.join(opts.dir, '.arrowignore');
			if (fs.existsSync(ignoreFile)) {
				watchIgnorePatterns = watchIgnorePatterns.concat(fs.readFileSync(ignoreFile, 'UTF-8').split('\n')
					.map(function (str) {
						return str.trim();
					})
					.filter(function (str) {
						return !!str;
					}));
			}
			var Forever = require('forever-monitor');
			child = new (Forever.Monitor)(path.join(__dirname, '..', '..', 'bin', 'run.js'), {
				max: +(process.env.APPC_AUTO_RESTART_COUNT || 3),
				silent: false,
				args: args,
				cwd: opts.dir,
				env: env,
				killTree: true,
				watch: process.env.APPC_AUTO_RESTART === undefined ? true : parseBoolean(process.env.APPC_AUTO_RESTART),
				watchDirectory: opts.dir,
				watchIgnorePatterns: watchIgnorePatterns
			});

			child.on('error', function (err) {
				appc.log.trace(err.stack);
				appc.log.error('error starting process', err);
			});

			child.on('exit', function () {
				if (!stopped) {
					appc.log.warn('child process exited more than 3 times, stopping ...');
					process.exit(1);
				} else {
					process.exit(0);
				}
			});

			child.on('exit:code', function (code) {
				appc.log.debug('detected script exited with exit code', code);
				if (code === 0) {
					// this is a normal shutdown sequence, so we need to just exit
					process.exit(0);
				}
			});

			child.on('restart', function () {
				if (!restarting) {
					appc.log.error('Restarting due to crash');
				}
				restarting = false;
			});

			child.on('watch:restart', function (info) {
				restarting = true;
				console.log('\n\n' + appc.chalk.blue.underline('Restarting due to changes to:') + ' \n\n\t' + appc.chalk.green(info.stat) + '\n\n');
			});

			var stdout = function stdout(buf) {
					var data = buf.toString().replace(/\n$/, '');
					// console.log(data);
					// quick and dirty way to know the server started
					if (!calledBack && data.indexOf('server started') !== -1) {
						calledBack = true;
						try { child && child.removeListener('stdout', stdout); } catch (E) { }
						return callback();
					}
				},
				started = function started() {
					restarting = false;
					child && child.removeListener('start', started);
					setTimeout(function () {
						if (!calledBack) {
							calledBack = true;
							try { child && child.removeListener('stdout', stdout); } catch (E) { }
							return callback();
						}
					}, 2000);
				};

			// listen for initial start
			child.on('stdout', stdout);
			child.on('start', started);

			child.start();
		}
		catch (E) {
			appc.log.trace(E.stack);
			callback(E);
		}
	});
}

/**
 * Turns a string value in to a boolean value.
 * @param val
 * @returns {boolean}
 */
function parseBoolean(val) {
	switch (String(val).toLowerCase().trim()) {
		case 'true':
		case 'yes':
		case '1':
			return true;
		case 'false':
		case 'no':
		case '0':
		case null:
			return false;
		default:
			return Boolean(val);
	}
}
