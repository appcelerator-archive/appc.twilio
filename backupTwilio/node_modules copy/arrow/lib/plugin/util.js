/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
/**
 * plugin utils
 */
var path = require('path'),
	fs = require('fs'),
	_ = require('lodash'),
	chalk = require('chalk'),
	found = {};

// jscs:disable jsDoc

// keep a cache of the found locations so that subsequent calls are fast lookup
function setCache(dir, value) {
	found[dir] = value;
	return value;
}

const types = ['models', 'apis', 'blocks', 'connectors'];

/**
 * given directory dir, returns true if the directory points to an
 * Arrow project directory, false if not
 */
function isArrowProject(dir) {
	// check the cache
	if (dir in found) {
		return found[dir];
	}
	// first check basic locations
	for (var c = 0; c < types.length; c++) {
		var p = path.join(dir, types[c]);
		if (fs.existsSync(p)) {
			return setCache(dir, true);
		}
	}
	// now check conf locations
	var conf = path.join(dir, 'conf', 'default.js');
	if (fs.existsSync(conf)) {
		return setCache(dir, true);
	}
	var pkgf = path.join(dir, 'appc.json');
	if (fs.existsSync(pkgf)) {
		// worse case, take a peek at package.json last
		var pkg = require(pkgf);
		if (pkg) {
			if (/^(block|connector|model|api)$/.test(pkg.type)) {
				return setCache(dir, true);
			}
		}
	}
	return setCache(dir, false);
}

/**
 * return the Arrow project directory
 */
function getProjectDir(opts) {
	var projectDir = opts.projectDir || process.cwd();
	if (isArrowProject(projectDir)) {
		return projectDir;
	}

	var cwd = path.basename(projectDir),
		back = path.join(projectDir, '..');
	// see if we're in one of the subfolders of a project like models
	for (var c = 0; c < types.length; c++) {
		if (cwd === types[c] && isArrowProject(back)) {
			return back;
		}
	}

	throw new Error('cannot find the project directory');
}

/**
 * return true if we can resolve this to a Arrow project
 */
function canResolveArrowProject(opts) {
	try {
		getProjectDir(opts);
		return true;
	}
	catch (E) {
		return false;
	}
}

function generateArgs(name, opts) {
	var args = [name];
	Object.keys(opts).forEach(function (name) {
		var value = opts[name];
		if (!_.isFunction(value)) {
			args.push('--' + name);
			args.push(value);
		}
	});
	return args;
}

function findArrowComponent(appc, opts, pluginExports) {
	var components = [];

	// search for component keywords in a directory
	function search(dir) {
		var pkgFile = path.join(dir, 'appc.json'),
			pkg,
			match,
			rel;
		if (fs.existsSync(pkgFile)) {
			try {
				pkg = JSON.parse(fs.readFileSync(pkgFile, 'utf8'));
				if (!pkg.type) { return; }
				if (/^(connector|model|block|api|appc-cli)$/.test(pkg.type)) {
					var pkgJSON = JSON.parse(fs.readFileSync(path.join(dir, 'package.json')));
					appc.log.debug('found publishable component ' + pkgJSON.name + ' at ' + dir);
					rel = path.relative(process.cwd(), dir);
					components.push({
						name: pkg.type + '/' + pkgJSON.name + '@' + pkgJSON.version + '   ' +
						appc.chalk.dim.gray('[' + (/^[\/.\\]/.test(rel) ? '' : './') + rel + ']'),
						value: {
							name: pkgJSON.name,
							type: pkg.type,
							version: pkgJSON.version,
							dir: dir,
							plugin: pluginExports
						}
					});
					return;
				}
			} catch (e) {
				appc.log.trace('Failed to parse appc.json: ' + e.message);
				return;
			}
			return;
		}
		// check legacy
		pkgFile = path.join(dir, 'package.json');
		if (fs.existsSync(pkgFile)) {
			try {
				pkg = JSON.parse(fs.readFileSync(pkgFile, 'utf8'));
				if (pkg.keywords && pkg.keywords.indexOf('arrow') !== -1) {
					var found = _.filter(pkg.keywords, function (e) {
						return /(apibuilder|arrow)-(connector|model|block|api)/.test(e);
					});
					if (found.length) {
						var type = found[0].split('-')[1];
						appc.log.debug('found publishable component ' + pkg.name + ' at ' + dir);
						rel = path.relative(process.cwd(), dir);
						components.push({
							name: type + '/' + pkg.name + '@' + pkg.version + '   ' +
							appc.chalk.dim.gray('[' + (/^[\/.\\]/.test(rel) ? '' : './') + rel + ']'),
							value: {
								name: pkg.name,
								type: type,
								version: pkg.version,
								dir: dir,
								plugin: pluginExports
							}
						});
						return;
					}
				}
			}
			catch (e) {
				appc.log.trace('Failed to parse package.json: ' + e.message);
				return;
			}
		}
	}

	// search directories for publishable components
	var searchDir = opts.projectDir || process.cwd();
	appc.log.trace('searching for publishable components in ' + searchDir);
	search(searchDir);

	// TODO: any additional places to search?
	return components;
}

/**
 * Prints a warning if the provided Node.js version number differs from the one
 * of the current runtime.
 *
 * @param {number} productionNodeVersion Version of Node.js that will be used in production
 * @param {Object} logger The logger used to print the warning messages
 */
function printSpecifyNodeVersionWarningIfRequired(productionNodeVersion, logger) {
	var runtimeNodeVersion = process.versions.node;
	if (productionNodeVersion === runtimeNodeVersion) {
		return;
	}

	logger.warn('');
	logger.warn(chalk.bgYellow('Specify Node.js version'));
	if (!productionNodeVersion) {
		logger.warn('The version of Node.js that will be used to run your app in production should');
		logger.warn('be defined in your ' + chalk.green('package.json') + '. You should always specify a Node.js version that');
	} else {
		logger.warn('The version of Node.js that will be used to run your app in production doesn\'t match');
		logger.warn('your runtime Node.js version. You should always specify a Node.js version that');
	}
	logger.warn('matches your local runtime Node.js version, which is ' + chalk.bold(runtimeNodeVersion) + '.');
	logger.warn('Please edit your ' + chalk.green('package.json') + ' so it contains something like this:');
	logger.warn('');
	logger.warn('  "engines": {');
	logger.warn('    "node": "' + runtimeNodeVersion + '"');
	logger.warn('  }');
	logger.warn('');
}

exports.isArrowProject = isArrowProject;
exports.getProjectDir = getProjectDir;
exports.canResolveArrowProject = canResolveArrowProject;
exports.generateArgs = generateArgs;
exports.findArrowComponent = findArrowComponent;
exports.printSpecifyNodeVersionWarningIfRequired = printSpecifyNodeVersionWarningIfRequired;
