/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var wrench = require('wrench'),
	async = require('async'),
	crypto = require('crypto'),
	fs = require('fs'),
	path = require('path'),
	ejs = require('ejs'),
	_ = require('lodash'),
	util = require('util'),
	exec = require('child_process').exec;

// jscs:disable jsDoc

var DEFAULT_CONNECTOR = 'tmp';

exports = module.exports = New;

function New(cli) {
	this.cli = cli;
	this.name = 'new';
	this.description = 'create a new component';
}

New.prototype.run = function run(callback, type) {
	var cli = this.cli,
		program = cli.program,
		config = cli.config || {},
		args = arguments;

	if (arguments.length > 2) {
		for (var c = 2; c < arguments.length; c++) {
			var arg = arguments[c];
			if (/^--/.test(arg)) {
				arg = arg.substring(2);
				program[arg] = arguments[c + 1];
				c++;
			}
		}
	}

	this.prompt.apply(this, args);
};

New.prototype.prompt = function prompt(callback, type) {
	var cli = this.cli,
		chalk = cli.chalk,
		program = cli.program,
		config = cli.config,
		inquirer = cli.inquirer,
		nameRegExp = cli.nameRegExp,
		appNameRegExp = cli.appNameRegExp,
		toDir,
		noConfirm = !program.confirm,
		theType = type && type.toLowerCase();

	var questions = [
		//0
		{
			type: 'list',
			name: 'type',
			message: 'What type of project?',
			choices: [
				cli.rpad('API', 15) + chalk.grey('component which exposes a REST API endpoint'),
				cli.rpad('Block', 15) + chalk.grey('component for intercepting requests and responses'),
				cli.rpad('Connector', 15) + chalk.grey('component for communicating with external data systems'),
				cli.rpad('Model', 15) + chalk.grey('component which describes data')
			],
			when: function when(obj) {
				if (theType) {
					// see if our type is in our list
					var value = questions[0].choices.map(function choiceIterator(v) {
						var name = questions[0].filter(v);
						return name.toLowerCase() === theType && name;
					}.bind(this)).filter(function filter(v) {
						return v;
					})[0];
					if (value) {
						// found, we can assign and move on without prompting
						obj.type = value;
						questions[1].message = 'What is the ' + value.toLowerCase() + ' name?';
						return false;
					} else {
						console.log(chalk.red('Invalid project type. Please choose one below:'));
					}
				}
				return true;
			},
			filter: function filter(value) {
				var t = value.split(' ')[0].toLowerCase();
				if (!theType) {
					theType = t.toLowerCase();
				}
				return t;
			}
		},
		//1
		{
			type: 'input',
			name: 'name',
			message: 'What is the name?',
			default: function () {
				return theType === 'connector' ? 'com.connector' :
				'my' + theType.substr(0, 1).toUpperCase() + theType.substr(1).toLowerCase();
			},
			when: function (opts) {
				var name = process.env.PROJECT_NAME || program.name;
				if (name && !_.isFunction(name) && questions[1].validate(name) === true) {
					opts.name = name;
					return false;
				}
				return true;
			},
			validate: function (value) {
				if (theType === 'api') {
					if (!appNameRegExp.test(value)) {
						return 'Invalid name. Use a name like ' + chalk.magenta.bold('my-app') + '. Valid value: ' + chalk.grey(appNameRegExp);
					}
				} else if (theType === 'connector') {
					if (!nameRegExp.test(value)) {
						return 'Invalid name. Use a namespaced URI style name like ' + chalk.magenta.bold('com.myco.connector') + '.';
					}
				}
				return true;
			}
		},
		//2
		{
			type: 'input',
			name: 'description',
			message: 'What is the description?',
			default: function () {
				return 'a new ' + theType;
			},
			when: function (opts) {
				var name = process.env.PROJECT_DESCRIPTION ||
					(!_.isFunction(program.description) && program.description);
				if (name && questions[2].validate(name) === true) {
					opts.description = name;
					return false;
				}
				return !noConfirm;
			},
			validate: function (value) {
				if (!value && !noConfirm) {
					return 'Invalid description. Please provide a short description of the purpose of this project!';
				}
				return true;
			}
		},
		//3
		{
			type: 'input',
			name: 'dir',
			message: 'Which directory to generate into?',
			default: function (opts) {
				return opts.name;
			},
			when: function (opts) {
				if (program.dir && questions[3].validate(program.dir) === true) {
					opts.dir = program.dir;
					return false;
				}
				return true;
			},
			validate: function (value) {
				if (value === '') {
					return 'Please provide directory path!';
				}
				if (fs.existsSync(value)) {
					if (!program.force) {
						questions[4].message = 'Directory exists, overwrite? (y/n)';
						toDir = value;
					}
				}
				return true;
			}
		},
		//4
		{
			type: 'input',
			name: 'delete',
			message: 'Delete?',
			when: function () {
				return !program.force && toDir;
			},
			validate: function (value) {
				value = (value || '').charAt(0).toLowerCase();
				if (value) {
					if (value.charAt(0) === 'n') {
						callback('Cancelled!');
						return false;
					} else if (value === 'y') {
						program.force = true;
						program.confirm = false;
						return true;
					}
				}
				return 'Please choose (y)es or (n)o!';
			}
		}
	];
	inquirer.prompt(questions, function promptCallback(answers) {
		if (arguments.length === 2) {
			answers = arguments[1];
		}
		answers = _.defaults(answers, {
			description: ''
		});
		answers.author = program.author;
		// merge in our appc config
		generateConfigList(function (err, obj) {
			if (err) { return callback(err); }
			obj = _.merge(answers, obj);
			// we still want to override using author if necessary
			obj.author = program.author || obj.author;
			this.generate(obj, callback);
		}.bind(this));
	}.bind(this));
};

function generateConfigList(callback) {
	exec('appc config list -o json', function (err, stdout) {
		if (err) { return callback(err); }
		var json;
		try {
			json = JSON.parse(stdout.trim());
		} catch (e) {
			json = {};
		}
		return callback(null, json);
	});
}

New.prototype.generate = function generate(opts, callback) {
	opts.dir = path.resolve(opts.dir);
	if (process.cwd() !== opts.dir) {
		if (fs.existsSync(opts.dir)) {
			wrench.rmdirSyncRecursive(opts.dir);
		}
		wrench.mkdirSyncRecursive(opts.dir);
	}
	var pkg = this.cli.pkg,
		type = opts.type,
		chalk = this.cli.chalk,
		logger = this.cli.logger,
		tasks = [],
		defaults = {
			versions: process.versions,
			pkg: pkg,
			apikey_production: crypto.randomBytes(24).toString('base64').replace(/[\/=]/g, '0'),
			apikey_preproduction: crypto.randomBytes(24).toString('base64').replace(/[\/=]/g, '0'),
			apikey_development: crypto.randomBytes(24).toString('base64').replace(/[\/=]/g, '0'),
			isTest: !!process.env.TEST,
			session: {
				encryptionKey: crypto.randomBytes(32).toString('base64'),
				signatureKey: crypto.randomBytes(64).toString('base64'),
				secret: crypto.randomBytes(24).toString('base64')
			},
			cookieSecret: crypto.randomBytes(24).toString('base64'),
			username: '',
			org_id: '',
			author: ''
		},
		filter = _.merge(defaults, opts);

	logger.trace('using filter', filter);
	tasks.push(function copyBaseDirTask(next) {
		copyDir('base', opts.dir, filter, next);
	});
	tasks.push(function copyDirTask(next) {
		copyDir(type, opts.dir, filter, next);
	});
	async.series(tasks, function finishCallback(err) {
		if (err) {
			return callback(util.format('generate %s failed: %s', type, err.toString()));
		} else {
			logger.debug('%s %s generated to %s', type, chalk.cyan(opts.name), chalk.yellow(opts.dir));
			!callback && logger.info(chalk.magenta('Done!'));
			callback(null, opts, filter);
		}
	});
};

function copyDir(from, to, filter, callback) {
	var templateDir = path.join(__dirname, '..', '..', 'templates'),
		fromDir = path.join(templateDir, from);

	// make sure the template directory exists
	fs.existsSync(fromDir) && wrench.readdirRecursive(fromDir, function readdirCallback(error, curFiles) {
		if (error) {
			return callback(error);
		}
		if (curFiles) {
			curFiles.forEach(function copyFileCallback(f) {
				var fromPath = path.join(fromDir, f),
					toPath = path.join(to, f);
				if (fs.statSync(fromPath).isDirectory()) {
					wrench.mkdirSyncRecursive(toPath);
				} else {
					copyFile(fromPath, toPath, filter);
				}
			});
		} else {
			callback();
		}
	});
}

var filterable = /\.(js|html|json|txt|md|yml|xml|ini)$/,
	isJSON = /\.json$/,
	isIgnore = /\._(npm|git)ignore$/;

function copyFile(from, to, filter) {
	var buf = fs.readFileSync(from),
		fn = path.basename(to);
	if (filterable.test(fn)) {
		buf = ejs.render(buf.toString(), filter);
		// if this is a target JSON and we already have a base
		// template, we're going to merge in the two templates
		if (isJSON.test(fn) && fs.existsSync(to)) {
			var fromJSON,
				toBuf;
			try {
				fromJSON = JSON.parse(buf);
			}
			catch (E) {
				console.error('Error parsing JSON [', buf, '] from', from);
				console.error(E.message || E);
				process.exit(1);
			}
			try {
				toBuf = ejs.render(fs.readFileSync(to).toString(), filter);
				var toJSON = JSON.parse(toBuf),
					toResult = _.merge(toJSON, fromJSON);
				buf = JSON.stringify(toResult, '\t', 4);
			}
			catch (E) {
				console.error('Error parsing JSON [', toBuf, '] from', to);
				console.error(E.message || E);
				process.exit(1);
			}
		}
	} else if (isIgnore.test(fn)) {
		var m = isIgnore.exec(to);
		to = to.replace('._' + m[1] + 'ignore', '.' + m[1] + 'ignore');
		if (fs.existsSync(to)) {
			// append ignore files
			buf = fs.readFileSync(to) + '\n' + buf;
		}
	}
	// console.log('writing', to, '=>', from);
	fs.writeFileSync(to, buf);
}
