/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var spawn = require('child_process').spawn,
	path = require('path');

// jscs:disable jsDoc

function LogManager(server, logger) {
	this.stopped = true;
	this.logger = logger;
}

LogManager.prototype.start = function () {
	this.logger.trace('LogManager start');
	if (this.process || !this.stopped) {
		throw new Error('already started');
	}
	this.stopped = false;
	var logger = this.logger;
	var fn = path.join(__dirname, 'logprocessor.js');
	logger.trace('running', fn);
	this.process = spawn(process.execPath, [fn], {cwd: process.cwd()});
	this.process.stdout.on('data', function (buf) {
		logger.trace('[logprocessor] ' + buf);
	});
	this.process.stderr.on('data', function (buf) {
		logger.trace('[logprocessor] ' + buf);
	});
	this.process.on('exit', function (exitCode) {
		logger.trace('logprocessor exit', exitCode, ', stopped=', this.stopped);
		if (this.stopped || exitCode === 2) {
			return;
		}
		this.process = null;
		this.stopped = true;
		// re-spawn
		logger.trace('detected unexpected exit, re-spawning');
		setTimeout(this.start.bind(this), 2000);
	}.bind(this));
};

LogManager.prototype.stop = function () {
	this.logger.trace('LogManager stop');
	if (this.process) {
		// mark as stopped so it doesn't respawn
		this.stopped = true;
		try {
			this.process.kill('SIGINT');
		}
		catch (e) {
		}
	}
};

module.exports = LogManager;
