/**
 * Arrow Cloud REST API wrapper
 */
var request = require('request'),
	fs = require('fs'),
	path = require('path'),
	chalk = require('chalk'),
	async = require('async'),
	debug = require('debug')('appc:arrowcloud'),
	acsConfig,
	configHost,
	configPort,
	configCookie,
	appc;

// jscs:disable jsDoc

function loadConfig(callback) {
	var acsFile = path.join(process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE, '.acs');
	var error;
	if (!fs.existsSync(acsFile)) {
		error = new Error('You are not logged in. Please login again.');
		error.errcode = 'loggedout';
		throw error;
	}
	try {
		acsConfig = JSON.parse(fs.readFileSync(acsFile));
	}
	catch (E) {
		error = new Error('You are not logged in. Please login again.');
		error.errcode = 'loggedout';
		throw error;
	}
	configHost = acsConfig.publishHost;
	configPort = acsConfig.publishPort || 443;
	configCookie = acsConfig.cookie && acsConfig.cookie[0] && acsConfig.cookie[0].split(';')[0];
	if (!configHost || !configPort || !configCookie) {
		error = new Error('You are not logged in. Please login again.');
		error.errcode = 'loggedout';
		throw error;
	}
	debug('loaded config host=%s, port=%d, sid=%s', configHost, configPort, configCookie);
}

function getDefaultHost() {
	if (process.env.APPC_ENV === 'preproduction') {
		return 'https://admin.cloudapp-enterprise-preprod.appctest.com';
	}
	return 'https://admin.cloudapp-enterprise.appcelerator.com';
}

function formatBody(body, resp) {
	return body && typeof(body) === 'string' && resp && resp.headers['content-type'] && resp.headers['content-type'].indexOf('/json') > 0 ? JSON.parse(body) : body;
}

function getCredentials(instance, callback, retries) {
	if (instance.username && instance.password && !instance.cookie) {
		var hostname = instance.host || getDefaultHost(),
			port = instance.port || 443,
			path = instance.path || '',
			opts = {
				url: hostname + ':' + port + path + '/login',
				method: 'post',
				headers: {
					'Content-Type': 'application/x-www-form-urlencoded',
					'User-Agent': appc && appc.sdk.userAgent || 'Appcelerator',
					'Accept': 'text/json, application/json'
				},
				form: {
					login: instance.username,
					password: instance.password
				}
			};
		debug('sending %j', opts);
		return request(opts, function (err, resp, body) {
			body = formatBody(body, resp);
			debug('receiving err1=%j, body=%j', err, body);
			// if we receive a cloud error that looks like a restart, try again
			if (resp && /^(408|500|502|503|404)$/.test(String(resp.statusCode))) {
				retries = retries || 1;
				debug('detected server error, will re-try again in %d ms', 500 * retries);
				return setTimeout(function () {
					getCredentials(instance, callback, retries + 1);
				}, 500 * retries);
			}
			if (err) { return callback(err); }
			if (body && body.success) {
				var cookie = resp.headers['set-cookie'];
				if (cookie && cookie.length) {
					var sid;
					for (var c = 0; c < cookie.length; c++) {
						var line = cookie[c].split(';')[0],
							token = line.split('=');
						if (token[0] === 'connect.sid') {
							sid = line;
							break;
						}
					}
					if (!sid) {
						return callback(new Error('invalid login. no session was created'));
					}
					instance.port = port;
					instance.cookie = sid;
					instance.host = hostname;
					instance.path = path;
					return callback(null, {
						host: hostname,
						port: port,
						path: path,
						cookie: sid
					});
				}
			} else if (body && body.message) {
				return callback(new Error(body.message));
			}
			return callback(new Error('login error'));
		});
	} else if (instance && instance.cookie) {
		return callback(null, {
			host: instance.host,
			port: instance.port,
			path: instance.path,
			cookie: instance.cookie
		});
	} else if (!acsConfig) {
		try {
			loadConfig();
		}
		catch (E) {
			return callback(E);
		}
	}
	return callback(null, {
		host: configHost,
		port: configPort,
		cookie: configCookie,
		path: ''
	});
}

function sendHTTPRequest(instance, method, uriPath, json, callback, optsCallback, reqCallback, retries) {
	startSpinner();
	getCredentials(instance, function (err, credentials) {
		if (err) { return callback(err); }
		var opts = {
			method: method,
			url: credentials.host + ':' + credentials.port + (credentials.path || '') + uriPath,
			headers: {
				'Cookie': credentials.cookie,
				'User-Agent': appc && appc.sdk.userAgent || 'Appcelerator',
				'Accept': 'text/json, application/json'
			},
			gzip: true
		};
		if (json instanceof Buffer) {
			opts.headers['Content-Type'] = 'application/octet-stream';
			opts.headers['Content-Disposition'] = 'attachment;filename=sslcert';
			opts.headers['Content-Length'] = String(Buffer.byteLength(json));
			opts.body = json;
		} else if (json && typeof(json) === 'object') {
			opts.json = json;
		} else if (json && typeof(json) === 'string') {
			opts.url += '?' + json;
		}
		optsCallback && optsCallback(opts);
		debug('sending %j', opts);
		startSpinner();
		var req = request(opts, function (err, resp, body) {
			body = formatBody(body, resp);
			stopSpinner();
			debug('receiving err2=%j, body=%j', err, body);
			// if we receive a cloud error that looks like a restart, try again
			if (resp && /^(408|500|502|503|404)$/.test(String(resp.statusCode))) {
				retries = retries || 1;
				debug('detected server error, will re-try again in %d ms', 500 * retries);
				return setTimeout(function () {
					sendHTTPRequest(instance, method, uriPath, json, callback, optsCallback, reqCallback, retries + 1);
				}, 500 * retries);
			}
			if (err) {
				if (err.code === 'ENOTFOUND') {
					return callback('Either you are offline, or the server cannot be reached. Please check your connection and try again.');
				}
				return callback(err);
			}
			var error;
			if (resp.statusCode > 200 && typeof(body) === 'string') {
				error = new Error(body);
				error.statusCode = resp.statusCode;
				return callback && callback(error);
			}
			if (body && !body.success) {
				error = new Error(body.message);
				error.errcode = body.errcode;
				error.statusCode = resp.statusCode;
				return callback && callback(error);
			}
			callback(err, body);
		});
		reqCallback && reqCallback(req);
	});
}

function ArrowCloudApp(name, org_id, appc_) {
	this.name = name;
	this.org_id = org_id || process.env.APPC_SESSION_ORGID;
	appc = appc_;
	if (appc && appc.log) {
		// if we provided an appc ref, use that instead of debug lib
		debug = appc.log.debug.bind(appc.log);
	}
}

/**
 * remove an app
 */
ArrowCloudApp.prototype.remove = function (callback) {
	sendHTTPRequest(this, 'post', '/remove/' + encodeURIComponent(this.name), 'orgid=' + this.org_id, callback);
};

/**
 * unpublish app
 */
ArrowCloudApp.prototype.unpublish = function (version, callback) {
	if (typeof(version) === 'function') {
		callback = version;
		version = null;
	}
	var verString = '/' + encodeURIComponent(version || 'deployed');
	sendHTTPRequest(this, 'post', '/unpublish/' + encodeURIComponent(this.name) + verString, 'orgid=' + this.org_id, callback);
};

/**
 * get current versions of app
 */
ArrowCloudApp.prototype.getVersions = function (callback) {
	var regex = /Published versions?: (.*)?. The version is deployed currently: (.*)./;
	sendHTTPRequest(this, 'get', '/publish/' + encodeURIComponent(this.name), 'orgid=' + this.org_id, function (err, body) {
		if (err) { return callback(err); }
		var tokens = regex.exec(body.message);
		var versions = tokens && tokens.length && tokens[1].split(',').map(function (v) {
			return v.trim();
		});
		callback(null, {
			current_version: tokens && tokens.length && tokens[2].trim(),
			versions: versions
		});
	});
};

/**
 * get current versions of app
 */
ArrowCloudApp.prototype.setVersion = function (version, callback) {
	sendHTTPRequest(this, 'post', '/publish/' + encodeURIComponent(this.name) + '/' + encodeURIComponent(version), 'orgid=' + this.org_id, callback);
};

/**
 * get the details about an app
 */
ArrowCloudApp.prototype.getDetails = function (callback) {
	var orgid = this.org_id;
	sendHTTPRequest(this, 'get', '/list/' + encodeURIComponent(this.name), 'orgid=' + orgid, function (err, body) {
		if (err) { return callback(err); }
		if (!body.apps || !body.apps.length) {
			var error = new Error(body.message);
			return callback && callback(error);
		}
		if (body && body.apps && body.apps.length) {
			// find the current org
			body.apps = body.apps.filter(function (app) {
				return app.orgid === orgid || app.orgid === String(orgid);
			});
		}
		var result = {
			success: true,
			app: body && body.apps && body.apps[0],
			quota: body && body.quotas && body.apps && body.quotas.filter(function (e) {return e.orgid === body.apps.length && body.apps[0].orgid;})[0]
		};
		callback && callback(null, result);
	});
};

/**
 * create an app
 */
ArrowCloudApp.prototype.create = function (callback) {
	sendHTTPRequest(this, 'post', '/create/' + encodeURIComponent(this.name), {orgid: this.org_id}, callback);
};

/**
 * set the CNAME to the app
 */
ArrowCloudApp.prototype.setCName = function (cname, callback) {
	sendHTTPRequest(this, 'post', '/cname/set/' + encodeURIComponent(this.name) + '/' + encodeURIComponent(cname), {orgid: this.org_id}, callback);
};

/**
 * get the CNAME to the app
 */
ArrowCloudApp.prototype.getCName = function (callback) {
	sendHTTPRequest(this, 'post', '/cname/check/' + encodeURIComponent(this.name), {orgid: this.org_id}, function (err, body) {
		if (err) { return callback(err); }
		// NOTE: this is so hacky.  we get back a semi structure (escaped in weird way) json as part
		// of the body message and we have to parse it out
		var re = /name: '(.*)'/.exec(body.message);
		var name = re && re.length && re[1];
		re = /domain: \[(.*)\]/.exec(body.message);
		var domain = re && re.length && re[1];
		domain = domain && domain.replace(/\'/g, '');
		callback(null, {
			name: name,
			domain: domain && domain.split(',').map(function (n) {return n.trim();})
		});
	});
};

/**
 * set the CNAME to the app
 */
ArrowCloudApp.prototype.removeCName = function (cname, callback) {
	if (typeof (cname) === 'function') {
		callback = cname;
		cname = '';
	}
	sendHTTPRequest(this, 'post', '/cname/remove/' + encodeURIComponent(this.name) + (cname ? '/' + encodeURIComponent(cname) : ''), {orgid: this.org_id}, callback);
};

/**
 * set the path to the app
 */
ArrowCloudApp.prototype.setCNamePath = function (cpath, callback) {
	sendHTTPRequest(this, 'post', '/cname/path/' + encodeURIComponent(this.name) + '/' + encodeURIComponent(cpath), {orgid: this.org_id}, callback);
};

/**
 * set the domain to the app
 */
ArrowCloudApp.prototype.setDomain = function (cname, callback) {
	sendHTTPRequest(this, 'post', '/domain/set/' + encodeURIComponent(this.name) + '/' + encodeURIComponent(cname), {orgid: this.org_id}, callback);
};

/**
 * get the domain to the app
 */
ArrowCloudApp.prototype.getDomain = function (cname, callback) {
	sendHTTPRequest(this, 'post', '/domain/check/' + encodeURIComponent(this.name), {orgid: this.org_id}, callback);
};

/**
 * set the domain to the app
 */
ArrowCloudApp.prototype.removeDomain = function (cname, callback) {
	if (typeof (cname) === 'function') {
		callback = cname;
		cname = '';
	}
	sendHTTPRequest(this, 'post', '/domain/remove/' + encodeURIComponent(this.name) + (cname ? '/' + encodeURIComponent(cname) : ''), {orgid: this.org_id}, callback);
};

/**
 * set the path to the app
 */
ArrowCloudApp.prototype.setDomainPath = function (cpath, callback) {
	sendHTTPRequest(this, 'post', '/domain/path/' + encodeURIComponent(this.name) + '/' + encodeURIComponent(cpath), {orgid: this.org_id}, callback);
};

/**
 * set the container size of the app
 */
ArrowCloudApp.prototype.setContainer = function (size, callback) {
	size = size.toLowerCase();
	switch (size) {
		case 'dev':
			size = 'Dev';
			break;
		case 'small':
			size = 'Small';
			break;
		case 'medium':
			size = 'Medium';
			break;
		case 'large':
			size = 'Large';
			break;
		case 'xlarge':
			size = 'XLarge';
			break;
		default:
			return callback(new Error('unsupported size: ' + size));
	}
	sendHTTPRequest(this, 'post', '/server/' + encodeURIComponent(this.name) + '/set/' + size, {orgid: this.org_id}, callback);
};

/**
 * get the app environment variables
 */
ArrowCloudApp.prototype.getEnvironment = function (callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/env', {orgid: this.org_id}, function (err, body) {
		if (err && err.errcode === 247) {
			return callback && callback(null, {});
		}
		var env = {};
		body.message && body.message.split(/\n/).forEach(function (line) {
			var i = line.indexOf(' = ');
			var k = line.substring(0, i).trim();
			var v = line.substring(i + 2).trim();
			env[k] = v;
		});
		return callback(err, env);
	});
};

/**
 * set the app environment variables
 */
ArrowCloudApp.prototype.setEnvironment = function (env, callback) {
	sendHTTPRequest(this, 'post', '/config/' + encodeURIComponent(this.name) + '/env?orgid=' + this.org_id, env, callback);
};

/**
 * set the app environment variables
 */
ArrowCloudApp.prototype.getSSLCertificate = function (callback) {
	sendHTTPRequest(this, 'get', '/certs/show/' + encodeURIComponent(this.name), {orgid: this.org_id}, callback);
};

/**
 * set the app environment variables
 */
ArrowCloudApp.prototype.removeSSLCertificate = function (callback) {
	sendHTTPRequest(this, 'delete', '/certs/' + encodeURIComponent(this.name), {orgid: this.org_id}, callback);
};

/**
 * set a SSL certificate. the cert must be a Buffer
 */
ArrowCloudApp.prototype.setSSLCertificate = function (cert, callback) {
	if (!(cert instanceof Buffer) && typeof(cert) !== 'string') {
		return callback(new Error('certificate must be a Buffer or String'));
	}
	sendHTTPRequest(this, 'post', '/certs/' + encodeURIComponent(this.name) + '?orgid=' + this.org_id, cert, callback);
};

/**
 * download the app
 */
ArrowCloudApp.prototype.download = function (version, filename, callback) {
	sendHTTPRequest(this, 'get', '/download/' + encodeURIComponent(this.name) + '/' + encodeURIComponent(version), {orgid: this.org_id}, callback);
};

/**
 * set min containers
 */
ArrowCloudApp.prototype.setMinimum = function (value, callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/min/' + encodeURIComponent(value), {orgid: this.org_id}, callback);
};

/**
 * set max containers
 */
ArrowCloudApp.prototype.setMaximum = function (value, callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/max/' + encodeURIComponent(value), {orgid: this.org_id}, callback);
};

/**
 * set max queued requests before scaling
 */
ArrowCloudApp.prototype.setMaximumQueuedRequests = function (value, callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/maxqueuedrequests/' + encodeURIComponent(value), {orgid: this.org_id}, callback);
};

/**
 * set whether the container should autoscale up
 */
ArrowCloudApp.prototype.setAutoscaleUp = function (value, callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/autoup/' + (value ? 'true' : 'false'), {orgid: this.org_id}, callback);
};

/**
 * set whether the container should autoscale down
 */
ArrowCloudApp.prototype.setAutoscaleDown = function (value, callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/autodown/' + (value ? 'true' : 'false'), {orgid: this.org_id}, callback);
};

/**
 * get the status for the app
 */
ArrowCloudApp.prototype.getStatus = function (callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/appstatus', {orgid: this.org_id}, function (err, body) {
		if (err) { return callback(err); }
		return callback(null, body.message);
	});
};

/**
 * start the spinner
 */
function startSpinner() {
	if (appc) {
		appc.spinner.start();
	}
}

/**
 * stop the spinner
 */
function stopSpinner() {
	if (appc) {
		appc.spinner.stop();
	}
}

/**
 * write a wait message and start spinner
 */
function waitMessage(msg) {
	if (appc) {
		appc.log.info(msg);
	}
}

/**
 * write message and stop spinner
 */
function infoMessage(msg) {
	if (appc) {
		appc.log.info(msg);
	}
}

/**
 * if we have more than 10 versions, we should remove the oldest
 */
function undeployEarliestVersionIfNeeded(app, cb) {
	// check and see if we have more than 10 published and remove the oldest
	return app.getVersions(function (err, detail) {
		if (detail && detail.versions && detail.versions.length === 10) {
			debug('undeploying old version: %s', detail.versions[0]);
			app.unpublish(detail.versions[0], cb);
		} else {
			cb();
		}
	});
}

/**
 * publish the app
 */
ArrowCloudApp.prototype.publish = function (dir, force, callback, predeployCallback) {
	startSpinner();
	if (typeof(force) === 'function') {
		predeployCallback = callback;
		callback = force;
		force = false;
	}
	var pkg,
		appcJSON;
	try {
		var packageJSON = path.join(dir, 'package.json');
		if (!fs.existsSync(packageJSON)) {
			return callback(new Error('couldn\'t find ' + packageJSON));
		}
		pkg = JSON.parse(fs.readFileSync(packageJSON));
	}
	catch (E) {
		stopSpinner();
		return callback(new Error('error parsing application package.json. ' + E.message));
	}
	try {
		appcJSON = path.join(dir, 'appc.json');
		if (fs.existsSync(appcJSON)) {
			appcJSON = JSON.parse(fs.readFileSync(appcJSON));
		} else {
			appcJSON = {};
		}
	}
	catch (E) {
		appcJSON = {};
	}

	var self = this;
	force = +force;

	if (isNaN(force)) {
		force = false;
	}

	waitMessage('Publishing application ... this could take several minutes');

	undeployEarliestVersionIfNeeded(self, function () {

		sendHTTPRequest(self, 'get', '/publish/' + encodeURIComponent(self.name) + '/' + encodeURIComponent(pkg.version) + '/' + (+force), 'orgid=' + self.org_id, function (err, body) {
			if (err) {
				stopSpinner();
				return callback(err);
			}

			var wrench = require('wrench'),
				Targz = require('tar.gz'),
				exec = require('child_process').exec,
				chalk = require('chalk'),
				zlib = require('zlib'),
				crypto = require('crypto'),
				tmpdir = require('os').tmpdir(),
				deployDir = path.join(tmpdir, 'arrowcloud-publish-' + Date.now()),
				extractDir = path.join(deployDir, '/extract-' + pkg.name + '-' + pkg.version),
				uploadFile = path.join(tmpdir, 'arrowcloud-publish-' + pkg.name + '-' + pkg.version + '.tgz'),
				length = 0,
				md5sum = crypto.createHash('md5'),
				arrowReponse,
				currentVersion,
				versions,
				cloud;

			waitMessage('Packaging application ... ');

			async.series([

				function (cb) {
					// check and see if we have a successfully deployed app that we can use to rollback if failured
					self.getDetails(function (err, details) {
						if (details && details.app && details.app.status !== 'Failed to deploy' && details.app.currentPublish) {
							currentVersion = Object.keys(details.app.currentPublish)[0];
							versions = Object.keys(details.app.publishes);
							debug('current version %s', currentVersion);
						}
						cb();
					});
				},

				function (cb) {

					// copy into a temporary directory
					wrench.copyDirSyncRecursive(dir, deployDir, {
						forceDelete: false,
						exclude: function (filename, adir) {
							var relative = path.relative(deployDir, adir);
							if (relative === 'node_modules') {
								return true;
							}
							if (relative === 'logs') {
								return true;
							}
						}
					});

					// remove these directories
					['node_modules', 'logs'].forEach(function (name) {
						var adir = path.join(deployDir, name);
						fs.existsSync(adir) && wrench.rmdirSyncRecursive(adir);
					});

					// remove these files since they aren't needed
					['.gitignore', 'Gruntfile.js', '.jshintrc', 'README.md', '.travis.yml', 'npm-debug.log', 'conf/local.js', 'conf/development.js'].forEach(function (name) {
						var fn = path.join(deployDir, name);
						fs.existsSync(fn) && fs.unlinkSync(fn);
					});

					// don't publish any possibly sensitive local config files
					var confDir = path.join(deployDir, 'conf');
					fs.existsSync(confDir) && fs.readdirSync(confDir).forEach(function (name) {
						if (/.*\.(development|local)\.js/.test(name)) {
							var fn = path.join(deployDir, 'conf', name);
							debug('removing %s', fn);
							fs.unlinkSync(fn);
						}
					});

					cb();
				},

				function (cb) {
					debug('npm pack %s', deployDir);
					exec('npm pack', {cwd: deployDir}, cb);
				},

				function (cb) {
					var packFile = path.join(deployDir, pkg.name + '-' + pkg.version + '.tgz');
					debug('extract %s -> %s', packFile, extractDir);
					new Targz().extract(packFile, extractDir, cb);
				},

				function (cb) {
					// install our npm lifecycle script
					var arrowPkg = JSON.parse(fs.readFileSync(path.join(__dirname, '..', '..', 'package.json')));
					pkg.scripts = pkg.scripts || {};
					// add our install scripts
					pkg.scripts.install = 'node ./__arrow_install.js; ' + (pkg.scripts.install || '');
					pkg.scripts.postinstall = 'node ./__arrow_postinstall.js; ' + (pkg.scripts.postinstall || '');
					if (pkg.scripts.start) {
						pkg.scripts.poststart = pkg.scripts.start;
					}
					pkg.scripts.start = 'node ./__arrow_start.js; ';
					pkg.dependencies = pkg.dependencies || {};
					pkg.dependencies.arrow = pkg.dependencies.arrow || arrowPkg.version;
					pkg.dependencies.async = pkg.dependencies.async || '*'; // __arrow_install.js requires this
					pkg.dependencies.debug = pkg.dependencies.debug || '*';
					delete pkg.ensureLatest;
					delete pkg.devDependencies;
					pkg._main = pkg.main;
					delete pkg.main;
					// migrate old projects in case they aren't set but don't touch
					// if it's changed by the developer
					if (pkg.healthCheck === undefined && appcJSON.type === 'api') {
						pkg.healthCheck = true;
					}
					var pkgFile = path.join(extractDir, 'package', 'package.json');
					var pkgContents = JSON.stringify(pkg, null, 2);
					debug('writing package.json(1) %s', pkgContents);
					fs.writeFile(pkgFile, pkgContents, cb);
				},

				function (cb) {
					// write the install script
					var from = path.join(__dirname, '..', '..', 'templates', 'publish', '__arrow_install.js');
					var to = path.join(extractDir, 'package', '__arrow_install.js');
					debug('copy %s -> %s', from, to);
					fs.writeFile(to, fs.readFileSync(from), cb);
				},

				function (cb) {
					// write the postinstall script
					var from = path.join(__dirname, '..', '..', 'templates', 'publish', '__arrow_postinstall.js');
					var to = path.join(extractDir, 'package', '__arrow_postinstall.js');
					debug('copy %s -> %s', from, to);
					fs.writeFile(to, fs.readFileSync(from), cb);
				},

				function (cb) {
					// write the start script
					var from = path.join(__dirname, '..', '..', 'bin', 'run.js');
					var to = path.join(extractDir, 'package', '__arrow_start.js');
					debug('copy %s -> %s', from, to);
					fs.writeFile(to, fs.readFileSync(from), cb);
				},

				function (cb) {
					// install our appc dependencies
					if (!appc) {
						return cb();
					}
					var baseDir = path.join(extractDir, 'package');
					debug('appc install %s', baseDir);
					var level = appc.log.level();
					appc.log.level('warn');
					appc.plugins.install.execute(appc, [],
						{projectDir: baseDir, skipNpm: true, quiet: true},
						function (err, result) {
							appc.log.level(level);
							cb(err, result);
						});
				},

				function (cb) {
					startSpinner();
					// remove our node_modules, we'll re-install on the server side
					['connectors', 'models', 'blocks'].forEach(function (name) {
						var nmd = path.join(extractDir, 'package', 'node_modules', name);
						debug('checking %s', nmd);
						if (fs.existsSync(nmd)) {
							var dirs = fs.readdirSync(nmd);
							for (var c = 0; c < dirs.length; c++) {
								var cnmd = path.join(nmd, dirs[c], 'node_modules');
								if (fs.existsSync(cnmd)) {
									debug('removing %s', cnmd);
									wrench.rmdirSyncRecursive(cnmd);
								}
							}
						}
					});
					cb();
				},

				function (cb) {
					if (predeployCallback) {
						predeployCallback(path.join(extractDir, 'package'), cb);
					} else {
						cb();
					}
				},

				function (cb) {
					// install any private node_modules
					if (pkg.dependencies && Object.keys(pkg.dependencies).length) {
						Object.keys(pkg.dependencies).forEach(function (k) {
							var ver = pkg.dependencies[k];
							// if this looks like an invalid version range it's probably a github
							// url (such as foo/bar or git@github.com:foo/bar.git) or empty version
							if (!ver || (appc && appc.semver && !appc.semver.validRange(ver))) {
								var nmd = path.join(dir, 'node_modules', k);
								if (fs.existsSync(nmd)) {
									// place in a special directory that will be handled in __arrow_install.js
									var tnmd = path.join(extractDir, 'package', 'node_modules');
									if (!fs.existsSync(tnmd)) {
										fs.mkdir(tnmd);
									}
									debug('copying private module %s -> %s', nmd, tnmd);
									wrench.copyDirSyncRecursive(nmd, path.join(tnmd, k));
									// delete it so that we don't try and npm install it again on server side
									// since that will failå
									delete pkg.dependencies[k];
								} else {
									appc && appc.log.warn('Couldn\'t find required node module: ' + k + ' at ' + nmd);
								}
							}
						});
						// re-write it
						var pkgFile = path.join(extractDir, 'package', 'package.json');
						var pkgContents = JSON.stringify(pkg, null, 2);
						debug('writing package.json(2) %s', pkgContents);
						return fs.writeFile(pkgFile, pkgContents, cb);
					} else {
						cb();
					}
				},

				function (cb) {
					var packageDir = path.join(extractDir, 'package');
					deployDir = path.join(extractDir, '' + pkg.version);
					debug('rename %s -> %s', packageDir, deployDir);
					fs.rename(packageDir, deployDir, cb);
				},

				function (cb) {
					debug('compress %s -> %s', deployDir, uploadFile);
					new Targz().compress(deployDir, uploadFile, cb);
				},

				function (cb) {
					startSpinner();
					var stream = fs.createReadStream(uploadFile);
					stream.on('data', function (buf) {
						md5sum.update(buf, 'utf8');
						length += buf.length;
					});
					stream.on('end', cb);
				},

				function (cb) {
					var pre = function (opts) {
							opts.headers['Content-Type'] = 'application/octet-stream';
							opts.headers['Content-Length'] = String(length);
							opts.headers['Content-Disposition'] = 'attachment;filename=' + path.basename(uploadFile);
							opts.headers['X-Content-Checksum'] = md5sum.digest('hex');
							opts.timeout = 5 * 60000;
						},
						post = function (req) {
							fs.createReadStream(uploadFile)
								.on('end', function () {
									waitMessage('Deploying application ... ');
								})
								.pipe(req);
						},
						endPoint = '/publish/' + encodeURIComponent(self.name) + '/' + encodeURIComponent(pkg.version) + '/' + (+force);

					sendHTTPRequest(self, 'post', endPoint, 'async=true&orgid=' + self.org_id, function (err, body) {
						// check if a client side timeout waiting on server and if so, give a more friendly reason
						if (err && err.code === 'ETIMEDOUT') {
							err.message = 'Timed out waiting for deployment to complete. Please try your publish again in a few minutes.';
							return cb(err);
						}
						if (err) { return cb(err); }
						arrowReponse = body;
						cb();
					}, pre, post);
				},

				function (cb) {
					// wait for deployment to finish
					waitMessage('Starting application ... ');
					var started = false;
					var deployStarted = Date.now();
					async.whilst(
						function () { return !started; },
						function (next) {
							startSpinner();
							self.getDetails(function (err, details) {
								if (err) { return next(err); }
								var error;
								if (details.app.servers && details.app.servers.length) {
									for (var c = 0; c < details.app.servers.length; c++) {
										var server = details.app.servers[c];
										// if we find at least one server running, we can break out
										// ACS with OpenVZ is Deployed
										// ACS with Docker is Running
										if (/(Running|Deployed)/.test(server.status)) {
											started = true;
											break;
										} else if (server.status === 'Failed') {
											stopSpinner();
											error = new Error('Deployment failed');
											error.errno = 'deployment_failed';
											error.failure = server.message;
											return next(error);
										}
									}
								}
								// check to see if this is a failure
								if (details.app.status === 'Failed to deploy') {
									stopSpinner();
									error = new Error('Deployment failed. ' + (details.app.message || 'Please run "appc cloud loglist" to see what errors are reported.'));
									return next(error);
								}
								// timed out
								if (Date.now() - deployStarted > (5 * 60000)) {
									stopSpinner();
									error = new Error('Deployment failed');
									error.errno = 'deployment_timeout';
									return next(error);
								}
								startSpinner();
								setTimeout(next, 1000);
							});
						},
						cb
					);
				}

			], function (err) {
				fs.existsSync(deployDir) && wrench.rmdirSyncRecursive(deployDir);

				stopSpinner();

				if (err && err.errno === 'deployment_failed' && currentVersion) {
					debug('deployment failed, attempting to rollback to %s', currentVersion);
					console.log('Deployment failed. Rolling back to version: ' + currentVersion);
					return self.setVersion(currentVersion, function () {
						// NODEJS-2018 - force a env change to cause reployment
						self.setEnvironment({ARROW_FAILED_DEPLOY: '' + Date.now()}, function () {
							err.rollback_version = currentVersion;
							return callback(err);
						});
					});
				}

				callback(err, arrowReponse);
			});
		});

	});
};

module.exports = ArrowCloudApp;

if (module.id === '.') {
	var app = new ArrowCloudApp('appc-registry-server', 14301);
	var createApp = false;
	app.host = 'https://admin.cloudapp-enterprise-preprod.appctest.com';
	app.username = process.argv[2];
	app.password = process.argv[3];
	app.getCName(function (err, details) {
		details && console.log('status', details);
	});
}
