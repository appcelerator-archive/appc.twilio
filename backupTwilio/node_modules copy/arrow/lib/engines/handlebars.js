// jscs:disable
/**
 * @class HandlebarsRendererEngine
 * Renderer engine for Handlebar templates.
 * @extends ArrowRendererEngine
 * @pseudo
 */

/**
 * @property skipread
 * @hide
 */
// jscs:enable

var handlebars = require('handlebars'),
	fs = require('fs'),
	util = require('./util'),
	watchers = [];

// jscs:disable jsDoc

exports.extension = 'hbs';

function render(app, filename, opts) {
	filename = util.resolveLayoutFilename(app, filename);
	var tpl = handlebars.compile(fs.readFileSync(filename).toString(), {noEscape: true});
	return tpl(opts).toString();
}

exports.createRenderer = function (content, filename, app) {
	var tpl = handlebars.compile(content, {noEscape: true});
	return function (filePath, opts, callback) {
		util.render(app, tpl(opts || {}).toString(), opts, exports.extension, render, callback);
	};
};

/**
 * @property {Object} Handlebars
 * handlebars module instance to access its APIs.
 */
exports.Handlebars = handlebars;

/**
 * @method registerHelper
 * Registers a handlebar helper function.
 * @param {String} name Field name.
 * @param {Function} callback Helper function.
 */
exports.registerHelper = handlebars.registerHelper.bind(handlebars);
/**
 * @method registerPartial
 * Registers a partial template.
 * @param {String} name Name of the partial template.
 * @param {String} template Template string.
 */
exports.registerPartial = handlebars.registerPartial.bind(handlebars);

function isProduction() {
	return process.env.NODE_ENV === 'production' ||
		(process.env.serverId && process.env.appid);
}

/**
 * Loops through a directory and sets up all of the
 * associated files as Handlebar Partials.
 *
 * @param {String} dir Path of the directory to use as partials directory
 * @param {Boolean} watch Set to `true` to monitor and update file changes.
 */
exports.registerPartials = function (dir, watch) {
	var fs = require('fs'),
		path = require('path'),
		ext = '.' + exports.extension;
	fs.readdirSync(dir)
		.filter(function (fn) { return path.extname(fn) === ext; })
		.forEach(function (fn) {
			var f = path.join(dir, fn),
				stat = fs.statSync(f);
			if (stat.isDirectory()) {
				exports.registerPartials(f);
			} else {
				var fileName = path.basename(f).replace(ext, '');
				handlebars.registerPartial(fileName, fs.readFileSync(f, 'utf8'));
			}
		});
	if (watch === undefined && !isProduction() || watch) {
		var watcher = fs.watch(dir, {persistent: true, recursive: true}, function (event, filename) {
			// according to the docs, filename isn't always provided
			if (filename) {
				var name = path.basename(filename).replace(ext, '');
				filename = path.join(dir, filename);
				if (fs.existsSync(filename)) {
					handlebars.registerPartial(name, fs.readFileSync(filename, 'utf8'));
				}
			}
		});
		watchers.push(watcher);
	}
};

exports.cleanupWatchers = function () {
	for (var i = 0; i < watchers.length; i++) {
		watchers[i].close();
	}
	watchers = [];
};
