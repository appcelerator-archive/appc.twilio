// jscs:disable jsDoc
var _ = require('lodash');
var om = require('arrow-objectmodel');

var verbMap = {
	POST: 'create',
	GET: 'find',
	PUT: 'update',
	DELETE: 'delete'
};

module.exports.bindRoutes = bindRoutes;
module.exports.generateDefinition = generateDefinition;
module.exports.generateDefinitionByQuery = generateDefinitionByQuery;

function bindRoutes(arrow) {
	var admingConfig = arrow.config.admin || {};
	var routePrefix = admingConfig.prefix || '/arrow';
	var app = arrow.app;

	arrow.logger.trace('Registering swagger routes under path ' + routePrefix);
	app.get(routePrefix + '/docs.json', getDefinition);
	app.get(routePrefix + '/swagger.json', getDefinition);
	if (admingConfig.disableAPIDoc === false) {
		var docsRoutePrefix = admingConfig.apiDocPrefix || '/apidoc';
		arrow.logger.trace('Registering swagger routes under path ' + docsRoutePrefix);
		app.get(docsRoutePrefix + '/docs.json', getDefinition);
		app.get(docsRoutePrefix + '/swagger.json', getDefinition);
	}

	var objectModel = new om.ObjectModel(arrow);
	function getDefinition(req, res) {
		res.set('Content-Type', 'application/json');
		res.send(generateDefinitionByQuery(req.get('host'), objectModel, req.query));
	}
}

function transformKeyForComparison(val) {
	return val.replace(/[^a-z0-9]/ig, '').toLowerCase();
}

function generateDefinitionByQuery(host, objectModel, query) {
	var om = _.clone(objectModel);

	if (query && !_.isEmpty(query)) {
		query = transformKeyForComparison(Object.keys(query).shift().split('/').pop().replace(/\.(json|html)/g, ''));
		var matchesQuery = function (value, key) {
			return transformKeyForComparison(key) === query;
		};

		om.apis = pickBy(om.apis, matchesQuery);
		om.models = pickBy(om.models, matchesQuery);
	}

	return generateDefinition(host, om);
}

function generateDefinition(host, objectModel) {
	return {
		swagger: '2.0',
		info: compact({
			version: objectModel.metadata.version,
			title: objectModel.metadata.name,
			description: objectModel.metadata.description,
			termsOfService: objectModel.metadata.termsOfService,
			contact: {
				name: objectModel.metadata.author
			},
			license: {
				name: objectModel.metadata.license
			}
		}),
		host: objectModel.server.host ? objectModel.server.host : (host || ('127.0.0.1' + (objectModel.server.port ? ':' + objectModel.server.port : ''))),
		basePath: objectModel.config.apiPrefix,
		schemes: createSchemes(objectModel),
		consumes: [
			'application/json',
			'application/x-www-form-urlencoded',
			'multipart/form-data'
		],
		produces: [
			'application/json',
			'application/xml',
			'text/yaml',
			'text/csv',
			'text/plain'
		],
		definitions: createDefinitions(objectModel),
		paths: createPaths(objectModel)
	};
}

function createDefinitions(objectModel) {
	var retVal = {},
		models = objectModel.models;

	for (var modelName in models) {
		if (models.hasOwnProperty(modelName)) {
			var model = models[modelName],
				safeName = modelName.replace(/\//g, '_'),
				required = [],
				properties = {};

			for (var fieldName in model.fields) {
				if (model.fields.hasOwnProperty(fieldName)) {
					var field = model.fields[fieldName];
					if (field.required) {
						required.push(fieldName);
					}
					properties[fieldName] = {};
					switch (field.type) {
						case 'number':
							properties[fieldName].type = 'integer';
							properties[fieldName].format = 'int32';
							break;
						case 'array':
							// TODO: We need more information about the array sub-type here.
							properties[fieldName].items = {type: 'string'};
							break;
						case 'string':
							properties[fieldName].type = 'string';
							break;
						case 'boolean':
							properties[fieldName].type = 'boolean';
							break;
						case 'date':
							properties[fieldName].type = 'string';
							properties[fieldName].format = 'date';
							break;
						case 'object':
							properties[fieldName].type = 'string';
							properties[fieldName].format = 'json';
							break;
						default:
							properties[fieldName].type = 'string';
							properties[fieldName].format = field.type;
							break;
					}
				}
			}

			retVal[safeName] = {
				type: 'object',
				properties: properties
			};
			if (required.length > 0) {
				retVal[safeName].required = required;
			}
		}
	}

	retVal.ResponseModel = {
		type: 'object',
		required: [
			'code',
			'success',
			'request-id'
		],
		properties: {
			code: {
				type: 'integer',
				format: 'int32'
			},
			success: {
				type: 'boolean',
				'default': false
			},
			'request-id': {
				type: 'string'
			},
			message: {
				type: 'string'
			},
			url: {
				type: 'string'
			}
		}
	};

	retVal.ErrorModel = {
		type: 'object',
		required: [
			'message',
			'code',
			'success',
			'request-id'
		],
		properties: {
			code: {
				type: 'integer',
				format: 'int32'
			},
			success: {
				type: 'boolean',
				default: false
			},
			'request-id': {
				type: 'string'
			},
			message: {
				type: 'string'
			},
			url: {
				type: 'string'
			}
		}
	};

	return retVal;
}

function createPaths(objectModel) {
	var retVal = {},
		apis = objectModel.apis;
	for (var groupName in apis) {
		if (apis.hasOwnProperty(groupName)) {
			var api = apis[groupName];
			for (var i = 0; i < api.endpoints.length; i++) {
				var endpoint = api.endpoints[i],
					relativePath = translatePath(endpoint.path.split(objectModel.config.apiPrefix).pop()),
					def = retVal[relativePath];
				if (endpoint.enabled === false) {
					continue;
				}
				if (!def) {
					retVal[relativePath] = def = {};
				}
				var pathID = endpoint.method.toLowerCase();
				def[pathID] = compact({
					description: endpoint.description,
					operationId: getOperationId(endpoint),
					deprecated: endpoint.deprecated,
					parameters: translateParameters(endpoint),
					responses: endpoint.responses || api.responses,
					tags: [groupName]
				});
				if (!def[pathID].responses) {
					def[pathID].responses = {
						default: {
							description: 'Response from Server',
							schema: {
								$ref: '#/definitions/ResponseModel'
							}
						}
					};
				}
			}
		}
	}
	return retVal;
}

function createSchemes(objectModel) {
	var retVal = ['http'],
		config = objectModel.config || {};

	if (config.ssl && (config.env === 'development' || config.sslInProduction)) {
		retVal.push('https');
	}
	return retVal;
}

function translatePath(path) {
	return path.replace(/:([^/]+)/g, '{$1}');
}

function translateParameters(endpoint) {
	var retVal = [],
		bodyParams;
	if (_.find(endpoint.parameters, {type: 'body'})) {
		bodyParams = {
			name: endpoint.nickname,
			'in': 'body',
			description: endpoint.nickname + ' body',
			schema: {
				type: 'object',
				required: [],
				properties: {}
			}
		};
	}
	for (var name in endpoint.parameters) {
		if (endpoint.parameters.hasOwnProperty(name)) {
			var param = endpoint.parameters[name];
			switch (param.type) {
				case 'body':
					if (param.required) {
						bodyParams.schema.required.push(name);
					}
					bodyParams.schema.properties[name] = transformArrowProperty(param);
					break;
				default:
					if (param.type === 'form') {
						// We can't define both body and form params; there can be only one body per endpoint.
						if (bodyParams) {
							if (param.required) {
								bodyParams.schema.required.push(name);
							}
							bodyParams.schema.properties[name] = transformArrowProperty(param);
							break;
						}
					}
					// Force form parameters to be required (as required by the Swagger spec).
					if (param.type === 'path') {
						param.required = true;
					}
					var translated = {
						name: name,
						'in': param.type,
						description: param.description,
						required: !!param.required,
						type: param.dataType || 'string'
					};
					// TODO: We need more information about the sub-types of objects and arrays.
					if (param.dataType === 'object') {
						translated.type = 'string';
					}
					if (param.dataType === 'array') {
						translated.items = {type: 'object'};
					}
					retVal.push(compact(translated));
					break;
			}
		}
	}
	if (bodyParams) {
		if (bodyParams.schema.required.length === 0) {
			delete bodyParams.schema.required;
		}
		retVal.push(bodyParams);
	}
	return retVal;
}

function transformArrowProperty(arrowProperty) {
	var dataType = arrowProperty.dataType || 'string';
	var swaggerProperty = {
		type: dataType,
		description: arrowProperty.description
	};
	switch (dataType) {
		case 'date':
			swaggerProperty.type = 'string';
			swaggerProperty.format = 'date';
			break;
		case 'array': {
			swaggerProperty.items = {type: 'string'};
			break;
		}
	}

	return swaggerProperty;
}

function getOperationId(endpoint) {
	var retVal = verbMap[endpoint.method] || endpoint.method.toLowerCase(),
		splits = endpoint.path.replace(/appc\./, '')
			.replace(/_[a-z]/ig, function (val) {
				return val[1].toUpperCase();
			})
			.slice(1).split('/');
	for (var i = 1; i < splits.length; i++) {
		var split = splits[i];
		if (split[0] === ':') {
			retVal += 'By' + split.slice(1).toUpperCase();
		} else if (split[0] !== undefined) {
			retVal += split[0].toUpperCase() + split.slice(1);
		}
	}
	return retVal;
}

function compact(obj) {
	return omitBy(obj, function (val, key) {
		if (_.isArray(val)) {
			return val.length === 0;
		}
		if (_.isObject(val)) {
			obj[key] = compact(val);
			if (_.keys(obj[key]).length === 0) {
				return false;
			}
		}

		return !val;
	});
}

/**
 * Emulates the behaviour of _.omitBy until we can upgrade to lodash 4
 *
 * @see https://lodash.com/docs/4.16.4#omitBy
 * @param {Object} obj The source object
 * @param {Function} predicate The predicate function invoked per property
 * @return {Object} Returns the new object
 */
function omitBy(obj, predicate) {
	return pickBy(obj, _.negate(_.iteratee(predicate)));
}

/**
 * Emulates the behaviour of _.pickBy until we can upgrade to lodash 4
 *
 * @see https://lodash.com/docs/4.16.4#pickBy
 * @param {Object} obj The source object
 * @param {Function} predicate The predicate function invoked per property
 * @return {Object} Returns the new object
 */
function pickBy(obj, predicate) {
	var index = -1;
	var props = _.keysIn(obj);
	var length = props.length;
	var result = {};

	while (++index < length) {
		var key = props[index];
		var value = obj[key];

		if (predicate(value, key)) {
			result[key] = value;
		}
	}
	return result;
}
