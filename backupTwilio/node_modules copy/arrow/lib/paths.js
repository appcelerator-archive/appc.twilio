/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var path = require('path'),
	fs = require('fs'),
	arrow = require('./arrow'),
	requireNew = require('require-new'),
	Module = require('module');

/**
 * special monkey patch requiring of arrow components to make sure that these
 * components can require('arrow') without actually having to have the real module local
 */
function requireComponent(name, reload) {
	var previousWrapper = Module.wrapper[0],
		parentFolder = path.resolve(__dirname, '..', '..'),
		isInAppC = path.basename(parentFolder) === 'package',
		requireDir = isInAppC ? parentFolder : process.cwd();

	// inject our special require() handler that modifies the module search paths
	// and then invokes the original require()
	// NOTE: the wrapper MUST be on a single line
	Module.wrapper[0] = previousWrapper + ';' +
		'(function (_require, p) {' +
		'require = function (name) {' +
		'if (name==="arrow" || name==="arrow"){return global.__arrow;}' +
		'module.paths && module.paths.indexOf(p) === -1 && module.paths.unshift(p);' +
		'return _require(name);' +
		'};' +
		'}(require, "' + path.resolve(requireDir).replace(/"/g, '\"') + '"));';

	try {
		global.__arrow = arrow;
		// now let require do it's work depending on if we are forcing a reload or not
		var retVal = reload ? requireNew(name) : require(name);
		retVal.filename = retVal.filename || name;
		return retVal;
	} finally {
		// undo monkey patch
		Module.wrapper[0] = previousWrapper;
		delete global.__arrow;
	}
}

/**
 * find a component path based on node_modules folder.
 */
function findComponent(type, name) {
	var p,
		dirs = [],
		mdirs = [
			// start with the local directory such as 'connectors'
			path.join(process.cwd(), type + 's'),
			// then look in local node_modules
			path.join(process.cwd(), 'node_modules', type + 's'),
			// then look in local node_modules as a standalone
			path.join(process.cwd(), 'node_modules')
			// then concat the remaining modules paths
		].concat(module.paths);
	for (var c = 0; c < mdirs.length; c++) {
		var mp = mdirs[c],
			tp = path.join(mp, name);
		if (fs.existsSync(tp)) {
			var pkg = path.join(tp, 'appc.json');
			if (fs.existsSync(pkg)) {
				p = require(pkg);
				if (/^(connector|block|model|api)$/.test(p.type)) {
					return requireComponent(tp);
				}
			}
		}
	}
	// see if this is a connector project and we're trying to load itself
	var pf = path.join(process.cwd(), 'appc.json');
	if (fs.existsSync(pf)) {
		p = require(pf);
		if (/^(connector|block|model|api)$/.test(p.type)) {
			var index = path.join(process.cwd(), 'lib', 'index.js');
			if (fs.existsSync(index)) {
				return requireComponent(index);
			}
		}
	}
}

exports.findComponent = findComponent;
exports.requireComponent = requireComponent;
