/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var fs = require('fs'),
	path = require('path'),
	_ = require('lodash'),
	util = require('./util'),
	highlight = require('highlight.js'),
	Logger = require('appc-logger'),
	moment = require('moment');

// jscs:disable jsDoc

function Timeline(arrow) {
	this.logs = {};
	this.metadata = {};
	this.results = {};
	this.errors = {};
	this.args = {};
	this.arrow = arrow;
}

function formatRemote(addr) {
	return addr && addr.replace(/^::ffff:/, '');
}

Timeline.prototype.process = function (obj) {
	try {
		if (obj.type) {
			return this.add(obj);
		} else if (obj.start) {
			obj.type = 'request';
			obj.method = obj.req.method;
			obj.headers = obj.req.headers;
			this.started = new Date(obj.time).getTime();
			this.req_id = obj.req_id;
			this.url = obj.req && obj.req.url;
			this.remote = formatRemote(obj.req && obj.req.remoteAddress && obj.req.remoteAddress) + ':' + obj.req.remotePort;
			return this.add(obj);
		} else if (obj.ignore) {
			// skip, this is not used right now
		} else {
			console.log('not sure how to handle', obj);
		}
	}
	catch (E) {
		console.error(E.stack);
	}
};

Timeline.prototype.finish = function () {
	if (this.request) {
		this.request.logs = this.logs.request;
	}
	if (this.response) {
		this.response.logs = this.logs.response;
	}

	delete this.logs;
	delete this.metadata;
	delete this.arrow;
	delete this.args;
	delete this.results;
	delete this.errors;

	return this;
};

Timeline.prototype.getModel = function (timeline) {
	var tok = timeline.name.split(':');
	timeline.name = tok[1];
	timeline.method = timeline.subname || timeline.name;
	delete timeline.subname;
	return this.arrow.getModel(timeline.name);
};

Timeline.prototype.getConnector = function (timeline) {
	var tok = timeline.name.split(':');
	timeline.name = tok[1];
	timeline.method = timeline.subname;
	delete timeline.subname;
	var connector = this.arrow.getConnector(timeline.name);
	var version = connector.version || (connector.pkginfo && connector.pkginfo.version) || '0.0.0';
	timeline.name = 'connector/' + timeline.name + (version ? ('@' + version) : '');
	return connector;
};

Timeline.prototype.getBlock = function (timeline) {
	timeline.name = timeline.subname || timeline.name;
	delete timeline.subname;
	return this.arrow.getBlock(timeline.name);
};

Timeline.prototype.getAPI = function (timeline) {
	timeline.name = timeline.subname || timeline.name;
	delete timeline.subname;
	var key = 'action:api:' + timeline.name;
	var metadata = this.metadata && this.metadata[key] || {method: 'GET'};
	return this.arrow.getAPI(metadata.path || timeline.name, metadata.method);
};

function formatArgs(args) {
	if (args && Array.isArray(args)) {
		// the way bunyan stores the array, it adds a null entry at the end, so we remove that
		return util.formatBody(JSON.stringify(args.slice(0, args.length - 1), null, 2), 'json');
	} else if (args && _.isObject(args)) {
		return util.formatBody(JSON.stringify(args, null, 2), 'json');
	}
	return '';
}

Timeline.prototype.processComponent = function (timeline, component, logs, metadata, args, result, error) {
	if (component) {
		timeline.description = component.description || (component.pkginfo && component.pkginfo.description);
		timeline.filename = component.filename;
		timeline.detail = {};
		timeline.detail.args = formatArgs(args);
		timeline.detail.result = util.formatBody(JSON.stringify(result, null, 2), 'json');
		if (error) {
			timeline.detail.error = error;
		}
		if (logs) {
			timeline.detail.logs = logs;
		}
		// attempt to full in filename
		if (component.filename && fs.existsSync(component.filename)) {
			// if a directory, don't load it
			if (fs.statSync(component.filename).isDirectory()) {
				if (component.pkginfo) {
					timeline.filename = null; // set to null to pull in pkginfo
				} else {
					var pkg = path.join(component.filename, 'package.json');
					if (fs.existsSync(pkg)) {
						timeline.filename = pkg;
					} else {
						timeline.filename = null; // can't pull in directory so set to null
					}
				}
			}
		}
		if (metadata && !timeline.filename) {
			timeline.detail.config = util.formatBody(JSON.stringify(metadata, null, 2), 'json');
			if (metadata.model) {
				timeline.description = 'Generated API for ' + metadata.model;
			}
		}
		// generate source for non-generated model/api/blocks that developer has written
		if (/(model|api|block)/.test(timeline.type) && !component.generated) {
			if (timeline.filename) {
				timeline.detail.source = util.formatBody(fs.readFileSync(timeline.filename).toString(), 'javascript');
			} else if (_.isObject(component)) {
				try {
					timeline.detail.source = util.formatBody(JSON.stringify(_.omit(component, function (value, key, object) {
						return _.isFunction(value) || key[0] === '_';
					}), decircularize(), 4), 'javascript');
				}
				catch (err) {
					console.error(err);
				}
			}
		}
	} else {
		this.arrow.logger.error('Couldn\'t find timeline component for', timeline);
	}
};

function decircularize() {
	var seen = [];

	return function (key, value) {
		// Translate model types.
		if (value instanceof Buffer) {
			return '[ Buffer ]';
		}
		if (key === 'type' && value && _.isFunction(value)) {
			return value.name;
		}
		if (key === 'connector') {
			if (value && value.pkginfo) {
				return value.pkginfo.name + '@' + value.pkginfo.version;
			}
			return value;
		}
		if (key === 'logger') {
			return '[ Logger ]';
		}
		// If we have a circular reference, replace its value with a string representation.
		if (value && _.isObject(value)) {
			if (seen.indexOf(value) >= 0) {
				return '[ Circular Reference ]';
			}
			seen.push(value);
		}
		return value;
	};
}

Timeline.prototype.add = function (obj) {
	switch (obj.type) {
		case 'request':
			this.request = _.merge({}, _.pick(obj, 'method', 'time'));
			this.request.type = 'server';
			this.request.name = 'HTTP Request';
			this.request.started = new Date(this.request.time).getTime();
			delete this.request.time;
			this.request.detail = {
				body: util.formatBody(obj.body || '<no content>'),
				headers: util.formatBody(util.generateHeaders(obj.headers), 'http')
			};
			this.request.description = moment(obj.time).fromNow() + ' (' + obj.time + ')';
			// console.log('this.request->',JSON.stringify(this.request,null,2));
			break;
		case 'response':
			this.response = _.merge({}, _.pick(obj, 'status', 'time'));
			this.response.type = 'server';
			this.response.name = 'HTTP Response';
			this.response.started = new Date(this.response.time).getTime();
			delete this.response.time;
			this.response.statusMessage = util.statusMessage(this.response.status);
			this.response.detail = {
				body: util.formatBody(obj.body || '<no content>'),
				headers: util.formatBody(util.generateHeaders(obj.headers), 'http')
			};
			break;
		case 'transaction':
			// if this is a log message, record it by the type
			if (!obj.ignore && obj.msg) {
				var key = obj.tx_name;
				if (!key) {
					// if we are getting logs before or after transactions
					// we can assume that these are part of the incoming request before
					// the transaction or after the transactions in the response handler
					if (this.request) {
						key = 'request';
					} else {
						key = 'response';
					}
				}
				var array = this.logs[key];
				if (!array) {
					this.logs[key] = array = [];
				}
				//TODO: do better highlighting here
				array.push(util.formatBody(util.formatLogMessage(obj)));
			} else if (obj.ignore && obj.tx_metadata) {
				// set our metadata
				this.metadata[obj.tx_name] = obj.tx_metadata;
			}
			if (obj._result) {
				this.results[obj.tx_name] = obj._result;
			}
			if (obj._error) {
				this.errors[obj.tx_name] = obj._error;
			}
			if (obj._args) {
				this.args[obj.tx_name] = obj._args;
			}
			break;
		case 'timeline':
			try {
				this.timeline = _.pick(obj, 'timeline', 'time', 'totalDuration', 'apiDuration', 'beginServerDuration', 'endServerDuration');
				this.timeline.started = new Date(this.timeline.time).getTime();
				delete this.timeline.time;
				// now associate our logs we found with the right transaction
				this.timeline.timeline.forEach(function (timeline) {
					if (!timeline) { return; }
					var logs = this.logs[timeline.name],
						metadata = this.metadata[timeline.name];

					var args = this.args[timeline.name];
					var error = this.errors[timeline.name];
					var result = this.results[timeline.name];

					try {
						switch (timeline.type) {
							case 'connector':
								var Connector = this.getConnector(timeline);
								this.processComponent(timeline, Connector, logs, metadata, args, result, error);
								break;
							case 'model':
								var Model = this.getModel(timeline);
								this.processComponent(timeline, Model, logs, metadata, args, result, error);
								break;
							case 'block':
								var Block = this.getBlock(timeline);
								this.processComponent(timeline, Block, logs, metadata, args, result, error);
								break;
							case 'action':
								var API = this.getAPI(timeline);
								// internally its an action, but we want to display it as an API in the UI
								timeline.type = 'api';
								this.processComponent(timeline, API, logs, metadata, args, result, error);
								break;
						}
					}
					catch (E) {
						console.log('ERROR', E);
						console.error(E.stack);
					}
				}.bind(this));
			}
			catch (E) {
				console.log('ERROR', E);
				console.error(E.stack);
			}
			break;
	}
};

function configure(app, prefix, arrow, devmode) {
	app.get(prefix + '/metadata/timeline/:id', function serveTimelineAPI(req, res, next) {
		if (arrow.config.env !== 'development') {
			util.unauthorized(res);
			return next(false);
		}
		//FIXME: switch to using .metadata file instead of reading requests.log
		var timeline = new Timeline(arrow),
			logdir = Logger.arrowCloudLogDir || path.join(arrow.config.dir || process.cwd(), 'logs'),
			reqlog = path.join(logdir, 'requests.log'),
			id = util.getSafeReqId(req),
			defReqObj = {};
		util.readLogFile(reqlog, function findIt(obj) {
				if (obj.req_id === id) {
					defReqObj = obj;
					return true;
				}
			},
			function () {
				try {
					util.readLogFile(util.getRequestLogPath(logdir, req), timeline.process.bind(timeline), function (err) {
						if (err) { return next(err); }
						try {
							var result = timeline.finish();
							return res.json(_.defaults(result, defReqObj));
						}
						catch (E) {
							console.error('ERROR', E.stack);
							next(E);
						}
					});
				}
				catch (E) {
					console.error('ERROR', E.stack);
					next(E);
				}
			});
	});
}

exports.configure = configure;
