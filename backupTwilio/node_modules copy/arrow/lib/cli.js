/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var chalk = require('chalk'),
	_ = require('lodash'),
	under = chalk.underline,
	pkg = require('../package.json'),
	commands = require('./command'),
	Logger = require('appc-logger'),
	logger = Logger.createLogger({prefix: false}),
	pluralize = require('pluralize'),
	programAdded,
	program;

// jscs:disable jsDoc

exports = module.exports = CLI;

/**
 * log a fatal message and exit
 */
function fail(msg) {
	logger.fatal(msg);
	process.exit(1);
}

/**
 * return plural version of term
 */
function plural(count, term) {
	return pluralize(term, count);
}

/**
 * right pad a string a certain fixed length
 */
function rpad(str, length) {
	var r = str,
		l = Logger.stripColors(str).length;
	for (var c = l; c < length; c++) {
		r += ' ';
	}
	return r;
}

function CLI(prog, inq) {
	program = prog;
	this.fail = fail;
	this.commands = commands;
	this.chalk = chalk;
	this.logger = logger;
	this.pkg = pkg;
	this.program = program;
	this.rpad = rpad;
	this.plural = plural;
	this.inquirer = inq;

	// setup commands
	Object.keys(commands).forEach(function (name) {
		var Command = commands[name];
		if (typeof(Command) === 'function') {
			var command = new Command(this);
			commands[command.name] = command;
			delete commands[name];
		}
	}.bind(this));

	if (!programAdded) {
		programAdded = true;
		program.description(pkg.description)
			.version(pkg.version)
			.option('-a, --author <author>', 'author of the component')
			.option('--no-confirm', 'don\'t confirm generation, just do it')
			.option('-d, --dir <directory>', 'Directory')
			.option('-D, --description <description>', 'description of component')
			.option('-f, --force', 'Force overwrite files on generate')
			.option('-y, --no-confirm', 'Don\'t prompt for confirm')
			.option('-n, --name <name>', 'Name of component')
			.option('-j, --json', 'JSON output')
			.option('--config <config>', 'config')
			.option('-s, --save', 'Save results (used in install)')
			.option('-l, --level <level>', 'Set the log level, defaults to info')
			.option('--org-id <org_id>', 'Use a specific org_id when logging in')
			.usage('[options] [' + under('command') + ' [' + under('args') + ']]');

		program.on('--help', function () {
			console.log('  Commands:');
			console.log('');
			Object.keys(commands).forEach(function (name) {
				var command = commands[name];
				if (!command.hidden) {
					console.log('    ' + chalk.yellow(rpad(command.name, 22)) + ' ' + command.description);
				}
			});
			console.log('');
			console.log('  Examples:');
			console.log('');
			console.log('    ' + under('create a connector project'));
			console.log('    $ ' + chalk.cyan('api') + ' new connector');
			console.log('');
		});
	}
}

// setup as Class level properties so that it can be used outside of CLI as node module
_.merge(CLI, {
	fail: fail,
	commands: commands,
	chalk: chalk,
	logger: logger,
	pkg: pkg,
	program: program,
	rpad: rpad
});

/**
 * run the command line program
 */
CLI.prototype.run = function () {

	program.parse(process.argv);

	if (program.args.length === 0) {
		return program.help();
	}

	// set the logger level
	if (program.level) {
		logger.level(program.level);
	} else {
		logger.level('info');
	}

	// setup the default to save which is used by test cases when we don't want to save
	program.save = true;

	this.config = program.opts();

	// wrapper callback when we're completed
	var callback = function (err) {
		err && logger.fatal(err);
		process.exit(0);
	}.bind(this);

	this.runCommand(program.args[0], program.args.splice(1), callback);
};

/**
 * run a specific command
 */
CLI.prototype.runCommand = function (name, args, callback) {

	var command = commands[name];

	// push callback to front
	args.unshift(callback || function () {});
	if (callback) {
		// re-write so that we send back error
		this.fail = function (msg) {
			callback(msg);
		};
	}
	if (!command) {
		if (name === 'help') {
			program.help();
			return callback();
		}
		this.fail('Unsupported command: ' + name);
	}
	program.parse(args);
	command.run.apply(command, args);
};

CLI.appNameRegExp = CLI.prototype.appNameRegExp = /^[\w]{2,}[\w\.\d-_]+$/;
CLI.nameRegExp = CLI.prototype.nameRegExp = /^[\w]{2,}\.[\w\.\d-_]+$/;
CLI.componentNameRegExp = CLI.prototype.componentNameRegExp = /^(connector|model|api|block)\/([\w]{2,}\.[\w\.\d-_]+)(@\d\.\d\.\d)?$/;

CLI.splitComponentName = CLI.prototype.splitComponentName = function (value) {
	var tokens = this.componentNameRegExp.exec(value);
	if (tokens && tokens.length) {
		return {
			type: tokens[1],
			name: tokens[2],
			version: tokens[3] && tokens[3].substring(1) || '*',
			component: tokens[1] + '/' + tokens[2]
		};
	}
	throw new Error('Invalid Component Name. Must be in the format: /' + this.componentNameRegExp.source + '/');
};
