/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var fs = require('fs'),
	path = require('path'),
	exec = require('child_process').exec,
	Logger = require('appc-logger'),
	_ = require('lodash'),
	logger = Logger.createDefaultLogger({
		level: process.env.APPC_LOG_LEVEL || 'info',
		showcr: false
	}),
	cachedGitHash;

// jscs:disable jsDoc

/**
 * Loads up the configuration files in to the global $config object.
 */
var Loader = function Loader(dirname, env, defaultConfig) {
	dirname = dirname && fs.existsSync(dirname) && path.basename(dirname) === 'conf' ? dirname : path.join(dirname || process.cwd(), 'conf');
	env = (env || getDefaultEnv()).toLowerCase();

	var config = {env: env, dir: path.dirname(dirname)};
	if (defaultConfig && _.isObject(defaultConfig)) {
		config = _.merge(defaultConfig, config);
	}

	if (cachedGitHash) {
		config.git_hash = cachedGitHash;
	} else {
		getGitHash(function (err, hash) {
			hash && (config.git_hash = hash);
		});
	}

	var
	// all other config files
		configFiles = [],
		envTypes = ['default', 'local', 'dev', 'development', 'preprod', 'preproduction', 'preprodonprod', 'test', 'prod', 'production', 'prod-eu', 'production-eu', 'platform-axway'],
	// map different acceptable configurations by env, in the order they should be loaded
		envMap = {
			local: ['default', 'local', 'dev', 'development'],
			development: ['default', 'local', 'dev', 'development'],
			preproduction: ['default', 'test', 'prod', 'production', 'preprod', 'preproduction'],
			preprodonprod: ['default', 'preprodonprod'],
			test: ['default', 'dev', 'development', 'preprod', 'preproduction', 'test', 'prod', 'production'],
			production: ['default', 'prod', 'production'],
			'production-eu': ['default', 'prod-eu', 'production-eu'],
			'platform-axway': ['default', 'platform-axway']
		},
		vpcEnv = process.env.APPC_SESSION_ENV && JSON.parse(process.env.APPC_SESSION_ENV),
		vpcEnvName = vpcEnv && vpcEnv.name && vpcEnv.name.toLowerCase();

	// set up aliases
	envMap.preprod = envMap.preproduction;
	envMap.prod = envMap.production;
	envMap.dev = envMap.development;

	if (vpcEnvName && envTypes.indexOf(vpcEnvName) === -1) {
		envTypes.push(vpcEnvName);
		envMap[env].push(vpcEnvName);
	}

	var envTypeRegex = new RegExp('^(.*)\\.(' + envTypes.join('|') + ')\\.js$'),
		envSimpleTypeRegex = new RegExp('^(' + envTypes.join('|') + ')\\.js$');

	// if not in our env map, raise an exception
	if (!(env in envMap)) {
		throw new Error('unknown environment "' + env + '" specified. must be one of: ' + Object.keys(envMap).join(', '));
	}

	// load all the other config files found
	fs.existsSync(dirname) && fs.readdirSync(dirname)
		.filter(function (n) {
			// Only JavaScript files.
			if (!/\.js$/.test(n)) {
				return false;
			}
			// Exclude anything with "example." in the name.
			if (n.indexOf('example.') >= 0) {
				logger.trace('skipping ' + n + ' because it is an example');
				return false;
			}
			// Alright, let's load it!
			return true;
		})
		.forEach(function (fn) {
			if (envSimpleTypeRegex.test(fn)) {
				if (envMap[env].indexOf(fn.slice(0, -3)) === -1) {
					logger.trace('skipping ' + fn + ' because it is excluded by our env ' + env);
					return;
				}
			} else if (envTypeRegex.test(fn)) {
				var match = envTypeRegex.exec(fn),
					testEnv = match[2];
				// if it matches, allow load, else skip
				if (envMap[env].indexOf(testEnv) === -1) {
					logger.trace('skipping ' + fn + ' because it is excluded by our env ' + env);
					return;
				}
			}
			var file = path.join(dirname, fn);
			configFiles.push(file);
		});

	var configsMap = {'first': []},
		sortRegexp = new RegExp('\\.(' + envTypes.join('|') + ')\\.js$'),
		sortSimpleRegexp = new RegExp('^(' + envTypes.join('|') + ')\\.js$');

	// group the various files found in the right order
	configFiles.forEach(function (fn) {
		var name = path.basename(fn),
			match = sortRegexp.exec(name) || sortSimpleRegexp.exec(name);
		if (match) {
			var envName = match[1];
			if (!(envName in configsMap)) {
				configsMap[envName] = [fn];
			} else {
				configsMap[envName].push(fn);
				configsMap[envName].sort();
			}
		} else if (!/\.VPC\./.test(fn)) {
			// non-env based files are always loaded first in sorted order
			configsMap.first.push(fn);
			configsMap.first.sort();
		}
	});

	// now order the files based on the acceptable envs order in precedence order
	var orderedConfigs = [];
	envMap[env].forEach(function (k) {
		var arr = configsMap[k];
		arr && (orderedConfigs = orderedConfigs.concat(arr));
	});

	// add the first ones first
	orderedConfigs = configsMap.first.concat(orderedConfigs);

	// allow adding a specific config file, which will have the highest precedence, from the command line:
	var configFileIndex = process.argv.indexOf('--config-file');
	if (configFileIndex >= 0 && process.argv.length >= configFileIndex + 1) {
		orderedConfigs.push(path.resolve(process.argv[configFileIndex + 1]));
	}

	logger.trace('configuration loaded in this order\n', orderedConfigs);

	// now merge them in the right order
	orderedConfigs.forEach(function (file) {
		mix(config, require(file));
	});

	// do any environment overrides
	var configKeysMap = {};
	Object.keys(config).forEach(function (k) {
		configKeysMap[k.toLowerCase()] = k;
	});
	Object.keys(process.env).forEach(function (k) {
		if (k.indexOf('ARROW_') === 0) {
			var varName = k.substring(6).toLowerCase();
			if (configKeysMap[varName]) {
				// found a key in the environment, override it
				var name = configKeysMap[varName],
					value = process.env[k];
				logger.trace('environment variable', k, 'overrides config', name, ' with value =', value);
				config[name] = value;
			} else {
				logger.trace('environment variable', k, 'set in config', varName, ' with value =', process.env[k]);
				config[varName] = process.env[k];
			}
		}
	});

	logger.trace('using configuration\n', config);
	return config;
};

function mix(dest, src) {
	Object.keys(src).forEach(function (p) {
		if (dest.hasOwnProperty(p) && Object.prototype.toString.call(dest[p]) === '[object Object]') {
			mix(dest[p], src[p]);
		} else {
			dest[p] = src[p];
		}
	});
}

/**
 * determine the git hash for this project
 */
function getGitHash(callback) {
	var git = path.join(process.cwd(), '.git');
	if (!fs.existsSync(git)) {
		return callback();
	}
	exec('git rev-parse --short HEAD', function (error, stdout, stderr) {
		stdout && (cachedGitHash = stdout.trim());
		return callback(error, cachedGitHash);
	});
}

function isRunningInPreproduction() {
	return process.env.NODE_ACS_URL &&
		process.env.NODE_ACS_URL.indexOf('.appctest.com') > 0 ||
		process.env.NODE_ENV === 'preproduction' ||
		process.env.APPC_ENV === 'preproduction' ||
		process.env.NODE_ENV === 'development' ||
		process.env.APPC_ENV === 'development';
}

/**
 * determine the default env
 */
function getDefaultEnv() {
	// always use if specified
	if (process.env.NODE_ENV && process.env.NODE_ENV !== 'undefined') {
		return process.env.NODE_ENV;
	}
	// this means we're running in the node.acs production environment
	if (process.env.serverId && process.env.appid) {
		// check to see if this is pre-production cloud
		if (isRunningInPreproduction()) {
			return 'preproduction';
		}
		if (process.env.APPC_ENV === 'preprodonprod') {
			return 'preprodonprod';
		}
		return 'production';
	}
	// defaults to development if running locally
	return 'development';
}

module.exports = Loader;
Loader.getGitHash = getGitHash;
