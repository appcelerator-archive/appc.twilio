/*
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */

// jscs:disable
/**
 * @class Arrow
 */
	// jscs:enable
exports = module.exports = Arrow;
var consoleLog = console.error.bind(console);
var AppC = require('arrow-admin').AppC;
var inProduction;
var pendingRequests = 0;
var lastGCCheck = Date.now();
var stopping = false;

// jscs:disable jsDoc

if (process.env.serverId && process.env.appid) {
	inProduction = true;
}

// set correct defaults for runtime in production
// must do this before loading the Loader below which loads config files
if (inProduction) {
	// if neither are set, use smart defaults
	if (!process.env.NODE_ENV && !process.env.APPC_ENV) {
		process.env.NODE_ENV = process.env.APPC_ENV = AppC.isProduction ? 'production' : 'preproduction';
	} /* APPC_ENV takes precendence*/ else if (process.env.APPC_ENV) {
		process.env.NODE_ENV = process.env.APPC_ENV;
	} else {
		process.env.APPC_ENV = process.env.NODE_ENV;
	}
}

// set the name of the node process
process.title = 'arrow' + (process.env.APPC_WORKER_PID ? (' (node worker #' + process.env.APPC_WORKER_ID + ')') : '');

var express = require('express'),
	_ = require('lodash'),
	events = require('events'),
	fs = require('fs'),
	path = require('path'),
	util = require('util'),
	crypto = require('crypto'),
	async = require('async'),
	wrench = require('wrench'),
	cluster = require('cluster'),
	debug = require('debug')('arrow'),
	pkg = require('../package.json'),
	Metadata = require('./metadata'),
	Logger = require('appc-logger'),
	memwatch,
	Loader = require('./loader'),
	Response = require('./response'),
	RequestTx = require('./request_tx'),
	Middleware = require('./middleware'),
	Block = require('./block'),
	Router = require('./router'),
	CLI = require('./cli'),
	API = require('./api'),
	orm = require('arrow-orm'),
	uuid = require('uuid-v4'),
	paths = require('./paths'),
	pluralize = require('pluralize'),
	chalk = require('chalk'),
	Authentication = require('./authentication'),
	LogManager = require('./logmanager'),
	bindSwaggerRoutes = require('./swagger').bindRoutes,
	pluginUtil = require('./plugin/util'),
	Connector = orm.Connector,
	Model = orm.Model,
	Collection = orm.Collection,
	Instance = orm.Instance,
	connectors = {},
	globalArrow,
	inGetConnector,
	pendingModels,
	loadedModelDirs = [],
	instantiations = [],
	servers = [];

try {
	memwatch = require('appc-memwatch');
}
catch (err) {
	// appc-memwatch isn't installed. Carry on anyway.
}

util.inherits(Arrow, events.EventEmitter);

// allow people to reference the built-in debug module
Arrow.debug = debug;

// merge in orm into our Arrow
for (var key in orm) {
	if (orm.hasOwnProperty(key)) {
		Arrow[key] = orm[key];
		orm[key].Arrow = Arrow;
	}
}

Arrow.API = API;
Arrow.Block = Block;
Arrow.CLI = CLI;
Arrow.Formation = require('./formatters');
Arrow.Loader = Loader;
Arrow.Logger = Logger;
Arrow.Metadata = Metadata;
Arrow.Middleware = Middleware;
Arrow.ORM = orm;
Arrow.Router = Router;
Arrow.Version = pkg.version;

function Arrow(config, loadOnly) {
	if (instantiations !== undefined) {
		instantiations.push(this);
	}
	this.config = new Loader(config && config.dir, null, config);
	this.port = process.env.PORT;
	if (!inProduction && this.port === undefined) {
		this.port = this.config.port;
		if (this.port === undefined) {
			this.port = 8080;
		}
	}
	if (!this.config.admin) {
		this.config.admin = {};
	}
	this.config.admin.prefix = this.config.admin.prefix || '/arrow';
	this.config.apiPrefix = this.config.apiPrefix || '/api';
	this.loadOnly = loadOnly;
	this.inProduction = !!inProduction;
	this.ignoreDuplicateModels = !!this.config.ignoreDuplicateModels;

	if (!globalArrow) {
		globalArrow = this;
		// since the continuation listeners potentially has a ton of listeners on startup
		globalArrow.setMaxListeners(Number.MAX_VALUE);
	}

	if (process.env.APPC_LOG_LEVEL) {
		// change the internal config to use the environment
		this.config.logLevel = process.env.APPC_LOG_LEVEL;
	}
	if (config && config.overrideLevel) {
		this.config.logLevel = config.overrideLevel;
	}

	// configure the default apikey based on env
	if (!this.config.apikey_preproduction) {
		this.config.apikey_preproduction = this.config.apikey_production || this.config.apikey_development || this.config.apikey;
	}
	if (!this.config.apikey) {
		var key = 'apikey_' + this.config.env;
		this.config.apikey = this.config[key];
	} else {
		// set the api key to the same if we only use one
		this.config.apikey_production = this.config.apikey_preproduction = this.config.apikey_development = this.config.apikey;
	}

	// this is the default path (inside if). we use this
	// as a way to be able to load up arrow but without
	// creating the server infrastructure. this is useful for
	// being able to programatically load models, connectors, etc
	if (!loadOnly) {

		var self = this;
		this.express = express;
		var server = this.app = express();
		this.logger = createServerLogger(this, server);

		var healthCheckAPI = this.config.healthCheckAPI;
		if (healthCheckAPI) {
			try {
				healthCheckAPI = require(path.resolve(process.cwd(), healthCheckAPI));
			}
			catch (E) {
				this.logger.trace(E.stack);
				this.logger.error('error loading health check plugin', healthCheckAPI, E);
			}
		}

		// handle any arrow cloud health checks -- allow the user to specify their own
		// plugin or we'll provide a basic one that simply returns success if we are reachable
		// and not in shutdown phase
		server.get('/arrowPing.json', healthCheckAPI || function (req, resp, next) {
				return resp.json({success: !self.shuttingdown});
			});

		// add graceful shutdown middleware which will send 503 responses to
		// any incoming connection requests while we're in shutdown mode. any
		// front end load balancer (like arrow cloud) should correctly
		server.use(function (req, resp, next) {
			if (self.shuttingdown) {
				resp.shouldKeepAlive = false;
				resp.set('Connection', 'close');
				resp.set('Cache-Control', 'no-cache, no-store, max-age=0');
				resp.set('Pragma', 'no-cache');
				resp.status(503);
				resp.end('Server is shutting down');
			} else {
				next();
			}
		});

		if (this.inProduction) {
			this.app.enable('trust proxy');
		}

		// add the request-id helper
		express.request.getId = function () {
			if (!this._reqid) {
				this._reqid = uuid();
			}
			return this._reqid;
		};

		var baseurl = this.config.baseurl || process.env.ARROWCLOUD_APP_URL || process.env.ARROW_PUBLIC_URL || process.env.NODE_ACS_URL;
		if (this.config.env === 'development' && !this.inProduction) {
			baseurl = 'http://localhost:' + this.port;
		}

		if (baseurl === undefined && this.config.env === 'production-eu') {
			baseurl = 'http://localhost:' + this.port;
		}

		addLocals(this, this.app, baseurl);

		// bind a logger to the server itself
		server.logger = this.logger;

		var appPkg = path.join(config && config.dir || process.cwd(), 'package.json');
		if (fs.existsSync(appPkg)) {
			appPkg = require(appPkg);
			this.logger.info(chalk.blue.bold('Arrow/' + pkg.version) + ' ' + chalk.yellow(appPkg.name + '/' + appPkg.version));
		} else {
			appPkg = {};
			// fallback if we can't find package.json for app
			this.logger.info(chalk.blue.bold('Arrow/' + pkg.version));
		}
		this.productionNodeVersion = appPkg.engines && appPkg.engines.node;

		if (this.config.apikey) {
			this.logger.info('APIKey is:', chalk.gray(this.config.apikey));
		}

		// if we have a pubsub configuration, enable it for events
		if (this.config.pubsub) {
			this.definePubSub(appPkg);
		}

		var sessionConfig = this.config && this.config.session || {};

		server.use(function (req, resp, next) {
			req.pendingReqCount = ++pendingRequests;
			req.server = self;
			if (!self.config.disableServerBanner) {
				resp.set('Server', 'Appcelerator Arrow/' + pkg.version);
			}
			resp.set('Request-Id', req.getId());
			resp.locals['request-id'] = req.getId();
			req.logger = resp.logger = req.log = req.log || self.logger;
			next();
		});

		// this should always be at the top before anything else but after setting up the logger
		server.use(createRequestTransaction(this.config));

		// create the generic express middleware
		this.middleware = new Middleware(server, this.config.dir, sessionConfig, this.config);

		server.on('after', endRequestTransaction.bind(server));

		// add CORs headers
		server.use(function (req, resp, next) {
			if (req.method === 'OPTIONS') {
				var apis = API.getAPIsForPath(req.path);
				if (apis) {
					var options = _.unique(apis.map(function (api) {
						return api.method.toUpperCase();
					})).join(',');
					var checkMethod = req.headers['access-control-request-method'];
					if (checkMethod && options.indexOf(checkMethod.toUpperCase()) < 0) {
						// to deny, just send 200 without CORS headers
						return resp.status(200).end();
					}
					resp.setHeader('Allow', options);
					addCORsHeaders(self.config, req, resp);
					return resp.status(200).end();
				} else if (req.path === self.config.admin.prefix + '/testapi' || req.path === self.config.admin.prefix + '/metadata/logs') {
					// CORS should be enabled for our testapi and logs XHR
					addCORsHeaders(self.config, req, resp);
				}
			} else if (req.headers.origin) {
				// CORS
				addCORsHeaders(self.config, req, resp);
			}
			next();
		});

		// load up admin if enabled
		this.config.admin && this.config.admin.enabled && (this.admin = new (require('./admin'))(this));

		// create the default authentication strategy
		try {
			this.authstrategy = new Authentication(this);
		}
		catch (E) {
			this.logger.fatal('Error attempting to configure API authentication. ' + E.message || E);
		}

		this.logger.trace('creating Arrow server instance on port %d', this.port);
	} else {
		this.logger = Logger.createLogger({name: pkg.name, useConsole: true, level: this.config.logLevel});
		this.pkg = pkg;
	}

	if (process.env.APPC_DUMP_ENV) {
		this.logger.trace(process.env);
	}

	// pass the config to components but remove some parts
	this.objConfig = _.pick(this.config, 'name', 'port', 'admin', 'session', 'apikey', 'apikey_production', 'apikey_development');

	this.models = {};
	this.apis = [];
	this.blocks = {};
	this.routes = [];

	if (!loadOnly) {
		this.on('reload', this.reload);
	}

	// start loading our server
	process.nextTick(this.load.bind(this));
}

function addLocals(server, app, baseurl) {
	// record our base url for the platform and our external url
	app.locals.appc_platform_url = server.platformurl = AppC.baseurl;
	app.locals.appc_external_url = server.baseurl = baseurl;
	app.locals.appc_external_admin_url = server.adminurl = app.locals.appc_external_url + server.config.admin.prefix;
	app.locals.appc_external_create_url = server.createurl = app.locals.appc_external_url + server.config.admin.createprefix;
	app.locals.appc_external_apidoc_url = server.apidocurl = app.locals.appc_external_url + (server.config.admin && server.config.admin.apiDocPrefix || '/apidocs');
	app.locals.appc_env = process.env.APPC_ENV || process.env.NODE_ENV;
	app.locals.appc_registry_url = process.env.APPC_REGISTRY_SERVER || AppC.registryurl;
	app.locals.appc_security_url = process.env.APPC_SECURITY_SERVER || AppC.securityurl;
	server.logger.trace('setting app locals', app.locals);
}

// default headers that are allowed
// change them by setting property in config
//
// cors: {
//   safeHeaders: ['origin']
// }
//
//
const DEFAULT_SAFE_HEADERS = [
	'x-requested-with',
	'request-id',
	'response-time',
	'accept',
	'origin',
	'content-type',
	'authorization',
	'x-titanium-id',
	'x-native-id'
];

function addCORsHeaders(config, req, resp) {
	var corsConfig = config.cors || {},
		apis = API.getAPIsForPath(req.path),
		checkOrigin = corsConfig['Access-Control-Allow-Origin'] || '*',
		allowMethods = corsConfig['Access-Control-Allow-Methods'];

	if (req.headers.origin && req.headers.host && req.headers.origin.indexOf(req.headers.host) > 0) {
		if (checkOrigin === '*' || checkOrigin === req.headers.origin) {
			resp.setHeader('Access-Control-Allow-Origin', req.headers.origin);
		} else {
			// deny it
			return;
		}
	} else {
		resp.setHeader('Access-Control-Allow-Origin', checkOrigin);
	}

	if (allowMethods) {
		resp.setHeader('Access-Control-Allow-Methods', typeof allowMethods === 'object' ? allowMethods.join(', ') : allowMethods);
	}

	if ('access-control-request-headers' in req.headers) {
		var safeHeaders = corsConfig.safeHeaders || DEFAULT_SAFE_HEADERS;
		var wantHeaders = _.compact(req.headers['access-control-request-headers'].split(',').map(function (h) {
			h = h.trim();
			if (safeHeaders.indexOf(h) !== -1) {
				return h;
			}
		})).join(', ');
		resp.setHeader('Access-Control-Expose-Headers', wantHeaders);
		resp.setHeader('Access-Control-Allow-Headers', wantHeaders);
		resp.setHeader('Access-Control-Allow-Credentials', 'true');
	}
}

/**
 * Returns the middleware instance containing the Express app instance.
 * @returns {Arrow.Middleware}
 */
Arrow.prototype.getMiddleware = function () {
	return this.middleware;
};

/**
 * Tracks all instantiations.
 */
Arrow.trackInstantiations = function () {
	instantiations = [];
};

/*
 * used for testing only
 *
 * @private
 */
Arrow.resetGlobal = function () {
	if (instantiations !== undefined) {
		instantiations.forEach(function (arrow) {
			if (arrow.logmanager) {
				arrow.logmanager.stop();
			}
			if (arrow.logger && arrow.logger.requestLogger && arrow.logger.requestLogger.streams) {
				arrow.logger.requestLogger.streams.forEach(function (f) {
					f.stream.end();
				});
			}
		});
		instantiations = [];
	}
	Arrow.ORM.MemoryConnector.resetPrimaryKeys();
	connectors = {};
	loadedModelDirs = [];
	globalArrow = null;
	pendingRequests = 0;
};

/**
 * Gets a reference to the first instantiated arrow server.
 * @returns {Arrow}
 */
Arrow.getGlobal = function () {
	return globalArrow;
};

/*
 * create the logger
 */
function createServerLogger(arrow, server) {
	var logging = arrow.config.logging || {};
	// use a restify logger if transaction logging is on. it contains a console logger
	// too...
	// API-689 -- disable in production for now
	if (arrow.inProduction) {
		logging.transactionLogEnabled = false;
	}
	if (cluster.isWorker) {
		// we set the request logger to be unique so that each cluster worker will
		// write to a different file
		logging.requestsLogFilename = 'request-cluster-' + cluster.worker.id + '.log';
		arrow.config.logging = logging;
	}
	// create the restify logger
	var logger = Logger.createRestifyLogger(server, {
		afterEvent: 'txdone',
		level: arrow.config.logLevel,
		logs: logging.directory,
		requestsLogFilename: logging.requestsLogFilename,
		logSingleRequest: logging.transactionLogEnabled || logging.transactionLogEnabled === undefined
	});
	// only setup the log manager if transaction logging is enabled and we're in production
	if (arrow.inProduction || logging.processRemoteLogsInDev) {
		if (!arrow.inProduction && logging.processRemoteLogsInDev) {
			// write out test log config
			var logConfigFn = path.join(arrow.config.dir, 'conf', 'deploy.json'),
				logConfig = {
					logserver: 'http://127.0.0.1:8999',
					org_id: process.env.APPC_SESSION_ORGID,
					username: process.env.APPC_SESSION_USERNAME,
					name: pkg.name,
					version: pkg.version
				};
			fs.writeFileSync(logConfigFn, JSON.stringify(logConfig));
		}
		arrow.logmanager = new LogManager(arrow, logger);
	}
	return logger;
}

/*
 * start a connector and call next when completed
 */
function startConnector(instance, connector, next) {
	if (connector.connect && !instance.loadOnly && !connector.started) {
		// if the connector is disabled, don't start it
		if (connector.enabled === false || (connector.config && connector.config.enabled === false)) {
			if (!connector.enableWarning) {
				// only warn once
				instance.logger.info(chalk.green('connector/' + connector.name) + ' is disabled in config. will not start it and it won\'t be available');
			}
			connector.enabled = false;
			connector.enableWarning = true;
			return next();
		}
		instance.logger.info('starting ' + chalk.green('connector/' + connector.name + (connector.version ? ('@' + connector.version) : '')));
		connector.connect(function (err) {
			if (err) {
				err = new Error('Error loading connector/' + connector.name + '. ' + (err.message || err));
				return next(err);
			}
			connector.started = true;
			connector.enabled = true;
			instance.logger.info('started ' + chalk.green('connector/' + connector.name));
			next && next();
		});
	} else {
		next && next();
	}
}

/**
 * Returns the full path of the component directory.
 * @param {String} type Component type, that is, `api`, `block`, `model` or `route`.
 * @param {Boolean} nmd Set to `true` if using a node module.
 * @returns String
 */
Arrow.prototype.getComponentDir = function getComponentDir(type, nmd) {
	if (type === 'route') {
		// these live in a little bit of a different location
		return path.resolve(path.join(this.config.dir || process.cwd(), 'web', 'routes'));
	}
	return path.resolve(path.join(this.config.dir || process.cwd(), (nmd ? 'node_modules/' : '') + type + 's'));
};

/**
 * Prepares appc-pubsub for usage within Arrow. Warns the user if it is not installed locally to their project, or not
 * configured properly.
 */
Arrow.prototype.definePubSub = function (appPkg) {
	var self = this;
	if (!this.config.pubsub.key || !this.config.pubsub.secret) {
		self.logger.error('appc-pubsub is defined in your configuration, but not correctly! Please specify your pubsub key and secret.');
		return;
	}
	var PubSubClient;
	try {
		PubSubClient = require('appc-pubsub');
	}
	catch (E) {
		self.logger.error('appc-pubsub is configured, but not installed! Please make sure you install it: `npm install --save appc-pubsub`.', E, E.stack);
		return;
	}
	var options = _.merge({}, this.config.pubsub);
	try {
		options.newrelic = require('newrelic');
	}
	catch (E) {
		self.logger.trace('newrelic is not installed; if you want it to run, please `npm install --save newrelic`.');
		// this is OK, just means we don't have it
	}
	this.pubsub = new PubSubClient(options);
	this.pubsub.on('error', function (err) {
		self.logger.error('pubsub error', err, err.stack);
	});
	this.pubsub.on('unauthorized', function (err) {
		self.logger.error('pubsub client is unauthorized. check your key and secret in your configuration to ensure these values are correct.');
	});
	this.postServerEvent = function (name, immediate) {
		self.pubsub.publish(name, {
			url: process.env.NODE_ACS_URL,
			name: appPkg.name,
			version: appPkg.version,
			appid: process.env.appid,
			serverId: process.env.serverId,
			env: self.config.env,
			username: process.env.APPC_SESSION_USERNAME,
			org_id: process.env.APPC_SESSION_ORGID,
			node_version: process.version,
			arrow_version: pkg.version
		}, immediate);
	};
	this.on('started', function () {
		self.postServerEvent('com.appcelerator.server.started');
	});
	this.on('stopping', function () {
		self.postServerEvent('com.appcelerator.server.stopped', true);
	});
	this.on('stopped', function () {
		setTimeout(self.pubsub.close.bind(self.pubsub), 500);
	});
};

/**
 * Loads an API from an API file. The file must exist and be a valid API. No error checking is performed.
 * @param {String} fn Filename of the API.
 * @param {Function} [cb] Callback passed an Error object (or null if successful), the API instance, and the API class.
 */
Arrow.prototype.loadApi = function loadAPI(fn, cb) {
	this.logger.debug('attempting to load API', fn);
	var APIClass = paths.requireComponent(fn, true);
	if (!APIClass) {
		this.logger.trace(APIClass);
		throw new Error('Error loading api at ' + fn);
	}
	if (!_.isFunction(APIClass)) {
		this.logger.trace(APIClass);
		throw new Error('Error loading api at ' + fn + '. this module did not export a Class');
	}
	var api = new APIClass(this.objConfig, this, fn);
	this.apis.push(api);
	this.triggerReloadedIfRequired(false, [{fn: this.app}]);
	cb && cb(null, api, APIClass);
};

/**
 * Loads a Model from a Model file. The file must exist and be a valid Model. No error checking is performed.
 * @param {String} fn Filename of the Model.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Model class.
 */
Arrow.prototype.loadModel = function loadModel(fn, cb) {
	this.logger.debug('attempting to load model', fn);
	var Model = paths.requireComponent(fn, true);
	if (!Model) {
		this.logger.trace(Model);
		throw new Error('Error loading model at ' + fn);
	}
	if (!_.isObject(Model)) {
		this.logger.trace(Model);
		throw new Error('Error loading model at ' + fn + '. this module did not load properly');
	}
	if (!_.isFunction(Model.create) && !Model.loadingModels) {
		this.logger.trace(Model);
		throw new Error('Error loading model at ' + fn + '. this module did not export a Class');
	}
	// if we don't provide a connector, attempt to get the connector global default the config
	// this makes it nice since i can simply put my default in the config and i don't need to specify
	// on each and every model
	Model.connector = Model.connector || this.config.defaultConnector;
	Model.name && (this.models[Model.name] = Model);
	Model.filename = fn;
	if (!Model.generated) {
		Model.timestamp = fs.statSync(fn).mtime;
	}
	this.triggerReloadedIfRequired(false, [{fn: Model}]);
	cb && cb(null, Model);
};

/**
 * Loads a Block from a Block file. The file must exist and be a valid Block. No error checking is performed.
 * @param {String} fn Filename of the Block.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Block class.
 */
Arrow.prototype.loadBlock = function loadBlock(fn, cb) {
	this.logger.debug('attempting to load block', fn);
	var Block = paths.requireComponent(fn, true);
	if (!Block) {
		this.logger.trace(Block);
		throw new Error('Error loading block at ' + fn);
	}
	if (!_.isFunction(Block)) {
		this.logger.trace(Block);
		throw new Error('Error loading block at ' + fn + '. this module did not export a Class');
	}
	var block = new Block(this.objConfig, this);
	this.blocks[block.name] = block;
	Block.filename = block.filename = fn;
	Block.timestamp = block.timetsamp = fs.statSync(fn).mtime;
	this.triggerReloadedIfRequired(false, [{fn: block}]);
	cb && cb(null, Block);
};

/**
 * Loads a Route from a Route file. The file must exist and be a valid Route. No error checking is performed.
 * @param {String} fn Filename of the Route.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Route class.
 */
Arrow.prototype.loadRoute = function loadRoute(fn, cb) {
	this.logger.debug('attempting to load route', fn);
	var Router = paths.requireComponent(fn, true);
	if (!Router) {
		this.logger.trace(Router);
		throw new Error('Error loading route at ' + fn);
	}
	if (!_.isFunction(Router)) {
		this.logger.trace(Router);
		throw new Error('Error loading route at ' + fn + '. this module did not export a Class');
	}
	var route = new Router(this.objConfig, this);
	this.routes.push(route);
	Router.filename = route.filename = fn;
	Router.timestamp = route.timestamp = fs.statSync(fn).mtime;
	this.triggerReloadedIfRequired(false, [{fn: route}]);
	cb && cb(null, Router);
};

/**
 * Loads a Connector from a Connector file. The file must exist and be a valid Connector. No error checking is performed.
 * @param {String} fn Filename of the Connector.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Connector class.
 */
Arrow.prototype.loadConnector = function loadConnector(fn, cb) {
	this.logger.debug('attempting to load connector', fn);
	var Connector = paths.requireComponent(fn, true);
	if (!Connector) {
		this.logger.trace(Connector);
		throw new Error('Error loading connector at ' + fn);
	}
	if (!_.isObject(Connector)) {
		this.logger.trace(Connector);
		throw new Error('Error loading connector at ' + fn + '. this module did not export an object');
	}
	if (!_.isObject(Connector.create)) {
		this.logger.trace(Connector);
		throw new Error('Error loading connector at ' + fn + '. this module did not export a Class function');
	}
	var connector;
	if (!Connector.name && Connector.create) {
		if (Connector.filename) {
			connector = this.getConnector(Connector.filename.split(path.sep).pop());
		}
	} else {
		connector = this.getConnector(Connector.name);
	}
	if (connector) {
		connector.filename = Connector.filename = fn;
		startConnector(this, connector, cb);
		this.logger.debug('loaded connector', fn);
	} else {
		cb();
	}
};

/*
 * internally used to trigger a reloaded event if necessary
 */
Arrow.prototype.triggerReloadedIfRequired = function triggerReloadedIfRequired(force, obj, err) {
	if (!stopping && (force || this.loaded) && !this.pendingReload) {
		this.logger.debug('reloaded', obj);
		this.emit('reloaded', obj && Array.isArray(obj) ? obj : [obj], err);
	}
};

/**
 * Loads all project components.
 * @param {Function} callback Callback to execute after loading each component. Passed an Error object if any.
 * @param {Boolean} skipConnectors Set to `true` to not load Connectors.
 */
Arrow.prototype.loadComponents = function loadComponents(callback, skipConnectors) {
	var instance = this;
	var tasks = [];

	// make sure we first load any connectors specified in the configuration
	// so that we can setup the aliases correctly
	var allConnectors = this.config && this.config.connectors;
	for (var name in allConnectors) {
		if (allConnectors.hasOwnProperty(name)) {
			var loadedConnector = instance.getConnector(name, false);
			if (!loadedConnector) {
				this.logger.error('Couldn\'t find connector named: ' + name);
				delete allConnectors[name];
			} else {
				(function (loadedConnector) {
					tasks.push(function (cb) {
						startConnector(instance, loadedConnector, cb);
					});
				})(loadedConnector);
			}
		}
	}

	// load connectors, models, blocks, apis, and then routes from directories (in that order)
	// first using the node_modules (the true) and then
	// using the cwd/<type> (the false)
	['connector', 'model', 'block', 'api', 'route'].forEach(function (type) {
		if (skipConnectors && type === 'connector') { return; }
		var typeName = type.charAt(0).toUpperCase() + type.substring(1),
			mn = 'load' + typeName,
			loadFn = instance[mn].bind(instance);
		// set a flag that we're loading
		tasks.push(function (cb) {
			instance['loading' + typeName + 's'] = true;
			cb();
		});
		iterateComponentDir(instance, type, true, function (fn) {
			tasks.push(function (cb) {
				try {
					loadFn(fn, cb);
				}
				catch (E) {
					cb(E);
				}
			});
		});
		iterateComponentDir(instance, type, false, function (fn) {
			tasks.push(function (cb) {
				try {
					loadFn(fn, cb);
				}
				catch (E) {
					cb(E);
				}
			});
		});
		tasks.push(function (cb) {
			// delete our flag
			delete instance['loading' + typeName + 's'];
			// fire an event that we're done loading in case
			// we have someone listening for pending models to finish before continuing
			instance.emit('loaded' + typeName + 's');
			cb();
		});
	});

	async.series(tasks, callback);
};

/*
 * called internally to start loading server. when you call start, it will wait until the
 * loaded event is fired
 */
Arrow.prototype.load = function load(callback) {
	this.loadComponents(function (err) {
		if (!err) {
			//indicate we've started and emit loading event
			this.loaded = true;
			this.emit('loaded');
		} else if (callback) {
			callback(err);
		} else {
			this.emit('error', err);
		}
	}.bind(this));
};

/*
 * utility function to iterate a component directory and for each component found, call
 * the foundCallback function will the parameter of the path to the component
 */
function iterateComponentDir(instance, type, useNodeModuleDir, foundCallback) {
	var dir = instance.getComponentDir(type, useNodeModuleDir);
	instance.logger.trace('iterateComponentDir', type, dir);
	if (fs.existsSync(dir)) {
		if (type === 'model') {
			try {
				var appcJSON = require(dir + '/../appc.json');
				if (appcJSON && appcJSON.type === 'connector') {
					instance.logger.trace('skipping iterateComponentDir for ' + appcJSON.type, type, dir);
					return;
				}
			}
			catch (e) {
			}
			if (loadedModelDirs.indexOf(dir) >= 0) {
				instance.logger.trace('iterateComponentDir already read', type, dir);
				return;
			}
			loadedModelDirs.push(dir);
		}

		// if node_modules or a connector, we load not the individual files but the directory as module
		if (useNodeModuleDir) {
			var names = fs.readdirSync(dir);
			names.forEach(function nameIterator(name) {
				var ndir = path.join(dir, name),
					pkg = path.join(ndir, 'package.json');
				if (fs.existsSync(pkg)) {
					foundCallback(ndir);
				} else {
					instance.logger.trace('iterateComponentDir - no package json at', pkg);
				}
			});
		} else if (type === 'connector') {
			var pkg = path.join(dir, 'package.json');
			if (fs.existsSync(pkg)) {
				foundCallback(dir);
			} else {
				instance.logger.trace('iterateComponentDir - no package json at', pkg);
			}
		} else {
			var files = wrench.readdirSyncRecursive(dir),
				jsfileRE = /^((?!_))(.*)?\.js$/;
			files.forEach(function fileIterator(file) {
				if (jsfileRE.test(path.basename(file))) {
					var fn = path.join(dir, file);
					foundCallback(fn);
				} else {
					instance.logger.trace('iterateComponentDir - skipping...', file);
				}
			});
		}
	} else {
		instance.logger.trace('iterateComponentDir not found', type, dir);
	}
}

/**
 * Returns a configuration value for the key (or a provided default value if not found).
 * @param {String} key Key to retrieve.
 * @param {Any} def Default value to return if the key cannot be found.
 */
Arrow.prototype.get = function get(key, def) {
	return this.config[key] || def;
};

/*
 * handle the authentication flow for both sync and async implementations
 */
function executeAuth(authstrategy, req, resp, next) {
	if (authstrategy.validateRequest.length < 3) {
		// this is a synchoronous interface for simplicity
		try {
			var passed = authstrategy.validateRequest(req, resp);
			next(null, passed);
		}
		catch (E) {
			return next(E);
		}
	} else {
		// this is asynchronous
		authstrategy.validateRequest(req, resp, next);
	}
}

/*
 * returns true if this request looks like it's from the browser and accepts
 * HTML as response
 */
function isBrowserClient(req) {
	return (req.headers &&
	req.headers.accept &&
	req.headers.accept.indexOf('/html') > 0 &&
	req.headers['user-agent'] &&
	/Mozilla|Safari|Chrome|WebKit|Gecko|MSIE/i.test(req.headers['user-agent']));
}

/**
 * returns false if the model name passed in does not exist.
 * It handles the fatal error if the model does exist.
 *
 * At the moment it returns true, but it should stop the server
 */
function isModelDuplicate(modelName) {
	if (globalArrow && (modelName in globalArrow.models)) {
		if (globalArrow.ignoreDuplicateModels) {
			return false;
		}
		// Model already exists!
		throw new Error('Model name: ' + modelName + ' exists in multiple places');
	} else {
		return false;
	}
}

/**
 * Creates and executes a security middleware call, which authenticates the request.
 * @param {Object} req Request object.
 * @param {Object} resp Response object.
 * @param {Function} next Next function to call.
 */
Arrow.prototype.executeSecurityMiddleware = function executeSecurityMiddleware(req, resp, next) {

	// allow plugins to turn it off
	if (req.skipSecurityCheck) {
		return next();
	}

	// old server plugin. you could specify a authentication function
	// and we would call that. keep this in place for existing apps
	if (this.authentication) {
		if (this.admin && req.url.indexOf(this.admin.prefix) === 0) {
			return next();
		}
		return this.authorization(req, resp, next);
	}

	// we are using the newer authentication strategy plugin framework
	if (this.authstrategy.matchURL(req)) {
		return executeAuth(this.authstrategy, req, resp, function (err, passed, result) {
			if (!passed || err || result) {
				// if a browser, serve HTML to make it a little more friendly for the user
				if (isBrowserClient(req)) {
					resp.status(401);
					resp.setHeader('Content-Type', 'text/html');
					// allow a custom error page if configured, otherwise, use our built-in
					var customPage = req.server.config.admin.customHTMLErrorPage &&
						fs.existsSync(req.server.config.admin.customHTMLErrorPage) &&
						req.server.config.admin.customHTMLErrorPage ||
						path.join(__dirname, 'templates', '401.html');
					var buf = fs.readFileSync(customPage).toString();
					var ejs = require('ejs');
					var hash = Date.now();
					buf = ejs.render(buf, {prefix: req.server.config.admin.prefix, githash: hash});
					resp.write(buf);
					resp.end();
				} else {
					// otherwise, this is an API
					resp.status(err && err.statusCode || 401);
					resp.json(result || {
							id: err && err.id || 'com.appcelerator.api.unauthorized',
							message: err && err.message || 'Unauthorized',
							success: false
						});
				}
				return next(false);
			}
			next();
		});
	} else {
		next();
	}
};

/*
 * calls callback with true if available, false if not
 */
function isPortAvailable(port, cb, tries) {
	// if we are using PORT passed in from Arrow Cloud -or-
	// if we're running in a cluster worker, just continue
	if (inProduction || cluster.isWorker) {
		return cb(true);
	}
	tries = (tries || 0) + 1;
	var net = require('net'),
		server = net.createServer();
	server.listen(port, function (err) {
		if (err) { return cb(err); }
		var newcb;
		if (port === 0) {
			// pick a random port when 0 is used
			// we need to increment in user land and then verify again (below)
			port = server.address().port + 10;
			newcb = cb;
			cb = null;
		}
		server.once('close', function () {
			cb && cb(true, port);
			if (newcb) {
				// we need to verify our new port assigned to
				// make sure it's available since platforms don't
				// guarantee they are available
				// http://stackoverflow.com/questions/9901043/how-does-node-js-choose-random-ports
				return isPortAvailable(port, newcb, tries);
			}
		});
		server.close();
	});
	server.once('error', function (err) {
		try {
			server.close();
		}
		catch (e) {
		}
		if (err.code !== 'EADDRINUSE' || tries > 3) {
			cb && cb(false);
		} else {
			// on restart, sometimes a bind will fail, so let's try it again
			// for up to 3 times
			setTimeout(function () {
				isPortAvailable(port, cb, tries);
			}, 10);
		}
	});
}

/**
 * Starts the server.
 * @param {Function} [callback] Callback passed an Error object.
 * @throws Error
 */
Arrow.prototype.start = function start(callback) {

	// this can happen if you call loadOnly in constructor and then later
	// try and start the server
	if (!this.app) {
		var error = new Error('invalid state. no internal app was created. did you call loadOnly in the Arrow constructor?');
		if (callback) {
			return callback(error);
		} else {
			throw error;
		}
	}

	// if we started and then stopped and now we're restarting, we need to reload this
	if (this.shuttingdown) {
		this.logger.trace('re-start after a shutdown');
		var self = this;
		this.shuttingdown = false;
		return async.each(this.apis, function (api, cb) {
			api.remove(self, cb);
		}, function (err) {
			if (err) { return callback(err); }
			async.each(self.routes, function (route, cb) {
				if (route) {
					route.remove(self, cb);
				} else {
					cb();
				}
			}, function (err) {
				if (err) { return callback(err); }
				Object.keys(self.blocks).forEach(function (name) {
					var block = self.blocks[name];
					block.removeAllListeners();
				});
				self.models = {};
				self.apis = [];
				self.blocks = {};
				self.routes = [];
				self.load(function (err) {
					if (err) { return callback(err); }
					self.start(callback);
				});
			});
		});
	}

	if (!callback) {
		callback = function (err) {
			if (err) {
				this.logger.error('server failed to start');
				this.logger.error(err);
			} else {
				if (this.port) {
					this.logger.info('server started on port', this.port);
				} else {
					this.logger.info('server started');
				}
			}
		}.bind(this);
	}

	if (!this.loaded) {
		this.logger.debug('waiting on server to finish loading');
		// we haven't finished loading, wait for the loading event to
		// fire and then re-entrant the start function
		return this.on('loaded', function () {
			return this.start(callback);
		}.bind(this));
	}

	this.logger.debug('starting', this.port);
	this.emit('starting');
	if (process.send && process.connected) { process.send('starting'); }

	var tasks = [],
		listener,
		instance = this;

	// start any connectors that haven't been connected
	Object.keys(connectors).forEach(function connectorIterator(connectorName) {
		var connector = connectors[connectorName];
		if (!connector.connected) {
			tasks.push(function connectorConnectTask(cb) {
				startConnector(instance, connector, cb);
			});
		}
	});

	// turn our models into apis
	tasks.push(function createModelAPIs(next) {
		this.createAPIsFromModels();
		next();
	}.bind(this));

	// check our APIs and Routes for uniqueness
	tasks.push(function checkAPIs(next) {
		var uniqueMap = {},
			routesAndAPIs = [].concat(this.apis, this.routes);
		for (var i = 0; i < routesAndAPIs.length; i++) {
			var obj = routesAndAPIs[i];
			if (!obj.enabled) {
				continue;
			} else if (uniqueMap[obj.method + ':' + obj.path]) {
				this.logger.warn('Multiple APIs or Routes registered for the same path and method; please disable or change the path of all but one of them for consistent results:');
				this.logger.warn(' - ' + obj.method + ' ' + obj.path);
				this.logger.warn(' - to disable a Model method, use `actions: [ ... ]` or `disabledActions: [ "' + obj.describes + '" ]`');
				this.logger.warn(' - to disable an API or Route, use `enabled: false');
			} else {
				uniqueMap[obj.method + ':' + obj.path] = true;
			}
		}
		next();
	}.bind(this));

	// check the port to make sure its free
	tasks.push(function checkPortTask(next) {
		isPortAvailable(this.port, function (available, port) {
			if (!available) {
				return next(new Error('Assigned port (' + this.port + ') is already in use. ' +
					'Please see if you have a running instance of this service on this machine. ' +
					'You can also specify the port using the PORT environment variable when starting ' +
					'the server or change in your config file.'));
			}
			// assign it in case it was wildcard
			this.port = port || this.port;
			return next();
		}.bind(this));
	}.bind(this));

	// bind our apis
	tasks.push(function (next) {
		sortAPIsOrRoutes(this.apis);
		var keys = {};
		this.apis.forEach(function (api) {
			if (api.enabled) {
				// keep track of already bound apis and only bind once (save memory)
				var key = api.method + api.path;
				if (key in keys) {
					return;
				}
				keys[key] = 1;
				api.bind(instance.app);
			}
		});
		next();
	}.bind(this));

	// bind our routes
	tasks.push(function (next) {
		sortAPIsOrRoutes(this.routes);
		var keys = {};
		this.routes.forEach(function (route) {
			if (route.enabled) {
				// keep track of already bound routes and only bind once (save memory)
				var key = route.method + route.path;
				if (key in keys) {
					return;
				}
				keys[key] = 1;
				route.bind(instance.app);
			}
		});
		next();
	}.bind(this));

	// bind swagger routes
	tasks.push(function (next) {
		bindSwaggerRoutes(this);
		next();
	}.bind(this));

	// start the admin server
	tasks.push(function (next) {
		if (this.admin) {
			this.admin.start(this, next);
		} else {
			next();
		}
	}.bind(this));

	// start up the server
	tasks.push(function appListenTask(next) {
		this.emit('listening');
		if (process.send && process.connected) { process.send('listening'); }
		if (this.config.ssl && (!inProduction || this.config.sslInProduction)) {
			var https = require('https');
			var sslPort = process.env.SSLPORT || this.config.ssl.port || 8443;
			this.sslServer = https.createServer(this.config.ssl, this.app).listen(sslPort);
			if (this.config.timeout !== undefined) {
				this.sslServer.setTimeout(this.config.timeout);
			}
			this.logger.info('SSL bound to port', sslPort);
			this.sslPort = sslPort;
		}
		this.server = this.app.listen(this.port, next);
		if (this.config.timeout !== undefined) {
			this.server.setTimeout(this.config.timeout);
		}
	}.bind(this));

	// start the log manager
	tasks.push(function logManagerTask(next) {
		if (this.logmanager) {
			this.logmanager.start();
		}
		next();
	}.bind(this));

	// check if dev and production node version match
	tasks.push(function checkNodeVersion(next) {
		pluginUtil.printSpecifyNodeVersionWarningIfRequired(this.productionNodeVersion, this.logger);
		next();
	}.bind(this));

	tasks.push(function startedTask(next) {
		this.logger.info('started');
		this.emit('listen');
		this.emit('started');
		if (process.send && process.connected) { process.send('listen'); }
		if (process.send && process.connected) { process.send('started'); }
		this.proxy && listener && this.proxy.removeListener('connected', listener);
		servers.push(this);
		next();
	}.bind(this));

	if (process.argv.indexOf('--repl') >= 0) {
		tasks.push(function startRepl(next) {
			var server = this;
			process.nextTick(function () {
				console.log('');
				var r = require('repl').start({
					prompt: 'Arrow> ',
					useColors: true,
					useGlobal: true
				});
				r.context.server = server;
				r.context.Arrow = Arrow;
				r.context._ = _;
				r.context.fs = fs;
				r.context.path = path;
				r.on('exit', function () {
					server.stop();
				});
			});
			next();
		}.bind(this));
	}

	async.series(tasks, function (err) {
		err && this.emit('error', err);
		callback(err);
	}.bind(this));
};

/**
 * Generates the standardized APIs from all loaded models.
 */
Arrow.prototype.createAPIsFromModels = function () {
	Object.keys(this.models).forEach(function routeModelIterator(name) {
		var model = this.models[name];
		this.createAPIsFromModel(model);
	}.bind(this));
};

/**
 * Generates the standardized APIs from a particular model.
 */
Arrow.prototype.createAPIsFromModel = function (model) {
	if (model.connector && _.isString(model.connector)) {
		try {
			model._connector = model.connector;
			model.connector = this.getConnector(model.connector, true);
			model.connector.emit('init-model', model);
		}
		catch (E) {
			this.logger.trace(E.stack);
			throw new Error('Error loading connector: ' + model._connector + ' for model: ' + model.name + '. ' + E.message);
		}
	}
	if (model.autogen) {
		var modelAPIs = makeAPIsFromModel(model, this.config.apiPrefix);
		modelAPIs.forEach(function modelAPIConstructorIterator(API) {
			var api = new API(this.objConfig, this);
			this.apis.push(api);
		}.bind(this));
	}
};

/**
 * Sort the APIs or Routes (we need wildcard paths to be registered later in the process).
 */
function sortAPIsOrRoutes(apisOrRoutes) {
	apisOrRoutes.sort(function (a, b) {
		if (a.sort < b.sort) {
			return 1;
		} else if (a.sort > b.sort) {
			return -1;
		}
		// shortest paths first
		return a.path.length > b.path.length;
	});
}

function makeAPIsFromModel(model, apiPrefix) {
	// if autogen off, don't generate APIs for Model
	if (!model.autogen || (model.connector && model.connector.enabled === false) || !model.connector) {
		return [];
	}

	var apis = [],
		name = model.name;

	model.prefix = model.prefix || apiPrefix + '/' + name.toLowerCase();
	model.singular = model.singular || pluralize(name.toLowerCase(), 1);
	model.plural = model.plural || pluralize(name.toLowerCase());

	for (var key in model) {
		if (key.slice(-3) === 'API') {
			var val = model[key],
				isAPIDescriptor = _.isFunction(val),
				describes = key.slice(0, -3),
				describesUC = describes.substr(0, 1).toUpperCase() + describes.substr(1),
				enabled = true;

			if (!isAPIDescriptor) {
				continue;
			}
			var api = model[key]();
			if (!api) {
				continue;
			}

			// Check to see if the underlying connector has the necessary methods to support this API.
			var connectorMethods = (api.dependsOnAny || api.dependsOnAll || [describes]).filter(function (depConnectorMethod) {
				return !!model.getConnector()[depConnectorMethod];
			});
			if (connectorMethods.length < (api.dependsOnAll ? api.dependsOnAll.length : 1)) {
				enabled = false;
				delete api.enabled;
			}

			// Should we disable based on our action or action groups being disabled?
			if (model.actions.indexOf(describes) === -1 && (!api.actionGroup || model.actions.indexOf(api.actionGroup) === -1)) {
				enabled = false;
			}
			if (model.disabledActions && model.disabledActions.indexOf(describes) >= 0) {
				enabled = false;
				delete api.enabled;
			}

			// Handle some defaults for the API.
			if (!api.path) {
				api.path = model.prefix;
			} else if (api.path.substr(0, 2) === './') {
				api.path = model.prefix + api.path.substr(1);
			}
			_.defaultsDeep(api, {
				responses: {
					401: {
						description: 'This request requires user authentication, as configured by the server.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					404: {
						description: 'No results were found.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					500: {
						description: 'Something went wrong during the request; check out the logs on your server.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					504: {
						description: 'The request took too long to process, and the server timed it out.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					'default': {
						description: 'Response from Server',
						schema: {
							$ref: '#/definitions/ResponseModel'
						}
					}
				}
			});

			apis.push(API.extend(_.defaults(api, {
				uiSort: Number.MAX_VALUE,
				enabled: enabled,
				generated: true,
				documented: model.documented === undefined ? model.connector.config.documented : model.documented,
				group: name,
				describes: describes,
				method: 'GET',
				parameters: {},
				singular: model.singular,
				plural: model.plural,
				model: name,
				pre: _.flatten(_.compact([
					model['pre' + describesUC], model['before' + describesUC],
					model['pre' + (api.method || 'GET')], model['before' + (api.method || 'GET')],
					model.pre, model.before
				])),
				post: _.flatten(_.compact([
					model['post' + describesUC], model['after' + describesUC],
					model['post' + (api.method || 'GET')], model['after' + (api.method || 'GET')],
					model.post, model.after
				]))
			})));
		}
	}

	return apis;
}

/**
 * Removes an API from the server.
 * @param {String} filename Name of the file of the API to remove.
 * @param {Function} [callback] Callback function passed an Error object (or null if successful).
 */
Arrow.prototype.removeAPIByFilename = function removeAPIByFilename(filename, callback) {
	var api = _.filter(this.apis, function (api) {
		return api.filename === filename;
	})[0];

	if (api) {
		api.remove(this, function (err) {
			this.triggerReloadedIfRequired(true, {filename: api}, err);
			callback && callback();
		}.bind(this));
	} else {
		callback && callback(new Error('couldn\'t find an API at ' + filename));
	}
};

/**
 * Reloads any changes found in Models, Blocks, Routes or APIs.
 * @param {Function} [callback] Callback to execute after the reload.
 */
Arrow.prototype.reload = function reload(callback) {
	this.logger.debug('reload called');
	this.stop(function () {
		globalArrow = new Arrow(this.config);
		globalArrow.start(function (err) {
			this.logger.debug('reload finished!');
			callback && callback();
		}.bind(this));
	}.bind(this));
};

/**
 * Stops the Arrow server instance.
 * @param {Function} [callback] Callback to execute after the server stops.
 */
Arrow.prototype.stop = function stop(callback) {
	this.shuttingdown = true;

	if (this.server && !this.stopped) {

		for (var c = 0; c < servers.length; c++) {
			var server = servers[c];
			if (server === this) {
				servers.splice(c, 1);
				break;
			}
		}

		this.stopped = true;
		this.logger.debug('stopping');
		this.emit('stopping');
		if (process.send && process.connected) { process.send('stopping'); }

		var tasks = [];

		// first stop the server so we don't serve request
		tasks.push(function serverCloseTask(next) {
			try {
				// ignore any errors on shutdown
				this.server.close(function (err) {
					next();
				});
			}
			catch (E) {
				next();
			}
		}.bind(this));

		// stop the SSL server if we have one
		if (this.sslServer) {
			tasks.push(function serverCloseTask(next) {
				try {
					// ignore any errors on shutdown
					this.sslServer.close(function (err) {
						next();
					});
				}
				catch (E) {
					next();
				}
			}.bind(this));
		}

		// now disconnect all connectors
		Object.keys(connectors).forEach(function stopConnectorIterator(name) {
			var connector = connectors[name];
			connector.disconnect && tasks.push(function connectorDisconnectTask(next) {
				connector.disconnect(next);
			});
		}.bind(this));

		// stop the log manager
		tasks.push(function (next) {
			if (this.logmanager) {
				this.logmanager.stop();
			}
			next();
		}.bind(this));

		// stop the handlerbars watcher if running
		tasks.push(function (next) {
			var handlebars = this.getMiddleware().getRendererEngine('hbs');
			handlebars && handlebars.cleanupWatchers();
			next();
		}.bind(this));

		// now fire our lifecycle event
		async.series(tasks, function asyncCallback() {
			this.emit('stopped');
			if (process.send && process.connected) { process.send('stopped'); }
			this.logger.info('stopped');
			loadedModelDirs = [];
			callback && callback();
		}.bind(this));
	} else {
		loadedModelDirs = [];
		callback && callback();
	}

};

/**
 * @method createLogger
 * Creates a logger instance.
 * @param {Object} config
 * @param {Object} opts Additional initialization options.
 * Refer to the [bunyan documentation](https://www.npmjs.com/package/bunyan).
 * @returns {Arrow.Logger}
 */
/**
 * @method createLogger
 * @static
 * Creates a logger instance.
 * @param {Object} config
 * @param {Object} opts Additional initialization options.
 * Refer to the [bunyan documentation](https://www.npmjs.com/package/bunyan).
 * @returns {Arrow.Logger}
 */
Arrow.prototype.createLogger =
	Arrow.createLogger = function createLogger(config, opts) {
		return Logger.createLogger(_.merge(config, opts));
	};

// create a continuation monkey patch in the case the server hasn't yet loaded
// and we've created a Model
function createModelClassContinuationPatch(Model) {
	if (globalArrow && !globalArrow.loaded) {
		// monkey patch any methods that must have a valid connector that is running before we can call it
		var methods = [
			'create', 'delete', 'replace', 'save', 'update', 'delete', 'deleteAll', 'find', 'findAll', 'findByID',
			'findById', 'findOne', 'fetch', 'query', 'remove', 'removeAll'
		];
		methods.forEach(function (fnName) {
			var ModelFn = Model[fnName];
			if (ModelFn) {
				Model[fnName] = createModelMethodMonkeyPatch(Model, ModelFn, fnName);
			}
		});

		// unwrap the methods after the arrow loads
		var builderLoader = function builderLoader() {
			var methods = [
				'create', 'delete', 'replace', 'save', 'update', 'delete', 'deleteAll', 'find', 'findAll', 'findByID',
				'findById', 'findOne', 'fetch', 'query', 'remove', 'removeAll'
			];
			methods.forEach(function (fnName) {
				if (Model[fnName] && Model[fnName].originalFunction) {
					Model[fnName] = Model[fnName].originalFunction;
				}
			});
			globalArrow.removeListener('loaded', builderLoader);
		};
		globalArrow.on('loaded', builderLoader);
	}
}

// create a function wrapper that will watch for the server to finish loading
// (which will have started the connectors) before we actually continue with the
// function. the method (fn) being passed in must be async for this to work
function createModelMethodMonkeyPatch(ModelClass, fn, name) {
	// if we're not yet loaded, we can't call methods against the
	// ModelClass. in which case we're going to wait until we're loaded
	// and then once loaded, we'll continue
	function modelMethodMonkeyPatched() {
		var args = arguments;
		var builderLoader = function builderLoader() {
			// make sure we resolve the connector to the real connector instance
			if (_.isString(ModelClass.connector)) {
				ModelClass.connector = Arrow.getConnector(ModelClass.connector);
			}
			globalArrow.removeListener('loaded', builderLoader);
			// re-patch it back to the original so subsequent doesn't come back through this block anymore
			ModelClass[name] = fn;
			// go ahead invoke
			return fn.apply(ModelClass, args);
		};
		// wait for loaded to fire
		if (globalArrow.loaded) {
			builderLoader();
		} else {
			globalArrow.on('loaded', builderLoader);
		}
	}

	modelMethodMonkeyPatched.originalFunction = fn;

	return modelMethodMonkeyPatched;
}

/*
 * monkey patch Model.extend to make sure that we set the instance of the
 * connector before returning
 */
var ModelExtend = Arrow.Model.extend;
var ModelReduce = Arrow.Model.reduce;

Arrow.Model.extend = createModelMonkeyPatch(ModelExtend, 'extend');
Arrow.Model.reduce = createModelMonkeyPatch(ModelReduce, 'reduce');

function createModelMonkeyPatch(ModelClass, method) {
	var createModel = function createModel() {
		// if we're extending a named model, resolve it first
		var model;
		if (arguments.length === 3) {
			// if we're in the middle of loading models on startup, we need to deal
			// with the case we are extending a model that has not been loaded yet,
			// in which case we want to record the dependency and then load later
			if (globalArrow && globalArrow.loadingModels) {
				var args = arguments,
					self = this,
					fn = function () {
						globalArrow.removeListener('loadedModels', fn);
						return createModel.apply(self, args);
					};
				return globalArrow.on('loadedModels', fn);
			}
			// tricky. we need to check to see if the incoming connector referenced by
			// the new model is referencing a connector that is disabled and if so, just
			// return null so that the model load just fails silently (which is OK)
			if (arguments[2].connector) {
				var connector = _.isString(arguments[2].connector) ? Arrow.getConnector(arguments[2].connector) : arguments[2].connector;
				if (connector && !connector.enabled) {
					var connectorName = connector.name || arguments[2].connector;
					globalArrow && globalArrow.logger.debug('connector (' + connectorName + ') disabled, skipping model', arguments[1]);
					return;
				}
			}
			var extendModel = _.isString(arguments[0]) ? Arrow.getModel(arguments[0], true) : arguments[0],
				name = arguments[1],
				def = arguments[2];
			model = extendModel[method](name, def);
			// we need to set in case it wasn't set. this happens in cases where we loaded async
			model.name = name;
			model._parent = extendModel;
			model._supermodel = extendModel.name;
			if (!model.connector) {
				model.connector = extendModel.connector;
			}
			// if the extended model is autogen (like a built-in connector model) but we didn't
			// specify one in our own definition, assume we want to autogen it
			if (!extendModel.autogen && def.autogen === undefined) {
				model.autogen = true;
			}
			// make sure we record it. this happens in the case we async load and we didn't put it in
			// because of that...
			if (!isModelDuplicate(model.name)) {
				globalArrow.models[model.name] = model;
			}
		} else {
			// else we're creating a simple new model
			model = ModelClass.apply(Arrow.Model, arguments);
			isModelDuplicate(model.name);
		}

		if (model.connector && _.isString(model.connector)) {
			// if we're running and we have a string, resolve it
			if (globalArrow && globalArrow.loaded) {
				model._connector = model.connector;
				model.connector = Arrow.getConnector(model.connector, true);
				model.connector.emit('init-model', model);
			} else {
				// we need to monkey patch to create continuation
				createModelClassContinuationPatch(model);
			}
		} else if (model.connector) {
			model.connector.emit('init-model', model);
		}

		return model;
	};
	return createModel;
}

/**
 * Creates a model class.
 * @static
 * @param {String} name Name of the new Model.
 * @param {ArrowModelDefinition} definition Model definition object.
 * @returns {Arrow.Model}
 */
Arrow.createModel = function _createModel() {
	return globalArrow.createModel.apply(globalArrow, arguments);
};

/**
 * @method createModel
 * @alias #static-method-createModel
 */
Arrow.prototype.createModel = Arrow.Model.extend;

/**
 * Adds a model class(es) on this instance.
 * @param {Arrow.Model/Array<Arrow.Model>} model Model class(es) to add.
 */
Arrow.prototype.addModel = function addModel(model) {
	for (var c = 0; c < arguments.length; c++) {
		var ModelClass = arguments[c];
		if (!isModelDuplicate(ModelClass.name)) {
			this.models[ModelClass.name] = ModelClass;
		}
		// Has the server already started?
		if (this.server) {
			var startAt = this.apis.length;
			this.createAPIsFromModel(ModelClass);
			for (var i = startAt; i < this.apis.length; i++) {
				this.apis[i].bind(this.app);
			}
		}
	}
};

/**
 * Gets a model by name.
 * @static
 * @param {String} name Name of the model to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the model could not be found.
 * @returns {Arrow.Model}
 * @throws Error
 */
Arrow.getModel = function _getModel() {
	return globalArrow && globalArrow.getModel.apply(globalArrow, arguments);
};

/**
 * @alias #static-method-getModel
 */
Arrow.prototype.getModel = function getModel(name, failIfMissing) {
	// in case you specify connector/appc.mysql/model - strip out the connector portion
	name = String(name || '').replace('connector/', '');
	var result = this.models[name];
	if (!result) {
		var tokens = name.split('/');
		if (tokens.length > 1) {
			var connectorName = tokens[0],
				modelName = tokens[1],
				connector = connectors[connectorName];
			if (!connector && failIfMissing) {
				throw new Error('Couldn\'t find connector named: ' + connectorName);
			}
			result = connector && connector.models && (connector.models[modelName] || connector.models[connectorName + '/' + modelName] || connector.models[connector.name + '/' + modelName]);
		}
	}
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find model named: ' + name);
	}
	return result;
};

/**
 * Gets an array of Arrow APIs available to the instance.
 * @returns {Array<Arrow.API>}
 */
Arrow.prototype.getAPIs = function getAPIs() {
	return this.apis;
};

/**
 * Returns an API for the given path and optional method in the case where more than one method.
 * may be invoked on a path. If you defined a nickname when creating the API instance, you may pass
 * the nickname to the function rather than the path and method.
 * @param {String} path Path of the API (or its nickname).
 * @param {String} [method] HTTP verb.
 * @returns {Arrow.API}
 */
Arrow.prototype.getAPI = function getAPI(path, method) {
	var pathAsRoute = path;
	if (path.substring(0, 1) !== '/') {
		pathAsRoute = '/' + path;
	}
	for (var c = 0; c < this.apis.length; c++) {
		if ((this.apis[c].path === pathAsRoute ||
			this.apis[c].nickname === path) && (!method || (method && this.apis[c].method.toUpperCase() === method.toUpperCase()))) {
			return this.apis[c];
		}
	}
};

/**
 * Adds an API on this instance.
 * @param {Arrow.API} api API to add.
 */
Arrow.prototype.addAPI = function addAPI(APIConstructor) {
	if (_.isFunction(APIConstructor)) {
		var api = new APIConstructor(this.config, this);
		this.apis.push(api);
	} else {
		this.apis.push(APIConstructor);
	}
};

/**
 * Gets all models availabe to the instance.
 * @returns {Array<Arrow.Model>}
 */
Arrow.prototype.getModels = function getModels() {
	return this.models;
};

/**
 * Gets a block by name.
 * @param {String} name Name of the block to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the block could not be found.
 * @returns {Arrow.Block}
 * @throws Error
 */
Arrow.prototype.getBlock = function getBlock(name, failIfMissing) {
	var result = this.blocks[name];
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find block named: ' + name);
	}
	return result;
};

/**
 * Gets a route by name.
 * @param {String} name Name of the route to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the route could not be found.
 * @returns {Arrow.Router}
 * @throws Error
 */
Arrow.prototype.getRoute = function getBlock(name, failIfMissing) {
	var result = _.findWhere(this.routes, {name: name});
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find route named: ' + name);
	}
	return result;
};

/**
 * Adds the block(s) on this instance.
 * @param {Arrow.Block/Array<Arrow.Block>} block Block(s) to add.
 */
Arrow.prototype.addBlock = function () {
	for (var c = 0; c < arguments.length; c++) {
		var Block = arguments[c];
		this.blocks[Block.name] = Block;
	}
};

/**
 * Gets all blocks.
 * @returns Array<Arrow.Block>
 */
Arrow.prototype.getBlocks = function getBlocks() {
	return this.blocks;
};

/**
 * Returns a registered connector by name.
 * @static
 * @param {String} name Name of the connector to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the connector could not be found.
 * @throws Error
 */
Arrow.getConnector = function _getConnector() {
	if (!globalArrow) {
		throw new Error('an Arrow instance has not yet been created');
	}
	return globalArrow.getConnector.apply(globalArrow, arguments);
};

/**
 * Gets a connector by name.
 * @param {String} name Name of the connector to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the connector could not be found.
 * @throws Error
 */
Arrow.prototype.getConnector = function getConnector(name, failIfMissing) {
	if (!name) {
		throw new Error('missing name');
	}
	// trim off in case you specific connector/appc.salesforce which is acceptable
	name = name.replace('connector/', '');
	var found = connectors[name],
		askedName = name;
	if (!found) {
		if (name === 'memory') {
			// use memory if not found and specified. this is nice for testing
			connectors[name] = found = new Arrow.MemoryConnector();
			return found;
		}
		var config = this.config || new Loader() || {};
		// see if this is a mapped connector and if so, lookup the real connector
		if (config.connectors && name in config.connectors) {
			config = config.connectors[name];
			name = config.connector || askedName;
			config = config.config || config;
			// Note: we don't grab the cached `connectors[name]` because we need our own instance.
		} else if (config.connectors) {
			// not found, let's see if we have a connector specified
			var connectorsFound = _.filter(_.values(config.connectors), function (entry) {
				return entry.connector && entry.connector === askedName;
			});
			if (connectorsFound.length > 1) {
				this.logger.warn('Found ' + connectorsFound.length + ' connector configurations for ' + askedName + '. ' +
					'Using the first one found. If this isn\'t the right connector, use the correct alias name to ' +
					'specify the right connector');
				connectorsFound = [connectorsFound[0]];
			}
			if (connectorsFound.length === 1) {
				name = connectorsFound[0].connector || askedName;
				config = connectorsFound[0].config || connectorsFound[0];
			}
		}
		try {
			var ConnectorFactory = paths.findComponent('connector', name);
			if (ConnectorFactory) {
				if (!ConnectorFactory.create) {
					throw new Error(name + ' must be updated to use the Connector Factory API.  See https://jira.appcelerator.org/browse/API-138');
				}
				// re-entrant flag in case a Connector inadvertently calls Arrow.loadModelsForConnector
				// during this ConnectorFactory.create which will cause us to re-enter this method into an
				// infinite recursion problem .. so we note and then do it again later if we have this happen
				inGetConnector = true;
				var Connector = ConnectorFactory.create(Arrow, this);
				inGetConnector = false;
				found = new Connector(config[name] || config || {});
				if (found) {
					found.name = askedName;
					connectors[askedName] = found;
					// if we have a post create lifecycle callback, call it
					// this will allow connectors to do things like call Arrow.loadModelsForConnector
					// after the connector is instantiated but before it is returned.  if we don't do this
					// we will get into an infinite loop where things done in the constructor (like load models)
					// that require the connector will attempt to re-instantiate the connector again (since it's not done registering)
					if (pendingModels) {
						found.models = Arrow.loadModelsForConnector(found.name, pendingModels.module, pendingModels.dir);
						pendingModels = null;
					}
					if (found.postCreate) {
						found.postCreate.call(found);
					}
				}
			}
		}
		catch (E) {
			this.logger.error('Error loading connector: ' + name, E);
			throw E;
		}
	}
	if (!found && name === 'memory') {
		// use memory if not found and specified. this is nice for testing
		connectors[name] = found = new Arrow.MemoryConnector();
	}
	if (!found && failIfMissing) {
		throw new Error('Couldn\'t find connector named: ' + name);
	}
	return found;
};

/**
 * @method getConnectors
 * Gets a list of registered connectors.
 * @static
 * @returns {Array<Arrow.Connector>}
 */
/**
 * @method getConnectors
 * @alias #static-method-getConnectors
 */
Arrow.getConnectors =
	Arrow.prototype.getConnectors = function getConnectors() {
		return connectors;
	};

/**
 * @method registerConnector
 * @static
 * Registers a connector.
 * @param {Arrow.Connector} connector Connector to register.
 */
/**
 * @method registerConnector
 * @alias #static-method-registerConnector
 */
Arrow.registerConnector =
	Arrow.prototype.registerConnector = function registerConnector(connector) {
		connectors[connector.name] = connector;

		// attach a get model convenience function on the connector
		if (!connector.getModel) {
			connector.getModel = function (name) {
				return this.models && (this.models[name] || this.models[this.name + '/' + name]);
			};
		}

		if (connector.models) {
			Object.keys(connector.models).forEach(function keyIterator(name) {
				var model = connector.models[name];
				// map to the real connector instance
				model.connector = connector;
			});
		}
	};

// listen for connectors that are being created
Connector.on('register', Arrow.registerConnector);

function loadModels(models, dir, connectorName) {
	if (loadedModelDirs.indexOf(dir) >= 0) {
		return;
	}
	loadedModelDirs.push(dir);
	fs.readdirSync(dir).forEach(function modelResolver(name) {
		var p = path.join(dir, name);
		if (fs.statSync(p).isDirectory()) {
			loadModels(models, p, connectorName);
		} else if (path.extname(p) === '.js' && path.basename(p).charAt(0) !== '_') {
			// only do .js files that don't start with _
			var model = paths.requireComponent(p);
			if (model && !(model.name in models)) {
				models[model.name] = model;
				globalArrow && (model.connector = Arrow.getConnector(connectorName));
				model.filename = p;
				globalArrow && globalArrow.addModel(model);
			} else {
				throw new Error('Model: ' + model.name + ' already exists in connector: ' + connectorName);
			}
		}
	});
}

/**
 * Removes a model from this instance.
 * @param {Arrow.Model} model Model to remove.
 */
Arrow.prototype.removeModel = function (model) {
	delete this.models[model.name];
};

/**
 * Removes a connector.
 * @param {Arrow.Connector} connector Connector to remove.
 */
Arrow.prototype.removeConnector = function (connector) {
	delete this.connectors[connector.name];
};

/**
 * Removes a block.
 * @param {Arrow.Block} block Block to remove.
 */
Arrow.prototype.removeBlock = function (block) {
	delete this.blocks[block.name];
};

/**
 * Removes an API.
 * @param {Arrow.API} api API to remove.
 */
Arrow.prototype.removeAPI = function (api) {
	for (var c = 0; c < this.apis.length; c++) {
		var a = this.apis[c];
		if (a === api) {
			this.apis.splice(c, 1);
			break;
		}
	}
	api.remove(this);
};

/**
 * Removes a route.
 * @param {Arrow.Router} route Route to remove.
 */
Arrow.prototype.removeRoute = function (route) {
	if (route) {
		for (var i = 0; i < this.routes.length; i++) {
			var currentRoute = this.routes[i];
			if (currentRoute === route) {
				this.routes.splice(i, 1);
				break;
			}
		}
		route.remove(this);
	}
};

/**
 * returns an arrow toJSON description
 */
Arrow.prototype.toJSON = function () {
	return '[object Arrow]';
};

/**
 * returns an util.inspect description
 */
Arrow.prototype.inspect = function () {
	return '[object Arrow]';
};

/**
 * Dynamically loads the models into the server if the connector updates them dynamically
 * (i.e. after connect has run and started);
 */
Arrow.prototype.registerModelsForConnector = function registerModelsForConnector(connector, models) {
	if (!models || !_.isObject(models)) {
		throw new Error('Invalid argument passed to registerModelsForConnector: connector/' + connector.name + '; models must be an object.');
	}
	Object.keys(models).forEach(function (name) {
		var Model = models[name];
		if (Model.visible || Model.visible === undefined) {
			this.models[name] = Model;
		}
		if (Model.documented === undefined && connector.config.documented !== undefined) {
			Model.documented = connector.config.documented;
		}
	}.bind(this));
};

/**
 * Called by a connector to attempt to load any connector bundled models.
 * @param {String} connectorName Name of the connector.
 * @param {Object} module Connector module instance.
 * @param {String} dir Directory of the connector's models. Default is the connector's models folder.
 */
Arrow.loadModelsForConnector = function loadModelsForConnector(connectorName, module, dir) {
	if (inGetConnector) {
		// handle re-entrant issue with ConnectorFactory that calls this during
		// instantiation if we're still loading. will cause us to do this after its done
		pendingModels = {module: module, dir: dir};
		return;
	}
	var modelsDir = path.resolve(dir || path.join(path.dirname(path.dirname(module.filename)), 'models'));

	// attempt to load any models packaged with the connector
	if (fs.existsSync(modelsDir)) {
		var models = {};
		loadModels(models, modelsDir, connectorName);
		return models;
	}
};

// map helper functions
Arrow.pluralize = function doPluralize(name) {
	return pluralize(name);
};

Arrow.singularize = function doSingularize(name) {
	return pluralize(name, 1);
};

function createRequestTransaction(config) {
	var logging = config.logging || {},
		prefix = config.prefix,
		enabled = logging.transactionLogEnabled === undefined || logging.transactionLogEnabled;
	return function requestTx(req, resp, next) {
		// handle serialization to the log so that we only dump a subset of the object
		req.inspect = function () {
			return '[object Request]';
		};
		req.toJSON = function () {
			return req.log.serializers.req(req);
		};
		resp.inspect = function () {
			return '[object Response]';
		};
		resp.toJSON = function () {
			return req.log.serializers.res(resp);
		};
		if (!req.url || (req.url && req.url.indexOf(prefix) === 0) || !enabled) {
			req.logmetadata = false;
			return next();
		}
		req.tx = new RequestTx(req, resp, prefix);
		next();
	};
}

/**
 * called at the end of a request once it's done sending
 */
function endRequestTransaction(req, resp) {
	if (req.pendingReqCount) {
		pendingRequests--;
		if (pendingRequests < 0) { pendingRequests = 0; }
		req.pendingReqCount = null;
		var logger = req.server.logger;
		// always fire since this also handles request logger in addition to transaction logger
		this.emit('txdone', req, resp);
		if (req.tx) {
			req.tx.done();
			req.tx = null;
		} else if (req.cleanStream) {
			req.cleanStream();
			req.cleanStream = null;
		}
		// if no pending requests and we haven't do a GC in awhile, let's attempt to GC if
		// our heap usage is >1M
		if (memwatch && pendingRequests === 0 && (Date.now() - lastGCCheck) > 60000) {
			lastGCCheck = Date.now();
			var heapUsed = process.memoryUsage().heapUsed / 1024;
			if (heapUsed > 1000000) {
				(logger.debug || consoleLog)('triggering gc, heap usage', heapUsed + 'k');
				memwatch.gc();
			}
		}
	}
}

// shutdown all servers and then exit
function shutdownAllServers(exitCode, dontexit) {
	if (stopping) { return; }
	stopping = true;
	exitCode = exitCode === undefined ? 0 : exitCode;
	async.each(servers, function (server, cb) {
		server.stop(cb);
	}, function () {
		stopping = false;
		if (dontexit) { return; }
		process.exit(exitCode);
	});
}

// restart all servers by first stopping and then restarting them
function restartAllServers() {
	if (stopping) { return; }
	async.each(servers, function (server, cb) {
		server.pendingReload = true;
		server.loaded = false;
		server.stop(function (err) {
			if (err) { return cb(err); }
			stopping = false;
			pendingRequests = 0;
			server.pendingReload = false;
			server.start(function (err) {
				server.loaded = true;
				cb(err);
			});
		});
	});
}

// if not in production, remove our local logs on each shutdown
if (!inProduction) {
	debug('removing temporary log directory when in development on startup');
	process.on('exit', function (ec) {
		try {
			var wrench = require('wrench'),
				path = require('path'),
				fs = require('fs'),
				logdir = Logger.arrowCloudLogDir || path.join((globalArrow && globalArrow.config.dir) || process.cwd(), 'logs');
			if (fs.existsSync(logdir)) {
				try {
					wrench.rmdirSyncRecursive(logdir);
				}
				catch (E) {
					// ignore any errors
				}
			}
		}
		catch (E) {
		}
		cluster.isMaster && process.exit(ec);
	});
}

// normal shutdown type signals
// for now, we're going to ignore SIGHUP since that can be sent on terminal
// disconnect or backgrounding
// we only use this when we're not in cluster mode. otherwise, let the cluster handle below
// if we are in master, assume that we aren't running with cluster (such as unit tests)
if (cluster.isMaster || cluster.isWorker) {
	['exit', 'SIGINT', 'SIGTERM', 'SIGQUIT'].forEach(function (name) {
		process.on(name, shutdownAllServers);
	});

	// restart if we receive the SIGUSR2 signal
	process.on('SIGUSR2', function () {
		consoleLog('arrow.js: signal received SIGUSR2 restarting');
		restartAllServers();
	});
}

// on SIGABRT we are going to send an abort which should core on *nix platforms
process.on('SIGABRT', function () {
	shutdownAllServers(0, true);
	process.abort();
});

// monitor any unhandled exceptions
process.on('uncaughtException', function (error) {
	if (_.isObject(error)) {
		consoleLog('Uncaught Exception', error.message);
		try {
			error.stack && consoleLog(error.stack);
		}
		catch (E) {
		}
	} else {
		consoleLog('Uncaught Exception', error);
	}
	// if we get an unhandled exception we need to crash the process
	process.exit(1);
});

// monitor any memory leaks
memwatch && memwatch.on('leak', function (info) {
	consoleLog('memory leak detected', info);
});

if (cluster.isWorker) {
	// monitor any cluster messages
	process.on('message', function (msg) {
		/* jshint ignore:start */
		switch (msg) {
			case 'shutdown':
				return shutdownAllServers();
			case 'restart':
				return restartAllServers();
			default:
				break;
		}
		/* jshint ignore:end */
	});

}
