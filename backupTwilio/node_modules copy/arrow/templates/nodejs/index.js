/**
 * Code generated by Appcelerator Arrow Generator
 * 
 * <%= pkg.name %>
 *
 * Copyright (c) <%= new Date().getFullYear() %> Appcelerator, Inc.
 *
 * WARNING: This is generated code. Any changes will be overwritten
 * if you re-run the generator on this file.
 */
/* global encodeURIComponent: true */
/* jshint strict: true */
"use strict";
var events = require('events'),
	util = require('util'),
	urllib = require('url'),
	tty = require('tty'),
	querystring = require('querystring'),
	stream = require('stream'),
	useColors = tty.isatty(process.stderr),
	debugEnabled = !!(process.env.DEBUG && process.env.DEBUG.indexOf('arrow:sdk')!==-1),
	request;

// try and find a reasonable request library. these are all compatible.
// do them in preference order
(function() {
	var libs = ['appc-request-ssl','request-ssl','request'],
		dir = __dirname,
		fs = require('fs'),
		path = require('path'),
		rootdir = path.resolve('/');

	while (fs.existsSync(dir)) {
		var found = false;
		for (var c=0;c<libs.length;c++) {
			var nmd = path.join(dir, 'node_modules', libs[c]);
			if (fs.existsSync(nmd)) {
				try {
					request = require(nmd);
					found = true;
					break;
				}
				catch (E) {
				}
			}
		}
		if (found || dir===rootdir) { break; }
		dir = path.resolve(path.join(dir, '..'));
	}
})();

if (!request) {
	throw new Error('Can\'t find a suitable request library');
}

// APIs defined by Arrow API
var APIs = <%- JSON.stringify(apis,null,'\t') %>;

/**
 * Constructor for creating an API endpoint
 * @class
 * @classdesc API endpoint
 */
function API(config, key, method) {
	if (config && typeof(config)==='string') {
		method = key;
		key = config;
		config = {};
	}
	var api;
	method = (method || 'GET').toUpperCase();
	if (key) {
		api = APIs[method+' '+key];
	}
	if (!api && key && !method && (key in APIs)) {
		api = APIs[key];
	} else {
		var apis = Object.keys(APIs);
		for (var c=0;c<apis.length;c++) {
			var name = apis[c],
				obj = APIs[name];
			if (obj.nickname === key && method === obj.method) {
				api = obj;
				break;
			}
		}
	}
	if (api) {
		this._config = config;
		this._path = api.path;
		var self = this;
		Object.keys(api).forEach(function(key){
			self[key] = api[key];
		});
		if (config.debug) {
			debugEnabled = true;
		}
	} else {
		throw new Error('couldn\'t find API using name '+key+' and method '+method);
	}
}

util.inherits(API, events.EventEmitter);

/**
 * adapter to creating the Request object. subclass to
 * change the options passed to request or to use a different
 * request library implementation
 */
API.prototype.createRequest = function() {
	return request.apply(request, arguments);
};

/**
 * adapter called when receiving the response before processing.
 * subclasses can override to change the behavior of the result
 * before it's processed
 */
API.prototype.handleResult = function(err,resp,body) {
	return {
		error: err,
		response: resp,
		body: body
	};
};

/**
 * used internally to debug log
 * a few bites of code borrowed from npm debug library @ https://github.com/visionmedia/debug
 */
function debug() {
	if (!debugEnabled) { return; }
	var args = Array.prototype.slice.call(arguments);
	if (useColors) {
		var msg = '\u001b[91m' + 'arrow:sdk' + '\u001b[0m ';
		process.stderr.write(msg);
	}
	if ('string' !== typeof args[0]) {
		// anything else let's inspect with %o
		args = ['%o'].concat(args);
	}
	var index = 0;
	args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
		if (match === '%%') { return match; }
		index++;
		if (format === 'o') {
			match = util.inspect(args[index],{colors:useColors,depth:null});
			args.splice(index, 1);
			index--;
		}
		return match;
	});
	process.stderr.write(util.format.apply(util.format,args));
	process.stderr.write('\n');
}

/**
 * set the request body
 *
 * @param {Object} data of key/value parameters
 */
API.prototype.body = function(data) {
	this._body = data;
	return this;
};

/**
 * set the request body as JSON
 *
 * @param {Object} data of key/value parameters
 */
API.prototype.json = function(data) {
	this._json = data;
	return this;
};

/**
 * set the request path parameters as JSON key/values
 *
 * @param {Object} data of key/value parameters
 */
API.prototype.params = function(data) {
	this._params = data;
	return this;
};

/**
 * set the request query parameters
 *
 * @param {Object} data of key/value parameters
 */
API.prototype.query = function(data) {
	this._query = data;
	return this;
};

/**
 * set a request header
 * 
 * @param {String} name header name
 * @param {String} value header value
 */
API.prototype.header = function(name, value) {
	this._headers = this._headers || {};
	this._headers[name] = value;
	return this;
};

/**
 * send the request
 * 
 * @param {Object} data optional data to pass as JSON
 * @param {Function} callback optional function to invoke on response
 */
API.prototype.send = function(data, callback) {
	
	if (data && typeof(data)==='function') {
		callback = data;
		data = null;
	}
	
	if (data && typeof(data)==='object') {
		this._json(data);
	}

	var self = this,
		path = this._path,
		error,
		errorRaised,
		listeners;

<% if (securityCode) { 
	var code = securityCode('API', objectModel, sdktype, 'self');
%>
	// security model code
	<%- code.split('\n').join('\n\t') %>
<% } -%>

	// build any path parameters
	if (this.pathParameters) {
		var values = [];
		for (var c=0;c<this.pathParameters.length;c++) {
			var name = this.pathParameters[c];
			var param = self.parameters[name];
			var value = self._params && self._params[name] || self._json && self._json[name] || self._body && self._body[name];
			if (!value && !param.optional) {
				error = new Error('missing required path parameter \''+name+'"');
				error.code = 'com.appcelerator.arrow.missing.path.parameter';
				error.parameter = name;
				listeners = self.listeners('error');
				// if we have at least one error listener, emit an event
				if (listeners && listeners.length) {
					return this.emit('error',error);
				}
				// we don't have an event listener, throw an Error instead
				throw error;
			} else if (value) {
				// remove them so they don't get added again since they are path parameters
				if (self._json) { delete self._json[name]; }
				if (self._body) { delete self._body[name]; }
				if (self._params) { delete self._params[name]; }
			} else if (!value && param.optional) {
				break;
			}
			values.push(value);
		}
		// append our path parameter values
		path += '/' + values.map(function(value){
			return encodeURIComponent(value||'');
		}).join('/');
	}

	// append any query parameters
	if (this._query && Object.keys(this._query).length) {
		path += '?' + querystring.stringify(this._query);
	}

	// make sure our base url was set
	var baseurl = this._config && this._config.baseurl || this.baseurl || API.baseurl;
	if (!baseurl) {
		error = new Error('baseurl not set.');
		error.code = 'com.appcelerator.arrow.baseurl.missing';
		listeners = this.listeners('error');
		// if we have at least one error listener, emit an event
		if (listeners && listeners.length) {
			return this.emit('error',error);
		}
		// we don't have an event listener, throw an Error instead
		throw error;
	}

	var url = urllib.resolve(baseurl, path),
		opts = {
			url: url,
			method: this.method,
			json: this._json,
			followAllRedirects: true,
			headers: {
				'Accept': 'application/json',
				'User-Agent': 'Appcelerator Arrow SDK/1.0.0'
			}
		};

	// set any headers specified
	if (this._headers) {
		Object.keys(this._headers).forEach(function(key){
			opts.headers[key] = self._headers[key];
		});
	}

	// do a first pass to determine if we can send as JSON or if we
	// need to send a multipart
	if (this._body && typeof(this._body)==='object' && !this._json) {
		var multipart = false,
			keys = Object.keys(this._body);
		for (var i=0;i<keys.length;i++) {
			var bodyValue = this._body[keys[i]],
				bodyType = typeof(bodyValue);
			if (bodyType === 'object' && (bodyValue instanceof Buffer || bodyValue instanceof stream)) {
				multipart = true;
				break;
			}
		}
		if (!multipart) {
			opts.json = this._body;
			this._body = null;
		}
	}

	debug('sending request to %s',url);

	try {
		// create the request
		var req = this.createRequest(opts, function(err,resp,body) {

			var result = self.handleResult(err,resp,body);
			if (!result || typeof(result)!=='object') {
				throw new Error('handleResult subclass didn\'t properly return the right result');
			}

			// handle transform
			err = result.error;
			resp = result.response;
			body = result.body;

			debug('response received err=%o, body=%o, status code=%d',err,body,resp && resp.statusCode);

			if (err) {
				error = err;
				error.code = 'com.appcelerator.arrow.error';
			}

			if (!error && body && typeof(body)==='string' && resp.headers && resp.headers['content-type'].indexOf('/json') > 0) {
				try {
					body = JSON.parse(body);
				}
				catch (E) {
					error = E;
					error.code = 'com.appcelerator.arrow.error.json';
					return self.emit('error',error);
				}
			}

			if (!error && resp.statusCode > 399) {
				var http = require('http');
				error = new Error(http.STATUS_CODES[resp.statusCode]);
				error.code = 'com.appcelerator.arrow.http.status.'+resp.statusCode;
			}

			// check to see if it failed
			if (body && !body.success) {
				error = new Error(body.message || body);
				error.code = body.code;
			}
			// check to see if it succeeded
			else if (body && body.success) {
				body = body[body.key];
			}

			// if specifying a callback, just invoke it directly
			if (callback) {
				if (error) {
					errorRaised = true;
				}
				callback(error, resp, body);
			}
			// otherwise emit the appropriate event
			else {
				if (error) {
					debug(error);
					errorRaised = true;
					self.emit('error', error);
				} else {
					self.emit('response', resp, body);
				}
			}
		});

		// handle error
		req.on('error',function(err){
			if (!errorRaised) {
				errorRaised = true;
				error = err;
				error.code = 'com.appcelerator.arrow.error';
				debug(error);
				self.emit('error',error);
			}
		});

		// handle timeout
		req.on('timeout',function(){
			if (!errorRaised) {
				errorRaised = true;
				error = new Error('timed out');
				error.code = 'com.appcelerator.arrow.timeout';
				debug(error);
				self.emit('error',error);
			}
		});

		// append any body parameters
		if (this._body && typeof(this._body)==='object') {
			var form = req.form();
			Object.keys(this._body).forEach(function(name){
				var bodyValue = self._body[name],
					bodyType = typeof(bodyValue);
				if (bodyType === 'object') {
					// check to see if this is a buffer
					if (bodyValue instanceof Buffer) {
						var bufferStream = new stream.Transform();
						bufferStream.push(bodyValue);
						form.append(name, bufferStream);
					} else if (bodyValue instanceof stream) {
						form.append(name, bodyValue);
					} else {
						form.append(name, JSON.stringify(bodyValue));
					}
				} else {
					form.append(name, String(bodyValue));
				}
			});
		}
		return req;
	}
	catch (E) {
		if (!errorRaised) {
			errorRaised = true;
			listeners = self.listeners('error');
			// if we have at least one error listener, emit an event
			if (listeners && listeners.length) {
				return this.emit('error',E);
			} else if (callback) {
				return callback(E);
			}
			throw E;
		}
	}
};

/**
 * enable debug logging
 */
Object.defineProperty(API,'debug',{
	set: function(value) {
		debugEnabled = value;
	},
	get: function() {
		return debugEnabled;
	}
});

module.exports = API;
