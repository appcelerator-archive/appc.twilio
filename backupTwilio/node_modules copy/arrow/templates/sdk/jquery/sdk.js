/** filename: {{&sdkname}}.js **/
(function (context) {
	var config = {
		headers: {},
		timeout: 30000,
		domain: '{{&domain}}',
		port: 0
	};
	
	var ns = {};

	var NoCache = 1,
		CacheElseNetwork = 2,
		NetworkElseCache = 4,
		CacheThenNetwork = 8,
		CacheOnly = 16,
		NetworkOnly = 32;

	var Base64 = {_keyStr:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",encode:function(e){var t="";var n,r,i,s,o,u,a;var f=0;e=Base64._utf8_encode(e);while(f<e.length){n=e.charCodeAt(f++);r=e.charCodeAt(f++);i=e.charCodeAt(f++);s=n>>2;o=(n&3)<<4|r>>4;u=(r&15)<<2|i>>6;a=i&63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+this._keyStr.charAt(s)+this._keyStr.charAt(o)+this._keyStr.charAt(u)+this._keyStr.charAt(a)}return t},decode:function(e){var t="";var n,r,i;var s,o,u,a;var f=0;e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");while(f<e.length){s=this._keyStr.indexOf(e.charAt(f++));o=this._keyStr.indexOf(e.charAt(f++));u=this._keyStr.indexOf(e.charAt(f++));a=this._keyStr.indexOf(e.charAt(f++));n=s<<2|o>>4;r=(o&15)<<4|u>>2;i=(u&3)<<6|a;t=t+String.fromCharCode(n);if(u!=64){t=t+String.fromCharCode(r)}if(a!=64){t=t+String.fromCharCode(i)}}t=Base64._utf8_decode(t);return t},_utf8_encode:function(e){e=e.replace(/\r\n/g,"\n");var t="";for(var n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r)}else if(r>127&&r<2048){t+=String.fromCharCode(r>>6|192);t+=String.fromCharCode(r&63|128)}else{t+=String.fromCharCode(r>>12|224);t+=String.fromCharCode(r>>6&63|128);t+=String.fromCharCode(r&63|128)}}return t},_utf8_decode:function(e){var t="";var n=0;var r=c1=c2=0;while(n<e.length){r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r);n++}else if(r>191&&r<224){c2=e.charCodeAt(n+1);t+=String.fromCharCode((r&31)<<6|c2&63);n+=2}else{c2=e.charCodeAt(n+1);c3=e.charCodeAt(n+2);t+=String.fromCharCode((r&15)<<12|(c2&63)<<6|c3&63);n+=3}}return t}};

	var SDK = context['{{&sdkname}}'] = {
		/*
		 Public API.
		 */
		getModel: function (name, failIfMissing) {
			name = String(name || '').replace('connector/', '');
			var result = this.models[name];
			if (!result) {
				for (var modelName in this.models) {
					if (this.models.hasOwnProperty(modelName) && name === modelName.split('/').pop()) {
						result = this.models[modelName];
						break;
					}
				}
			}
			if (!result && failIfMissing) {
				throw new Error('Couldn\'t find model named: ' + name);
			}
			return result;
		},
		getAPI: function (pathOrNickname, method) {
			for (var i = 0; i < this.apis.length; i++) {
				var API = this.apis[i];
				if (1 === arguments.length) {
					if (API.nickname === pathOrNickname) {
						return API;
					}
				}
				else {
					if (API.path === pathOrNickname && API.method === method) {
						return API;
					}
				}
			}
			return null;
		},

		/*
		 Constants.
		 */
		Policy: {
			/**
			 * No caches are used or saved. This is the default caching policy for models.
			 */
			NoCache: 1,
			/**
			 * If a local cache of the results is available, it will be used; otherwise, the network will be used. Results will
			 * be cached.
			 */
			CacheElseNetwork: 2,
			/**
			 * If the network is available, it will be used for results; otherwise, the local cache will be used. Results will
			 * be cached.
			 */
			NetworkElseCache: 4,
			/**
			 * If a local cache of the result is available, it will be used immediately, and then the network will be used. The
			 * callback will, thus, be called twice. Results will be cached.
			 */
			CacheThenNetwork: 8,
			/**
			 * If a local cache of results is available, it will be used.
			 */
			CacheOnly: 16,
			/**
			 * If the network is available, it will be used for results. Results will be cached.
			 */
			NetworkOnly: 32
		},
		
		/*
		 Configuration.
		 */
		cachePolicy: {type: NoCache},
		getDomain: function () { return config.domain; },
		setDomain: function (newValue) { config.domain = newValue; },
		getPort: function () { return config.port; },
		setPort: function (newValue) { config.port = newValue; },
		getTimeout: function () { return config.timeout; },
		setTimeout: function (newValue) { config.timeout = newValue; },
		// TODO: What about other authentication strategies?
		getAPIKey: function () { return config.headers.APIKey; },
		setAPIKey: function (newValue) { config.headers.APIKey = newValue; },
		getAuthorization: function () { return config.headers.Authorization; },
		setAuthorization: function (newValue) {
			if (0 === newValue.indexOf('Basic ')) {
				config.headers.Authorization = newValue;
			}
			else if (':' === newValue.slice(-1)) {
				config.headers.Authorization = 'Basic ' + Base64.encode(newValue);
			}
			else {
				config.headers.Authorization = 'Basic ' + Base64.encode(newValue + ':');
			}
		},
		{{&securityPluginCode}}
	
		/*
		 Definitions.
		 */
		models: {
			{{#models}}
			'{{&name}}': {
				{{#endpoints}}
				'{{&describes}}': {{> endpoint.js}}{{^endpointIsLast}},{{/endpointIsLast}}
				{{/endpoints}}
			}{{^isLast}},{{/isLast}}
			{{/models}}
		},
		apis: [
			{{#apis}}
			{
				nickname: '{{&nickname}}',
				path: '{{&path}}',
				method: '{{&method}}',
				execute: {{> endpoint.js}}
			}{{^isLast}},{{/isLast}}
			{{/apis}}
		],

		/*
		 Utility.
		 */

		/**
		 * Turns a url and method in to a hash that can uniquely and securely identify it.
		 */
		getCacheHash: function getCacheHash(method, url) {
			var key = method + ':' + url + '\n';
			// Add headers.
			for (var headerName in config.headers) {
				if (config.headers.hasOwnProperty(headerName)) {
					key += headerName + ':' + config.headers[headerName] + '\n';
				}
			}
			return ns.md5(key);
		},

		/**
		 * Gets the cache db, ensuring it has the proper schema set up.
		 * @returns {Window}
		 */
		getCacheDB: function () {
			if (this.cacheDB) {
				return this.cacheDB;
			}
			// TODO: Back this with local storage.
			this.cacheDB = new ns.LRUCache();
			return this.cacheDB;
		},
		/**
		 * Checks the cache to see if results have been cached for the specific request.
		 * @param hash A string that uniquely identifies the request.
		 * @returns The cached results, or undefined.
		 */
		readCache: function (hash) {
			return this.getCacheDB().get(hash);
		},
		/**
		 * 
		 * @param hash
		 * @param duration
		 * @param results
		 */
		writeCache: function (hash, duration, results) {
			return this.getCacheDB().set(hash, results, duration);
		}
	};

	var defineProperty = (typeof Object.defineProperty == 'function');
	if (defineProperty) {
		var properties = [ 'Domain', 'Port', 'Timeout', 'Authorization' ];
		for (var i = 0; i < properties.length; i++) {
			var property = properties[i];
			Object.defineProperty(SDK, property[0].toLowerCase() + property.slice(1), {
				get: SDK['get' + property],
				set: SDK['set' + property],
				enumerable: true,
				configurable: false
			});
		}
		Object.defineProperty(SDK, 'apiKey', {
			get: SDK.getAPIKey,
			set: SDK.setAPIKey,
			enumerable: true,
			configurable: false
		});
	}

	function isFunction(val) {
		return 'function' === typeof val;
	}

	function appendQuery(url, query) {
		for (var queryName in query) {
			if (query.hasOwnProperty(queryName)) {
				url += (url.indexOf('?') === -1 ? '?' : '&') + queryName;
				if (query[queryName] !== '') {
					url += '=' + encodeURIComponent(query[queryName]);
				}
			}
		}
		return url;
	}

	function getURL(path) {
		var url = config.domain;
		if (config.port && config.port !== 80) {
			url += ':' + config.port;
		}
		url += path;
		return url;
	}
	
	{{> lru-cache.js}}
	{{> md5.js}}
})(this);