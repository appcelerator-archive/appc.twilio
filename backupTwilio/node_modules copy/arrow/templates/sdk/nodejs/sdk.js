/** filename: {{&sdkname}}/index.js **/
var request = require('request'),
	LRUCache = require('lru-cache');

/*
 Configuration.
 */
var config = {
	headers: {},
	timeout: 30000,
	domain: '{{&domain}}',
	port: 0
};

var NoCache = 1,
	CacheElseNetwork = 2,
	NetworkElseCache = 4,
	CacheThenNetwork = 8,
	CacheOnly = 16,
	NetworkOnly = 32;

module.exports = {
	/*
	 Public API.
	 */
	getModel: getModel,
	getAPI: getAPI,
	isFunction: isFunction,
	appendQuery: appendQuery,
	constructHTTP: constructHTTP,
	getURL: getURL,

	/*
	 Constants.
	 */
	Policy: {
		/**
		 * No caches are used or saved. This is the default caching policy for models.
		 */
		NoCache: 1,
		/**
		 * If a local cache of the results is available, it will be used; otherwise, the network will be used. Results will
		 * be cached.
		 */
		CacheElseNetwork: 2,
		/**
		 * If the network is available, it will be used for results; otherwise, the local cache will be used. Results will
		 * be cached.
		 */
		NetworkElseCache: 4,
		/**
		 * If a local cache of the result is available, it will be used immediately, and then the network will be used. The
		 * callback will, thus, be called twice. Results will be cached.
		 */
		CacheThenNetwork: 8,
		/**
		 * If a local cache of results is available, it will be used.
		 */
		CacheOnly: 16,
		/**
		 * If the network is available, it will be used for results. Results will be cached.
		 */
		NetworkOnly: 32
	},

	/*
	 Configuration.
	 */
	cachePolicy: {type: NoCache},
	get domain() { return config.domain; },
	set domain(val) { config.domain = val; },
	get port() { return config.port; },
	set port(val) { config.port = val; },
	get timeout() { return config.timeout; },
	set timeout(val) { config.timeout = val; },
	get APIKey() { return config.APIKey; },
	set APIKey(val) {
		config.APIKey = val;
		config.headers.APIKey = val;
	},
	get Authorization() { return config.Authorization; },
	set Authorization(val) {
		config.Authorization = val;
		if (0 === val.indexOf('Basic ')) {
			config.headers.Authorization = val;
		}
		else if (':' === val.slice(-1)) {
			config.headers.Authorization = 'Basic ' + new Buffer(val).toString('base64');
		}
		else {
			config.headers.Authorization = 'Basic ' + new Buffer(val + ':').toString('base64');
		}
	},
	{{&securityPluginCode}}
	/*
	 Definitions.
	 */
	models: {
		{{#models}}
		'{{&name}}': require('./models/{{&safeName}}'){{^isLast}},{{/isLast}}
		{{/models}}
	},
	apis: [
		{{#apis}}
		require('./apis/{{&safeName}}'){{^isLast}},{{/isLast}}
		{{/apis}}
	],

	/*
	 Utility.
	 */

	/**
	 * Turns a url and method in to a hash that can uniquely and securely identify it.
	 */
	getCacheHash: function getCacheHash(method, url) {
		var key = method + ':' + url + '\n';
		// Add headers.
		for (var headerName in config.headers) {
			if (config.headers.hasOwnProperty(headerName)) {
				key += headerName + ':' + config.headers[headerName] + '\n';
			}
		}
		return require('crypto').createHash('md5').update(key).digest('hex');
	},

	/**
	 * Gets the cache db, ensuring it has the proper schema set up.
	 * @returns {Window}
	 */
	getCacheDB: function () {
		if (this.cacheDB) {
			return this.cacheDB;
		}
		this.cacheDB = new LRUCache();
		return this.cacheDB;
	},
	/**
	 * Checks the cache to see if results have been cached for the specific request.
	 * @param hash A string that uniquely identifies the request.
	 * @returns The cached results, or undefined.
	 */
	readCache: function (hash) {
		return this.getCacheDB().get(hash);
	},
	/**
	 * 
	 * @param hash
	 * @param duration
	 * @param results
	 */
	writeCache: function (hash, duration, results) {
		return this.getCacheDB().set(hash, results, duration);
	}
};

/*
 Implementation.
 */

function getModel(name, failIfMissing) {
	name = String(name || '').replace('connector/', '');
	var result = this.models[name];
	if (!result) {
		for (var modelName in this.models) {
			if (this.models.hasOwnProperty(modelName) && name === modelName.split('/').pop()) {
				result = this.models[modelName];
				break;
			}
		}
	}
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find model named: ' + name);
	}
	return result;
}

function getAPI(pathOrNickname, method) {
	for (var i = 0; i < this.apis.length; i++) {
		var API = this.apis[i];
		if (1 === arguments.length) {
			if (API.nickname === pathOrNickname) {
				return API;
			}
		}
		else {
			if (API.path === pathOrNickname && API.method === method) {
				return API;
			}
		}
	}
	return null;
}

function isFunction(val) {
	return 'function' === typeof val;
}

function appendQuery(url, query) {
	for (var queryName in query) {
		if (query.hasOwnProperty(queryName)) {
			url += (url.indexOf('?') === -1 ? '?' : '&') + queryName;
			if ('' !== query[queryName]) {
				url += '=' + encodeURIComponent(query[queryName]);
			}
		}
	}
	return url;
}

function constructHTTP(method, url, onLoad, body) {
	return request({
		url: url,
		method: method,
		headers: config.headers,
		timeout: config.timeout,
		json: true,
		body: body
	}, onLoad);
}

function getURL(path) {
	var url = config.domain;
	if (config.port && config.port !== 80) {
		url += ':' + config.port;
	}
	url += path;
	return url;
}