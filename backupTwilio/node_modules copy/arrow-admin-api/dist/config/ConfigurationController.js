'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint no-unused-expressions:0 */
/* eslint no-shadow:0 */
var fs = require('fs');
var path = require('path');
var walk = require('walk');
var ServerConfiguration = require('./ServerConfiguration');
var NotFoundError = require('../errors/NotFoundError');
var BadRequestError = require('../errors/BadRequestError');

var ENV_TYPES = ['default', 'local', 'development', 'preproduction', 'preprodonprod', 'test', 'production', 'production-eu', 'platform-axway'];

var ENV_MAP = {
	local: ['default', 'local', 'dev', 'development'],
	development: ['default', 'local', 'dev', 'development'],
	preproduction: ['default', 'test', 'prod', 'production', 'preprod', 'preproduction'],
	preprodonprod: ['default', 'preprodonprod'],
	test: ['default', 'dev', 'development', 'preprod', 'preproduction', 'test', 'prod', 'production'],
	production: ['default', 'prod', 'production'],
	'production-eu': ['default', 'prod-eu', 'production-eu'],
	'platform-axway': ['default', 'platform-axway']
};

var UNKNOWN_ENV = 'other';

/**
 * The controller implementing the actions for interacting with the server configuration..
 * @public
 */

var ConfigurationController = function () {
	/**
  * Create a ConfigurationController.
  * @param {object} ctx - The context for this controller.
  * @param {express} ctx.app - The express application.
  * @param {string} ctx.prefix - The prefix bound to.
  * @param {Arrow} ctx.arrow - The Arrow server.
  * @param {boolean} ctx.devmode - Flag indicating if this is a devmode server.
  * @param {Swagger} ctx.swagger - openapi-doc instance.
  */
	function ConfigurationController(ctx) {
		_classCallCheck(this, ConfigurationController);

		this.ctx = ctx;
		this.confDir = path.resolve(path.join(this.ctx.arrow.config.dir || process.cwd(), 'conf'));
	}

	/**
 * Sanitize name and resolve it as a child of the configuration directory.
 * @param {string} name - The configuration file name to resolve to a path.
 * @return {string} path - The configuration file path.
 * @private
 */


	_createClass(ConfigurationController, [{
		key: 'safeFilename',
		value: function safeFilename(name) {
			return path.relative(path.sep, path.join(path.sep, name));
		}

		/**
  * Check if the file exists and is readable.
  * @param {string} filepath - The configuration file path.
  * @return {Promise} promise - A promise that will resolve with true or false to indicate acccess..
  * @private
  */

	}, {
		key: 'checkAccess',
		value: function checkAccess(filepath) {
			return new Promise(function (resolve, reject) {
				fs.stat(filepath, function (err, stats) {
					if (err) {
						reject(err);
					} else {
						resolve(stats.isFile());
					}
				});
			}).then(function () {
				return new Promise(function (resolve) {
					fs.access(filepath, fs.constants ? fs.constants.R_OK : fs.R_OK, function (hasAccess) {
						return resolve(!hasAccess);
					});
				});
			});
		}

		/**
   * Get the specified configuration file.
   * @param {string} name - The configuration file name.
   * @return {Promise} - Resolves with the file name and content.
   * @private
   */

	}, {
		key: 'readConfigFile',
		value: function readConfigFile(name) {
			var safeName = this.safeFilename(name);
			var filepath = path.join(this.confDir, safeName);

			return this.checkAccess(filepath).then(function (hasAccess) {
				if (!hasAccess) {
					throw new NotFoundError(name);
				}

				return new Promise(function (resolve, reject) {
					// Read the file
					fs.readFile(filepath, 'utf8', function (err, data) {
						if (err) {
							reject(err);
						} else {
							resolve({
								name: safeName,
								content: data
							});
						}
					});
				});
			});
		}

		/**
   * Get the environments that this file belongs to.
   * @param {string} name - The configuration file name.
   * @return {string[]} - The environments this file contributes to.
   * @private
   */

	}, {
		key: 'mapNameToEnvs',
		value: function mapNameToEnvs(name) {
			var filename = path.basename(name);
			var envTypeRegex = new RegExp('^(.*\\.)?(.*)\\.js$');
			var envType = void 0;

			if (!envTypeRegex.test(filename)) {
				// Not a config file
				return null;
			}

			var match = envTypeRegex.exec(filename);
			envType = match.length >= 2 && match[2];

			// Handle aliases and unknown
			envType = envType === 'preprod' ? 'preproduction' : envType;
			envType = envType === 'prod' ? 'production' : envType;
			envType = envType === 'prod-eu' ? 'production-eu' : envType;
			envType = envType === 'dev' ? 'development' : envType;
			envType = ENV_TYPES.indexOf(envType) === -1 ? UNKNOWN_ENV : envType;

			var envs = [];
			if (envType !== UNKNOWN_ENV) {
				Object.keys(ENV_MAP).forEach(function (key) {
					if (ENV_MAP[key].indexOf(envType) !== -1) {
						envs.push(key);
					}
				});
			} else {
				envs.push(UNKNOWN_ENV);
			}

			return envs;
		}

		/**
   * Get the specfied configuration file.
   * @param {string} name - The configuration file name.
   * @return {Promise} - Resolves with the file name, content and environments.
   */

	}, {
		key: 'getConfig',
		value: function getConfig(name) {
			var envs = this.mapNameToEnvs(name);

			return Promise.race([new Promise(function (resolve, reject) {
				// Reject immediately if not a config file.
				if (!envs || envs.length === 0) {
					reject(new NotFoundError(name));
				}
			}), this.readConfigFile(name).then(function (config) {
				return new ServerConfiguration(config.name, envs, config.content);
			})]);
		}

		/**
   * Update the specfied configuration file.
   * @param {string} name - The configuration file name.
   * @param {ServerConfiguration} config - The configuration file content.
   * @return {Promise} - Resolves with the file name, content and environments.
   */

	}, {
		key: 'updateConfig',
		value: function updateConfig(name, config) {
			var safeName = this.safeFilename(name);
			var filepath = path.join(this.confDir, safeName);

			return this.getConfig(name).then(function () {
				return new Promise(function (resolve, reject) {
					fs.writeFile(filepath, config.content, 'utf8', function (err) {
						if (err) {
							reject(err);
						} else {
							resolve();
						}
					});
				});
			});
		}

		/**
   * List all the configuration files, optionally filter by environment.
   * @param {string} env - (optional) the environment to get the configuration files for..
   * @return {Promise} - Resolves with an array of SystemConfig with no content.
   */

	}, {
		key: 'listConfigs',
		value: function listConfigs(env) {
			var _this = this;

			return Promise.race([new Promise(function (resolve, reject) {
				// Reject immediately if invalid env type
				if (env && Object.keys(ENV_MAP).indexOf(env) === -1) {
					reject(new BadRequestError(env));
				}
			}), new Promise(function (resolve) {
				var walker = walk.walk(_this.confDir);
				var files = [];

				walker.on('file', function (root, fileStats, next) {
					var envs = _this.mapNameToEnvs(fileStats.name);

					if (envs != null && (!env || envs.indexOf(env) !== -1)) {
						var absPath = path.join(root, fileStats.name);
						var configPath = path.relative(_this.confDir, absPath);
						files.push(new ServerConfiguration(configPath, envs));
					}
					next();
				});

				walker.on('end', function () {
					resolve(files);
				});
			})]);
		}
	}]);

	return ConfigurationController;
}();

exports = module.exports = ConfigurationController;