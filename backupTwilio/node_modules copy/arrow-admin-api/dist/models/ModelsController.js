'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint no-unused-expressions:0 */
var fs = require('fs');
var path = require('path');
var BadRequestError = require('../errors/BadRequestError');

var ALLOWED_MODEL_PROPS = ['actions', 'connector', 'description', 'fields', 'metadata', 'plural', 'singular'];
var ALLOWED_FIELD_PROPS = ['default', 'description', 'model', 'name', 'type', 'required', 'readonly', 'validator'];

/**
 * Generates code from current model.  Ideally, this should be within the arrow-orm.
 */
function generateCode(model) {
	// Check for required properties
	if (!model.name) {
		throw new BadRequestError('missing required property: name');
	}

	if (!model.connector || _typeof(model.connector) === 'object' && !model.connector.name) {
		throw new BadRequestError('missing or invalid property: connector');
	}
	if (!model.fields || _typeof(model.fields) !== 'object' || !Object.keys(model.fields).length) {
		throw new BadRequestError('missing or invalid property: fields');
	}

	// Preserve the model name
	var modelName = model.name;

	Object.keys(model).forEach(function (key) {
		if (key === 'fields') {
			Object.keys(model[key]).forEach(function (field) {
				Object.keys(model[key][field]).forEach(function (attr) {
					if (ALLOWED_FIELD_PROPS.indexOf(attr) < 0) {
						delete model[key][field][attr]; // not allowed
					} else if (attr === 'default') {
						if (model[key][field][attr] === '') {
							// when: default; deletes when empty (and only if empty)
							delete model[key][field][attr];
						}
					} else if (attr !== 'actions' && !model[key][field][attr]) {
						// when: readonly, required; deletes when false
						// when: description, name, type; deletes when empty
						// when: actions; do nothing
						delete model[key][field][attr];
					}
				});
			});
		}
		if (ALLOWED_MODEL_PROPS.indexOf(key) < 0) {
			delete model[key]; // not allowed
		} else if (key === 'connector') {
			if (_typeof(model[key]) === 'object') {
				model[key] = model[key].name; // convert the connector to a string name
			}
		} else if (key === 'metadata' && !Object.keys(model[key]).length) {
			delete model[key]; // redundant
		} else if (!model[key]) {
			// when: connector, fields, metadata; deletes when empty
			delete model[key];
		}
	});

	var modelPrefix = 'var Arrow = require(\'arrow\');\nvar Model = Arrow.createModel(\'' + modelName + '\', ';
	var modelBookend = ');\nmodule.exports = Model;';
	var generatedCode = '' + modelPrefix + JSON.stringify(model, null, 4) + modelBookend;
	return generatedCode;
}

var ModelsController = function () {
	function ModelsController(ctx) {
		_classCallCheck(this, ModelsController);

		this.ctx = ctx;
		if (!this.ctx.arrow.createModel) {
			throw new BadRequestError('Arrow.createModel is not defined');
		}
		this.modelsDir = path.resolve(path.join(this.ctx.arrow.config.dir || process.cwd(), 'models'));
	}

	/**
 * List all the models.
 * @return {Model} models - The models that Arrow has loaded.
 * @private
 */


	_createClass(ModelsController, [{
		key: 'getModels',
		value: function getModels() {
			var _this = this;

			return new Promise(function (resolve, reject) {
				var models = _this.ctx.arrow.getModels();
				if (!models) {
					reject(new Error('Unable to list models from Arrow.'));
				} else {
					(function () {
						// The Arrow.Model has a toJson that's more restrictive that limits the data, so re-compose
						// the model list to avoid the issue.
						var bareModels = {};
						Object.keys(models).forEach(function (m) {
							// Shallow copy the model and remove unwanted top-level fields
							bareModels[m] = Object.assign({}, models[m]);
							bareModels[m].filename && delete bareModels[m].filename;
						});
						resolve(bareModels);
					})();
				}
			});
		}

		/**
  * Sanitize name and resolve it to prevent directory traversal.
  * @param {string} name - The name to make safe.
  * @return {string} path - The safe filename.
  * @private
  */

	}, {
		key: 'safeFilename',
		value: function safeFilename(name) {
			return path.relative(path.sep, path.join(path.sep, name));
		}

		/**
  * Create a model file with the specified definition.
  * @param {Model} definition - The mode to create.
  * @return {Promise} promise - A promise that resolves when the file has been written.
  * @private
  */

	}, {
		key: 'createModel',
		value: function createModel(modelDef) {
			var _this2 = this;

			return new Promise(function (resolve, reject) {
				try {
					var _ret2 = function () {
						if (!modelDef || !modelDef.name) {
							reject('invalid model definition');
							return {
								v: void 0
							};
						}
						// Deep copy model
						var definition = JSON.parse(JSON.stringify(modelDef));
						var safeName = _this2.safeFilename(definition.name) + '.js';
						var filepath = path.join(_this2.modelsDir, safeName);

						// NOTE: the following code uses Arrow to validate models.  to make it
						// work, it is necessary to "tweak" things to allow createModel to be
						// called successfully.  It needs to remove the model, and dynamically
						// load the connector for it.
						// ------------------------------------
						// BEGIN: tweak
						// check to see if the current model exists and if it does remove
						// it (otherwise, it will throw an error).  the server will be restaring
						// anyway.  removing only removes from memory.
						try {
							var exists = _this2.ctx.arrow.getModel(definition.name);
							if (exists) {
								_this2.ctx.arrow.removeModel(definition);
							}
						} catch (ex) {}
						// okay to gobble error

						// convert the connector object to string to allow the arrow code
						// to dynamically resolve the connector.
						if (definition.connector && definition.connector.name) {
							definition.connector = definition.connector.name;
						}
						// ------------------------------------
						// END: tweak

						// validates the model before saving
						_this2.ctx.arrow.createModel(definition.name, definition);

						var code = generateCode(definition);

						fs.writeFile(filepath, code, {
							flag: 'w',
							encoding: 'utf-8',
							mode: 420
						}, function (err) {
							if (err) {
								reject(err);
							} else {
								resolve(definition.name);
							}
						});
					}();

					if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
				} catch (ex) {
					reject(ex);
				}
			});
		}
	}]);

	return ModelsController;
}();

exports = module.exports = ModelsController;