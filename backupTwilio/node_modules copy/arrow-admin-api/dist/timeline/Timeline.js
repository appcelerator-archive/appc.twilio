'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var fs = require('fs'),
    path = require('path'),
    _ = require('lodash'),
    util = require('../util'),
    moment = require('moment');

// jscs:disable jsDoc
function formatRemote(addr) {
	return addr && addr.replace(/^::ffff:/, '');
}

var Timeline = function () {
	function Timeline(arrow) {
		_classCallCheck(this, Timeline);

		this.logs = {};
		this.metadata = {};
		this.results = {};
		this.errors = {};
		this.args = {};
		this.arrow = arrow;
	}

	_createClass(Timeline, [{
		key: 'process',
		value: function process(obj) {
			try {
				if (obj && obj.type) {
					return this.add(obj);
				} else if (obj && obj.start && obj.req) {
					obj.type = 'request';
					obj.method = obj.req.method;
					obj.headers = obj.req.headers;
					this.started = new Date(obj.time).getTime();
					this.req_id = obj.req_id;
					this.url = obj.req.url;
					var formattedAddress = formatRemote(obj.req.remoteAddress);
					this.remote = formattedAddress + ':' + obj.req.remotePort;
					return this.add(obj);
				} else if (obj && obj.ignore) {
					// skip, this is not used right now
				} else {
					console.warn('not sure how to handle', obj);
				}
			} catch (err) {
				console.error(err.stack);
			}
			return false;
		}
	}, {
		key: 'finish',
		value: function finish() {
			if (this.request) {
				this.request.logs = this.logs.request;
			}
			if (this.response) {
				this.response.logs = this.logs.response;
			}

			delete this.logs;
			delete this.metadata;
			delete this.arrow;
			delete this.args;
			delete this.results;
			delete this.errors;

			return this;
		}
	}, {
		key: 'getModel',
		value: function getModel(timeline) {
			var tok = timeline.name.split(':');
			timeline.name = tok[1];
			timeline.method = timeline.subname || timeline.name;
			delete timeline.subname;
			return this.arrow.getModel(timeline.name);
		}
	}, {
		key: 'getConnector',
		value: function getConnector(timeline) {
			var tok = timeline.name.split(':');
			timeline.name = tok[1];
			timeline.method = timeline.subname;
			delete timeline.subname;
			var connector = this.arrow.getConnector(timeline.name);
			var version = connector.version || connector.pkginfo && connector.pkginfo.version || '0.0.0';
			timeline.name = version ? 'connector/' + timeline.name + '@' + version : 'connector/' + timeline.name;
			return connector;
		}
	}, {
		key: 'getBlock',
		value: function getBlock(timeline) {
			timeline.name = timeline.subname || timeline.name;
			delete timeline.subname;
			return this.arrow.getBlock(timeline.name);
		}
	}, {
		key: 'getAPI',
		value: function getAPI(timeline) {
			timeline.name = timeline.subname || timeline.name;
			delete timeline.subname;
			var key = 'action:api:' + timeline.name;
			var metadata = this.metadata && this.metadata[key] || { method: 'GET' };
			return this.arrow.getAPI(metadata.path || timeline.name, metadata.method);
		}
	}, {
		key: 'processComponent',
		value: function processComponent(timeline, component, logs, metadata, args, result, error) {
			if (component) {
				timeline.description = component.description || component.pkginfo && component.pkginfo.description;
				timeline.filename = component.filename;
				timeline.detail = {};
				timeline.detail.args = args;
				timeline.detail.result = result;
				if (error) {
					timeline.detail.error = error;
				}
				if (logs) {
					timeline.detail.logs = logs;
				}
				// attempt to full in filename
				if (component.filename && fs.existsSync(component.filename)) {
					// if a directory, don't load it
					if (fs.statSync(component.filename).isDirectory()) {
						if (component.pkginfo) {
							timeline.filename = null; // set to null to pull in pkginfo
						} else {
							var pkg = path.join(component.filename, 'package.json');
							if (fs.existsSync(pkg)) {
								timeline.filename = pkg;
							} else {
								timeline.filename = null; // can't pull in directory so set to null
							}
						}
					}
				}
				if (metadata && !timeline.filename) {
					timeline.detail.config = metadata;
					if (metadata.model) {
						timeline.description = 'Generated API for ' + metadata.model;
					}
				}
				// generate source for non-generated model/api/blocks that developer has written
				if (/(model|api|block)/.test(timeline.type) && !component.generated) {
					if (timeline.filename) {
						timeline.detail.source = fs.readFileSync(timeline.filename).toString();
					} else if (_.isObject(component)) {
						try {
							timeline.detail.source = JSON.stringify(_.omit(component, function (value, key) {
								return _.isFunction(value) || key[0] === '_';
							}), Timeline.decircularize(), 4);
						} catch (err) {
							console.error(err);
						}
					}
				}
			} else {
				this.arrow.logger.error('Couldn\'t find timeline component for', timeline);
			}
		}
	}, {
		key: 'add',
		value: function add(obj) {
			switch (obj.type) {
				case 'request':
					this.request = _.merge({}, _.pick(obj, 'method', 'time'));
					this.request.type = 'server';
					this.request.name = 'HTTP Request';
					this.request.started = new Date(this.request.time).getTime();
					delete this.request.time;
					this.request.detail = {
						body: obj.body,
						headers: obj.headers
					};
					this.request.description = moment(obj.time).fromNow() + ' (' + obj.time + ')';
					// console.log('this.request->',JSON.stringify(this.request,null,2));
					break;

				case 'response':
					this.response = _.merge({}, _.pick(obj, 'status', 'time'));
					this.response.type = 'server';
					this.response.name = 'HTTP Response';
					this.response.started = new Date(this.response.time).getTime();
					delete this.response.time;
					this.response.statusMessage = util.statusMessage(this.response.status);
					this.response.detail = {
						body: obj.body,
						headers: obj.headers
					};
					break;

				case 'transaction':
					// if this is a log message, record it by the type
					if (!obj.ignore && obj.msg) {
						var key = obj.tx_name;
						if (!key) {
							// if we are getting logs before or after transactions
							// we can assume that these are part of the incoming request before
							// the transaction or after the transactions in the response handler
							if (this.request) {
								key = 'request';
							} else {
								key = 'response';
							}
						}
						var array = this.logs[key];
						if (!array) {
							this.logs[key] = array = [];
						}
						array.push({ level: util.formatLogLevel(obj.level), time: obj.time, msg: obj.msg });
					} else if (obj.ignore && obj.tx_metadata) {
						// set our metadata
						this.metadata[obj.tx_name] = obj.tx_metadata;
					}
					if (obj._result) {
						this.results[obj.tx_name] = obj._result;
					}
					if (obj._error) {
						this.errors[obj.tx_name] = obj._error;
					}
					if (obj._args) {
						this.args[obj.tx_name] = obj._args;
					}
					break;

				case 'timeline':
					try {
						this.timeline = _.pick(obj, 'timeline', 'time', 'totalDuration', 'apiDuration', 'beginServerDuration', 'endServerDuration');
						this.timeline.started = new Date(this.timeline.time).getTime();
						delete this.timeline.time;
						// now associate our logs we found with the right transaction
						this.timeline.timeline.forEach(function (timeline) {
							if (!timeline) {
								return;
							}
							var logs = this.logs[timeline.name],
							    metadata = this.metadata[timeline.name];

							var args = this.args[timeline.name];
							var error = this.errors[timeline.name];
							var result = this.results[timeline.name];

							try {
								switch (timeline.type) {
									case 'connector':
										{
											var Connector = this.getConnector(timeline);
											this.processComponent(timeline, Connector, logs, metadata, args, result, error);
											break;
										}
									case 'model':
										{
											var Model = this.getModel(timeline);
											this.processComponent(timeline, Model, logs, metadata, args, result, error);
											break;
										}
									case 'block':
										{
											var Block = this.getBlock(timeline);
											this.processComponent(timeline, Block, logs, metadata, args, result, error);
											break;
										}
									case 'action':
										{
											var API = this.getAPI(timeline);
											// internally its an action, but we want to display it as an API in the UI
											timeline.type = 'api';
											this.processComponent(timeline, API, logs, metadata, args, result, error);
											break;
										}
									default:
										throw new Error('Unknown type: ' + timeline.type);
								}
							} catch (err) {
								console.error(err);
							}
						}.bind(this));
					} catch (err) {
						console.error(err);
					}
					break;

				default:
					throw new Error('Unknown type: ' + obj.type);
			}
		}
	}], [{
		key: 'validate',


		/**
  * Validate that object is a Timeline.
  * @param {Timeline|object} entry - The object to validate.
  * @return {boolean} - true if the object is a valid Timeline.
  */
		value: function validate(entry) {
			var valid = true;
			this.schema.required.forEach(function (prop) {
				if (!entry.hasOwnProperty(prop)) {
					valid = false;
				}
			});
			return valid;
		}
	}, {
		key: 'decircularize',
		value: function decircularize() {
			var seen = [];

			return function (key, value) {
				// Translate model types.
				if (value instanceof Buffer) {
					return '[ Buffer ]';
				}
				if (key === 'type' && value && _.isFunction(value)) {
					return value.name;
				}
				if (key === 'connector') {
					if (value && value.pkginfo) {
						return value.pkginfo.name + '@' + value.pkginfo.version;
					}
					return value;
				}
				if (key === 'logger') {
					return '[ Logger ]';
				}
				// If we have a circular reference, replace its value with a string representation.
				if (value && _.isObject(value)) {
					if (seen.indexOf(value) >= 0) {
						return '[ Circular Reference ]';
					}
					seen.push(value);
				}
				return value;
			};
		}
	}, {
		key: 'schema',
		get: function get() {
			return {
				title: 'Timeline',
				type: 'object',
				properties: {
					started: {
						type: 'number',
						description: 'The time (in msec) that the request started.'
					},
					req_id: {
						type: 'string',
						description: 'Unique request identifier'
					},
					url: {
						type: 'string',
						description: 'The request URL'
					},
					remote: {
						type: 'string',
						description: 'The remote host'
					},
					request: {
						$ref: '#/definitions/TimelineEntry'
					},
					response: {
						$ref: '#/definitions/TimelineEntry'
					},
					timeline: {
						type: 'object',
						properties: {
							beginServerDuration: {
								type: 'number',
								description: 'The time (in msec) processing the message prior to API access.'
							},
							endServerDuration: {
								type: 'number',
								description: 'The time (in msec) processing the message after to API access.'
							},
							totalDuration: {
								type: 'number',
								description: 'The server time (in msec) processing the request.'
							},
							timeline: {
								type: 'array',
								items: {
									$ref: '#/definitions/TimelineEntry'
								}
							}
						}
					}
				},
				required: ['req_id', 'started', 'url', 'request']
			};
		}
	}]);

	return Timeline;
}();

exports = module.exports = Timeline;