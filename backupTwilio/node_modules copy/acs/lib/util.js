'use strict';

var logger = require('./logger.js'),
    jsp = require('uglify-js').parser,
    pro = require('uglify-js').uglify,
    path = require('path'),
    fs = require('fs'),
    _ = require('underscore')._,
    colors = require('colors'),
    program = require('commander'),
    globalConfig,
    defaultConfig;

function generateTemplate(name, config, outFile, compile) {
    var fn = path.join(__dirname, 'templates', name);
    var results = '';
    if(compile) {
        var compiled = _.template(fs.readFileSync(fn, 'utf8'));
        results = compiled(config || {});
    } else {
        results = fs.readFileSync(fn);
    }
    if(compile) {
        fs.writeFileSync(outFile, results, 'utf8');
    } else {
        fs.writeFileSync(outFile, results, 'utf8');
    }
}

function generateTemplateDir(dir, config, outdir) {
    if(!exists(outdir)) {
        fs.mkdirSync(outdir);
    }
    var fn = path.join(__dirname, 'templates', dir);
    if(exists(fn)) {
        var files = fs.readdirSync(fn), i;
        for(i in files) {
            if(files.hasOwnProperty(i)) {
                var file = path.join(fn, files[i]);
                var stat = fs.statSync(file);
                if(stat.isDirectory()) {
                    generateTemplateDir(path.join(dir, files[i]), config, path.join(outdir, files[i]));
                } else {
                    generateTemplate(path.join(dir, files[i]), config, path.join(outdir, files[i]));
                }
            }
        }
    }
}

function die(msg, errcode) {
    logger.error(msg);
    if (errcode) {
        process.exit(errcode);
    } else {
        process.exit(1);
    }
}

function exists(f) {
    // changes in node 0.8.0
    if (_.isFunction(fs.existsSync)) {
        return fs.existsSync(f);
    }
    return path.existsSync(f);
}

function lpad(x, len, ch) {
    ch = ch || ' ';
    var pre = '';
    var ns = String(x);
    var cur = colors.stripColors(ns).length;
    for ( var c = cur; c < len; c++) {
        pre += ch;
    }
    return pre + ns;
}

function rpad(x, len, ch) {
    ch = ch || ' ';
    var ns = String(x);
    var cur = colors.stripColors(ns).length;
    for ( var c = cur; c < len; c++) {
        ns += ch;
    }
    return ns;
}

function trim(line) {
    return String(line).replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}

function getUserHome() {
    return process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];
}

function getConfigFile() {
    return path.join(getUserHome(), '.' + program.name);
}

function getNPMConfigFile() {
    return path.join(getUserHome(), '.' + 'npmrc');
}

function getNPMAuth() {
    var npmrc = getNPMConfigFile();
    if (exists(npmrc)) {
        var file = fs.readFileSync(npmrc, 'utf8');
        var _auth = file.match(/^_auth = (.*?)\n/);
        if (!_auth) {
            return null;
        }
        _auth = _auth[1];
        _auth = new Buffer(_auth, 'base64').toString();
        _auth = _auth.match(/^([^:]+):(.+)$/);
        if (!_auth) {
            return null;
        }
        return ({user: _auth[1], password: _auth[2]});
    } else {
        return null;
    }
}

function getPathSeparator() {
    return process.platform === 'win32' ? '\\' : '/';
}

function getDefaultConfFile() {
    var nettleExec = process.argv[1];
    nettleExec = fs.realpathSync(nettleExec);
    var nettlePath = nettleExec.substring(0, nettleExec.lastIndexOf(getPathSeparator(),
            nettleExec.lastIndexOf(getPathSeparator()) - 1));
    return nettlePath + getPathSeparator() + 'nettle.conf';
}

function getDefaultConfig() {
    if (defaultConfig) {
        // cache it
        return defaultConfig;
    }
    var cfg = getDefaultConfFile();
    if (exists(cfg)) {
        try {
            defaultConfig = JSON.parse(fs.readFileSync(cfg, 'utf-8'));
            return defaultConfig;
        } catch (E) {
            logger
            .error('Error parsing config file at ' + cfg + '. ' +
                E.stack);
        }
    }
    return {
        publishHost : 'https://admin.cloudapp.appcelerator.com',
        publishPort : '443'
    };
}

function getGlobalConfig() {
    if (globalConfig) {
        // cache it
        return globalConfig;
    }
    var cfg = getConfigFile();
    if (exists(cfg)) {
        try {
            globalConfig = JSON.parse(fs.readFileSync(cfg, 'utf-8'));
            return globalConfig;
        } catch (E) {
            logger
            .error('Error parsing config file at ' + cfg + '. ' +
                E.stack);
        }
    }
    return {};
}

function saveGlobalConfig(o) {
    var cfg = getConfigFile();
    fs.writeFileSync(cfg, stringifyJSON(o), 'utf-8');
    globalConfig = o;
}

function saveLastLogTime(logType, startTime, endTime, lastLogTime) {
    var o = getGlobalConfig();
    o[logType] = {};
    o[logType].lastLogTime = lastLogTime;
    o[logType].startTime = startTime;
    o[logType].endTime = endTime;
    saveGlobalConfig(o);
}

function getLastLogTime(logType) {
    var o = getGlobalConfig();
    return o[logType];
}

function getProxy() {
    var proxy = {};
    proxy.server = getGlobalConfig().proxy || getDefaultConfig().proxy || undefined;
    if(!proxy.server) {
        return null;
    }

    var proxy_user = getGlobalConfig().proxy_user || getDefaultConfig().proxy_user || undefined;
    var proxy_pass = getGlobalConfig().proxy_pass || getDefaultConfig().proxy_pass || undefined;

    proxy.url = proxy.server;
    if(proxy_user && proxy_pass) {
        var i = proxy.server.indexOf('//');
        if(i !== -1) {
            proxy.url = proxy.server.substring(0, i + 2);
            proxy.url += proxy_user;
            proxy.url += ':';
            proxy.url += proxy_pass;
            proxy.url += '@';
            proxy.url += proxy.server.substring(i + 2);
        }
    }

    return proxy;
}

function isLoggedIn() {
    var cfg = getGlobalConfig();
    return cfg.session && cfg.mid && cfg.session.sid && cfg.username;
}

function stringifyJSON(j) {
    var ast = jsp.parse('(' + JSON.stringify(j) + ')');
    ast = pro.ast_mangle(ast);
    var final_code = pro.gen_code(ast, {
        beautify : true,
        quote_keys : true
    });

    // XXX: why would we assign the value of the loca variable final_code
    // right before returning?
    final_code = final_code.substring(1, final_code.length - 2); // remove
    return final_code;
    // ( )
    // needed
    // for
    // parsing
}

function readConfig(projectdir) {
    if (!exists(projectdir)) {
        die('Couldn\'t find project at ' + projectdir);
    }
    var config = path.join(projectdir, 'package.json');
    if (!exists(config)) {
        die('Couldn\'t find project at ' + projectdir +
            '. Missing config at ' + config);
    }

    return JSON.parse(fs.readFileSync(config, 'utf-8'));
}

function findAddresses(cb, results) {

    var i = 0;
    var exec = require('child_process').exec;

    var re = /[^:\-](?:[0-9A-F][0-9A-F][:\-]){5}[0-9A-F][0-9A-F][^:\-]/i;
    var cmds = [ '/sbin/ifconfig', '/bin/ifconfig', 'ifconfig', 'ipconfig /all' ];

    var cbs = [];

    function run_cmd() {
        var cmd = cmds[i];
        exec(cmd, function(err, stdout, stderr) {
            var lines, line, match, j;
            if (!err) {
                lines = stdout.split('\n');
                for (j = 0; j < lines.length; j++) {
                    line = lines[j];
                    match = re.exec(line);
                    if (match) {
                        match = match.toString().trim();
                        if (match.length) {
                            if (!results) {
                                results = [];
                            }
                            results.push(match);
                        }
                    }
                }
            }

            if (results && results.length > 0) {
                done();
            } else {
                i += 1;
                if (i < cmds.length) {
                    run_cmd();
                } else {
                    done();
                }
            }
        });
    }

    // Avoid calling out to the shell multiple times.
    // Queue up any callbacks, and call them all when done.
    var done = function() {
        while (cbs.length) {
            cb = cbs.shift();
            cb();
        }
    };

    if (results.length === 0) {
        cbs.push(cb);
        if (cbs.length === 1) {
            run_cmd();
        }
    } else {
        cb();
    }
}

function getMacAddress(cb) {
    if (!(cb instanceof Function)) {
        throw new Error('Argument to address must be a callback function');
    }

    var results = [];

    var respond = function() {
        if (results && results.length >= 1) {
            cb(undefined, results[0]);
        } else {
            cb('No MAC addresses found');
        }
    };

    findAddresses(respond, results);
}

function installDepends(basedir, depends, cb) {
    if (isOnline()) {
        var mods = [], k;
        if(depends) {
            for (k in depends) {
                if(depends.hasOwnProperty(k)) {
                    if(k === 'acs') {
                        logger.warn('\'acs\' is found in dependencies and will be' +
                    ' ignored.');
                        continue;
                    }
                    var cmd = k + '@' + depends[k];
                    logger.debug('dependency => ' + cmd);
                    mods.push(cmd);
                }
            }
        }
        if (mods.length === 0) {
            logger.info('No dependencies detected');
            return cb();
        }
        logger.info('Installing dependencies...');
        try {
            var npm = require("npm");
            npm.load({
                prefix : basedir,
                loglevel : 'warn'
            }, function(err) {
                if (err) {
                    logger.error(err);
                }
                npm.commands.install(function(err) {
                    logger.info('Dependencies installed.');
                    cb(err);
                });
            });
        } catch (e) {
            logger.error(e);
        }
    } else {
        cb();
    }
}

function isOnline() {
    var online = false, name;
    var interfaces = require('os').networkInterfaces();
    for (name in interfaces) {
        if(interfaces.hasOwnProperty(name)) {
            var entries = interfaces[name];
            _.each(entries, function(e) {
                if (!e.internal) {
                    online = true;
                }
            });
            if (online) {
                break;
            }
        }
    }
    return online;
}

function ipaddress() {
    var ifaces = require('os').networkInterfaces(), dev, ipaddr;
    for (dev in ifaces) {
        if(ifaces.hasOwnProperty(dev)) {
            ifaces[dev].forEach(function(details) {
                if (details.family === 'IPv4' && dev.substring(0, 2) !== 'lo') {
                    ipaddr = details.address;
                }
            });
            if (ipaddr) {
                return ipaddr;
            }
        }
    }
}

function isEmpty(val) {
    return (val === undefined || val === null || val.length <= 0) ? true : false;
}

/**
 * Read and validate app package.json
 * @param file full path to app package.json
 */
function readAndValidateConfig(file) {

    var cfg,
        result = {success: true};

    try {
        cfg = JSON.parse(fs.readFileSync(file, 'utf-8'));
    } catch (e) {
        result.success = false;
        // Set default message, caller can also use different message according to validate result.
        result.message = "Failed to parse package.json. Please make sure your app's package.json is valid.";
        return result;
    }

    var fieldError = validateConfig(cfg);
    if(fieldError) {
        result.success = false;
        result.message = 'Failed to validate packages.json. ' + fieldError;
        return result;
    }

    result.config = cfg;
    return result;
}


/**
 * validate content of app package.json.
 * @param config
 * @returns {*}
 */
function validateConfig(config) {
    if(config) {
        if(!config.name || trim(config.name) === '') {
            return 'Invalid \'name\'.';
        }
        if(!config.version || trim(config.version) === '') {
            return 'Invalid \'version\'.';
        }
        //If no framework specified we'll default to 'none' (regular or free app)
        if(config.framework && config.framework !== 'none' && config.framework !== 'mvc' ) {
            return 'Invalid \'framework\'.';
        }
        if(config.framework === 'mvc') {
            if(!config.main || trim(config.main) === '') {
                return 'Invalid \'main\'.';
            }
        } else {
            /* if the app is created with '--framework none'
             * 'main' or 'scripts.start' in package.json are both ok
             * but if they are set at the same time, we will only take 'main'
             */
            var included_main = (config.main && trim(config.main) !== '');
            var included_scripts_start = (config.scripts && config.scripts.start && trim(config.scripts.start) !== '');
            if(!included_main && !included_scripts_start) {
                return 'You must specify either \'main\' or \'scripts.start\' for launching app.';
            } else if (included_main && included_scripts_start) {
                logger.warn('Both \'main\' and \'scripts.start\' are specified. \'scripts.start\' will be ignored.');
            }
        }
        if(config.dependencies && config.dependencies.acs) {
            return '\'acs\' cannot be in dependencies.';
        }
        return null;
    } else {
        return 'No configuration to validate.';
    }
}

/**
 * Read and validate git configuration file for publish
 * @param file full path to git configuration file
 */
function readAndValidateGitConfig(file) {

    var cfg,
        result = {success: true};

    try {
        cfg = JSON.parse(fs.readFileSync(file, 'utf-8'));
    } catch (e) {
        result.success = false;
        // Set default message, caller can also use different message according to validate result.
        result.message = "Failed to parse file. Please make sure your specify a valid git configuration file.";
        return result;
    }

    if(!cfg.repo || trim(cfg.repo) === '') {
        result.success = false;
        result.message = 'Failed to validate git configuration file. Invalid \'repo\'.';
        return result;
    }

    result.config = cfg;
    return result;
}


function isPositiveInt(value) {
    var floatN = parseFloat(value);
    if ((floatN === parseInt(value, 10)) && !isNaN(value)) {
        if (floatN > 0 && floatN < 999999999999) {
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
}

function isWin() {
    return require('os').platform().indexOf('win') === 0;
}


function parseUrlPath(path) {
    var keys = [];
    if (Array.isArray(path)) {
        path = '(' + path.join('|') + ')';
    }
    path = path
        .replace(/\/\(/g, '(?:/')
        .replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g, function(_, slash, format, key, capture, optional, star){
            keys.push({ name: key, optional: !! optional });
            slash = slash || '';
            return '' +
        (optional ? '' : slash) +
        '(?:' +
        (optional ? slash : '') +
        (format || '') +
        (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')' +
        (optional || '') +
        (star ? '(/*)?' : '');
        })
        .replace(/([\/.])/g, '\\$1')
        .replace(/\*/g, '(.*)');

    return keys;
}

// Make sure the env variable name is shell safe per:
// http://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap08.html
function checkEnvVarName(varName) {
    // list of reserved env var names
    var blackList = [];
    var invalidChars = varName.toString().match(/[^_A-Za-z0-9]/g);
    if(invalidChars) {
        return varName + ' contains illegal character: ' + invalidChars + '.';
    }
    // env vars must start with a shell safe non digit character.
    if (!varName.charAt(0).match(/[_A-Za-z]/)) {
        return  'Variable name must start with a non digit character.';
    }
    if (blackList.indexOf(varName) !== -1) {
        return '\'' + varName + '\'' + ' is reserved, please use another name.';
    }
    return null;
}

function validateDomain(cname) {
    if(!cname) {
        return 'Please provide a valid domain with --set'.red;
    }
    if(!cname.match(/^(?:[a-zA-Z0-9]+(?:\-*[a-zA-Z0-9])*\.)+[a-zA-Z]{2,6}$/)) {
        return cname + ' is not a valid domain name.';
    }

    return null;
}

function password (prompt, mask, callback) {
    process.stdout.write(prompt);
    var value = '';
    mask = mask || '*';

    function raw(mode) {
        var setRawMode = process.stdin.setRawMode || process.tty.setRawMode;
        setRawMode.call(process.stdin, mode);
    }

    try {
        raw(true);
    } catch (ex) {
    }

    process.stdin.on('error', callback);
    process.stdin.on('data', function data (line) {
        line = line + '';
        for(var i = 0; i < line.length; i++) {
            var c = line[i];
            // Unicode of Key 'up', 'down', 'left', 'right' start with u0027 (x1b)
            // When meeting those 4 keys, will ignore
            if(c === '\x1b' && i === 0) {
                break;
            }
            switch (c) {
                case '\n': case '\r': case '\r\n': case '\u0004':
                try { raw(false); } catch (ex) { }
                process.stdin.removeListener('data', data);
                process.stdin.removeListener('error', callback);
                value = value.trim();
                process.stdout.write('\n');
                if(process.stdout.flush) {
                    process.stdout.flush();
                }
                return callback(null, value);
                case '\x7f': case'\x08':
                // Backspace escape
                if(value.length>0){
                    process.stdout.write('\b \b');
                }
                value = value.slice(0,-1);
                break;
                case '\u0003': case '\0':
                process.stdout.write('\n');
                process.exit(1);
                break;
                default:
                    value = value + c;
                    process.stdout.write(mask);
                    break;
            }
        }
    });

}

function getUsername(args, defaultUsername, prompt, cb) {
    if(typeof prompt === 'function') {
        cb = prompt;
        // Following is for authenticated npm install, only show 'npm username:' prompt
        if(defaultUsername === 'npm username:') {
            prompt = defaultUsername;
        } else {
        // Following is for username prompt when user login
        prompt = 'username:';
        if(defaultUsername) {
        // Display the default username which is in ~/.acs file
        prompt = 'username (' + defaultUsername.cyan.bold + '):';
        }
        }
    }
    if (args && args.length > 0) {
        cb(args[0]);
    } else {
        program.prompt(prompt.white+' ', cb);
    }
}

function getPassword(args, prompt, cb) {
    if(typeof prompt === 'function') {
        cb = prompt;
        prompt = 'password:';
    }
    if (args && args.length > 1) {
        cb(args[1]);
    } else {
        // we have to use our own since commander is jacked in 0.8 for password
        password(prompt.white+' ','*',function(err,value) {
            if (err) {
                die(err);
            }
            cb(value);
        });
        //program.password('password:'.white+' ','*',cb);
    }
}

function getHost(args, hostname, prompt, cb) {

    if(typeof prompt === 'function') {
        cb = prompt;
        prompt = 'host (' + (getGlobalConfig().publishHost || getDefaultConfig().publishHost).cyan.bold + '):';
    }
    if(!hostname) {
        program.prompt(prompt.white+' ', cb);
    } else {
        cb(hostname);
    }
}

function requireLogin(cb) {
    console.log('Login required!');
    require('./command/login').run(null, null, cb);
}

function getConnectionErrorMsg(error, resBody) {
    var host_port = (getGlobalConfig().publishHost || getDefaultConfig().publishHost) + ':' + (getGlobalConfig().publishPort || getDefaultConfig().publishPort);
    return 'Can not connect to ' + host_port + '.';
}

/**
 * Get the app name from the command arguments
 * @param args
 * @param program
 * @param name default name
 * @return {*}
 */
function getAppName(args, program, name) {
    if(name) {
        return name;
    }
    var appname;
    if (args.length >= 1) {
        appname = args[0];
    } else {
        var dir = program.dir || process.cwd();
        var f = path.join(dir, 'package.json');
        if (!exists(f)) {
            die('Could not find application directory. Please specify a valid app name or run the command in project dir or with -d to specify a project dir.'.red);
        } else {
            var config = JSON.parse(fs.readFileSync(f, 'utf-8'));
            try {
                appname = config.name;
            } catch (err) {
                die('Could not locate app name in package.json. Please specify a valid app name or run the command in project dir or with -d to specify a project dir.'.red);
            }
        }
    }

    return appname;
}

/**
 * Check if a path is an existing directory
 * @param path
 */
function isDirectory(path) {
    try {
        if(fs.lstatSync(path).isDirectory()){
            return true;
        }
    } catch (err) {
        // the path does not exist
        return false;
    }
}

exports.framework_mvc = 'mvc';
exports.framework_none = 'none';
exports.isEmpty = isEmpty;
exports.ipaddress = ipaddress;
exports.getMacAddress = getMacAddress;
exports.die = die;
exports.stringifyJSON = stringifyJSON;
exports.readConfig = readConfig;
exports.getGlobalConfig = getGlobalConfig;
exports.getDefaultConfig = getDefaultConfig;
exports.saveGlobalConfig = saveGlobalConfig;
exports.isLoggedIn = isLoggedIn;
exports.isOnline = isOnline;
exports.trim = trim;
exports.lpad = lpad;
exports.rpad = rpad;
exports.exists = exists;
exports.installDepends = installDepends;
exports.generateTemplate = generateTemplate;
exports.generateTemplateDir = generateTemplateDir;
exports.serviceConfig = {};
exports.validateConfig = validateConfig;
exports.isPositiveInt = isPositiveInt;
exports.isWin = isWin;
exports.getProxy = getProxy;
exports.saveLastLogTime = saveLastLogTime;
exports.getLastLogTime = getLastLogTime;
exports.parseUrlPath = parseUrlPath;
exports.checkEnvVarName = checkEnvVarName;
exports.getUsername = getUsername;
exports.getPassword = getPassword;
exports.getHost = getHost;
exports.password = password;
exports.validateDomain = validateDomain;
exports.getNPMAuth = getNPMAuth;
exports.readAndValidateConfig = readAndValidateConfig;
exports.readAndValidateGitConfig = readAndValidateGitConfig;
exports.requireLogin = requireLogin;
exports.getConnectionErrorMsg = getConnectionErrorMsg;
exports.getAppName = getAppName;
exports.isDirectory = isDirectory;
