'use strict';

var tar = require('tar'),
    fs = require('fs'),
    path = require('path'),
    zlib = require('zlib'),
    fstream = require('fstream'),
    request = require('request'),
    temp = require('temp'),
    wrench = require('wrench'),
    u = require('./util'),
    cli = require('./cli');

function sendTarGz(dirs, url, version, un, pw, callback, cookie) {
    function filter() {
        return !this.basename.match(/^(\.git|\.svn|\.DS_Store|app\.tar\.gz)/);
    }

    cli.spinner('Packing application...');
    temp.mkdir('acs',function(err, tmpdir) {
        var fn = path.join(tmpdir, 'app.tar.gz');
        var writeStream = fs.createWriteStream(fn);

        var td = path.join(tmpdir, version);
        var node_modules = path.join(td, 'node_modules');

        // copy additional modules
        for ( var c = 0; c < dirs.length; c++) {
            var dir = dirs[c];
            var target = td;
            if (c > 0) {
                var bn = path.basename(dir);
                // if we're copying node_modules, don't nest,
                // just use the contents as the target
                if (bn === 'node_modules') {
                    var listdir = fs.readdirSync(dir);
                    for ( var x = 0; x < listdir.length; x++) {
                        var ltd = path.join(node_modules, listdir[x]);
                        if (!u.exists(ltd)) {
                            wrench.mkdirSyncRecursive(ltd);
                        }
                        wrench.copyDirSyncRecursive(path.join(dir, listdir[x]), ltd);
                    }
                    continue;
                } else {
                    target = path.join(node_modules, bn);
                }
            }
            if (!u.exists(target)) {
                wrench.mkdirSyncRecursive(target);
            }
            wrench.copyDirSyncRecursive(dir, target);
            removeDependencies(target, function(err, packagesBack){
                if(err){
                    callback(err);
                    wrench.rmdirSyncRecursive(tmpdir);
                    return;
                }
                // Remove logs folder
                wrench.rmdirSyncRecursive(path.join(target, 'logs'), true);

                var handledPackages = packagesBack;
                gzipandupload(writeStream, td, filter, fn, tmpdir, cookie, url, handledPackages, un, pw, callback);
            });
        }

    });
}

exports.sendTarGz = sendTarGz;

function gzipandupload(writeStream, td, filter, fn, tmpdir, cookie, url, handledPackages, un, pw, callback){

    var globalConfig = u.getGlobalConfig(),
        defaultConfig = u.getDefaultConfig(),
        proxy = globalConfig.proxy || defaultConfig.proxy || undefined;

    //tar generates proprietary headers (prefixed by NODETAR. or SCHILY.) in some cases. For example, when the length
    //of file name is longer than 256 characters. The proprietary headers may cause untar fail.
    var pack = tar.Pack({noProprietary:true}), gzip = zlib.createGzip(), length = 0;

    gzip.on('data', function(buf) {
        length += buf.length;
    });
    gzip.on('end', function() {
        cli.spinner('Packing application... done\n', true);
        if (handledPackages) {
            if (handledPackages.uninstall.length > 0) {
                console.log('Node modules [' + handledPackages.uninstall + '] will be loaded from npm site by Node.ACS Cloud');
            }
            if (handledPackages.remain.length > 0) {
                console.log('Node modules [' + handledPackages.remain + '] will be loaded from local side');
            }
        }
        console.log('Publishing to cloud...');
    });

    var req_socket = null;

    writeStream.on('close', function() {

        var options = {
            uri: encodeURI(url),
            method: 'POST',
            proxy: proxy,
            headers: {
                'Content-Length' : String(length),
                'Content-Type' : 'application/octet-stream',
                'Content-Disposition' : 'attachment;filename=' + path.basename(fn),
                'Cookie' : cookie
            }
        };

        if (un && pw) {
            options.auth =  {
                user: un,
                password: pw
            };
        }

        var Request = request(options, function(error, response, body) {

            if (error) {
                callback(error);
            }
            if (response.statusCode === 503) {
                callback('Admin server is currently unavailable.');
            }
            if (response.statusCode === 502) {
                callback('Admin server ran into a problem when processing the request.');
            }
            if (response.statusCode !== 200) {
                // XXX res is not defined, probably want to do something
                // else here
                callback('Server returned error status. ' + response.statusCode);
            }
        });

        Request.on('request', function(req) {
            req.on('socket', function(socket) {
                req_socket = socket;
            });

            var finished = false;
            req.on('drain', function() {
                if(req_socket) {
                    var p = req_socket.bytesWritten/length;
                    if(p > 1) {
                        p = 1;
                    }
                    if(!finished) {
                        cli.progress(p);
                    }
                    if(p === 1) {
                        finished = true;
                    }
                } else {
                    cli.progress(1);
                }
            });
        });

        var buf = '', progress = '';
        Request.on('data', function(b) {
            progress += b;
            var n, line;
            while((n = progress.indexOf('|')) !== -1) {
                if(n === 0) {
                    progress = progress.substring(1);
                } else {
                    line = progress.substring(0, n);
                    progress = progress.substring(n);
                    if(line.indexOf('{') !== 0) {
                        console.log(line);
                    } else {
                        buf += line;
                    }
                }
            }
        });

        Request.on('end', function() {
            buf += progress;
            callback(null, buf);
            fs.unlinkSync(fn);
            wrench.rmdirSyncRecursive(tmpdir);
        });

        fs.createReadStream(fn).pipe(Request);
    });

    var stream = fstream.Reader({
        path : td,
        filter : filter,
        type : 'Directory'
    });
    stream.pipe(pack);
    pack.pipe(gzip);
    gzip.pipe(writeStream);
}

function removeDependencies(dir, callback) {
    var npm = require('npm');
    npm.load({prefix : dir, loglevel : 'error'}, function(err) {
        if(err){
            return callback ? callback(err) : null;
        }
        npm.commands.ls(null, true, function(err, data) {
            if(err){
                return callback ? callback(err) : null;
            }
            var packages = Object.keys(data.dependencies);
            var uninstallingPackages = [];
            var remainingPackages = [];
            for (var i=0;i<packages.length;i++){
                var pkgName = packages[i];
                var pkgContent = data.dependencies[pkgName];
                if(!pkgContent.extraneous || pkgContent.name === 'acs') {
                    uninstallingPackages.push(pkgName);
                } else {
                    remainingPackages.push(pkgName);
                }
            }
            npm.commands.uninstall(uninstallingPackages, function(err) {
                if(err){
                    return callback ? callback(err) : null;
                }
                return callback ? callback(null, {'uninstall': uninstallingPackages, 'remain' : remainingPackages}) : null;
            });
        });
    });
}
