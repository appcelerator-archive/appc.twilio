'use strict';

var path = require('path'),
    u = require('../util'),
    fs = require('fs'),
    logger = require('../logger'),
    request = require('request'),
    HandleResult = require('./handleResult'),
    post = require('../post'),
    cli = require('../cli'),
    _ = require('underscore'),
    moment = require('moment'),
    url = require('url');

exports.run = function(args, program) {
    var globalConfig = u.getGlobalConfig(),
        defaultConfig = u.getDefaultConfig(),
        proxy = u.getProxy();

    if (proxy) {
        logger.debug('ACS CLI is using proxy: ' + proxy.server);
        proxy = proxy.url;
    }
    if (globalConfig.publishHost && !program.isCallback) {
        console.log(String(('Admin Hostname: ' + globalConfig.publishHost).grey));
    }

    // attach our authentication
    var cookie = globalConfig.cookie ? String(globalConfig.cookie).split(';')[0] || ['connect-sid', ''].join('=') : '';

    var host = globalConfig.publishHost || defaultConfig.publishHost,
        port = globalConfig.publishPort || defaultConfig.publishPort,
        p = '/publish/',
        serverUrl = host + ':' + port + p;

    if (program.list_versions) {
        checkVersions();
    } else if (program.set_active_version) {
        changeVersion();
    } else if (program.git) {
        publishFromGit();
    } else if (program.force) {
        forcePublish();
    } else {
        publishFromDir();
    }

    function checkVersions() {
        var name = program.list_versions === true ? null : program.list_versions,
            appname = u.getAppName(args, program, name);
        serverUrl += appname;

        var parsedUrl = url.parse(serverUrl);
        parsedUrl.query = {};
        if (program.org) {
            parsedUrl.query.orgid = program.org;
        }
        serverUrl = url.format(parsedUrl);

        var HR = new HandleResult();
        HR.succeed = function(response, result) {
            console.log(result.message);
        };

        request({
            uri: encodeURI(serverUrl),
            method: 'GET',
            proxy: proxy,
            headers: {
                'Cookie': cookie,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        }, HR.handler);
    }

    function changeVersion() {
        var appname = u.getAppName(args, program),
            version = program.set_active_version;
        serverUrl += appname + '/' + version;

        var parsedUrl = url.parse(serverUrl);
        parsedUrl.query = {};
        if (program.org) {
            parsedUrl.query.orgid = program.org;
        }
        serverUrl = url.format(parsedUrl);

        var HRC = new HandleResult();
        HRC.checkResult = function(response, result) {
            if (!result.success) {
                if (result.message) {
                    u.die(result.message + ' ' + (result.extended || ''), result.errcode ? result.errcode : 1);
                } else {
                    u.die('Failed to validate the version: ' + result);
                }
            }
            program.confirm('Do you want to deploy version ' + version + ' published at ' + new Date(result.message) + '? ', function(ok) {
                if (ok) {
                    doChange();
                } else {
                    process.exit();
                }
            });
        };

        request({
            uri: encodeURI(serverUrl),
            method: 'GET',
            proxy: proxy,
            headers: {
                'Cookie': cookie,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        }, HRC.handler);


        function doChange() {
            var HR = new HandleResult();
            request({
                uri: encodeURI(serverUrl),
                method: 'POST',
                proxy: proxy,
                headers: {
                    'Cookie': cookie,
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
            }, HR.handler);
        }
    }


    /**
     * When user uses '--force' option with app name as parameter
     * we don't know whether the app was published from git or from local dir
     * In this case, we'll sent a request first to check the app publish location
     * If the app was publish from git, then we'll use the git config stored in
     * the server to redo the publish
     * otherwise, we'll do the normal publish processes for local dir
     */
    function forcePublish() {
        var name = program.force === true ? null : program.force,
            appname = u.getAppName(args, program, name);
        serverUrl += appname + '/1';

        var parsedUrl = url.parse(serverUrl);
        parsedUrl.query = {};
        if (program.org) {
            parsedUrl.query.orgid = program.org;
        }
        serverUrl = url.format(parsedUrl);

        var options = {
            uri: encodeURI(serverUrl),
            method: 'PUT',
            proxy: proxy,
            headers: {
                'Cookie': cookie,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        };

        if (args.length === 2) {
            options.auth = {
                user: args[0],
                password: args[1]
            };
        }

        var Request = request(options, function(error, response, body) {
            if (error) {
                u.die(u.getConnectionErrorMsg(error, body));
            }
            if (response.statusCode === 503) {
                u.die("Admin server is currently unavailable.");
            }
            if (response.statusCode === 502) {
                u.die('Admin server ran into a problem when processing the request.');
            }
            if (response.statusCode === 404) {
                u.die(body);
            }
        });

        var buf = '',
            progress = '';
        Request.on('data', function(b) {
            progress += b;
            var n, line;
            while ((n = progress.indexOf('|')) !== -1) {
                if (n === 0) {
                    progress = progress.substring(1);
                } else {
                    line = progress.substring(0, n);
                    progress = progress.substring(n);
                    if (line.indexOf('{') !== 0) {
                        console.log(line);
                    } else {
                        buf += line;
                    }
                }
            }
        });

        Request.on('end', function() {
            buf += progress;
            var result = {};
            try {
                result = JSON.parse(buf);
            } catch (e) {
                u.die(buf);
            }
            if (result.success) {
                handlePublishResult(null, buf);
            } else {
                // for 201(app not found) and 288(app was not published from git) we should call normal publish
                if (result.errcode === 201 || result.errcode === 288) {
                    // reset url here
                    serverUrl = host + ':' + port + p;
                    publishFromDir();
                } else if (result.errcode && result.errcode === 100) {
                    // stop spinner if current command is 'publish'
                    u.requireLogin(function() {
                        require('./publish').run(args, program);
                    });

                } else {
                    console.log();
                    u.die(result.message, result.errcode ? result.errcode : 1);
                }
            }
        });
    }


    function publishFromGit() {
        var gitConfig = program.git;
        // the user has two ways to specify the git config
        //  1. acs publish â€”git repo=https://github.com/rdong/gitTestApp.git, branch=master, username=uname, access_token=****, npm_username=npmuname, npm_password=****
        //  2. acs publish --git git.config
        //      the content of the git.config should be like below:
        //      {
        //          "repo": "https://github.com/appcelerator/myapp.git",
        //          "branch": "1.1.1",
        //          "access_token": "your_access_token" // your personal-access-tokens generated from git hub, used as password
        //      }

        var configObj = {},
            result;
        var eqSign = gitConfig.indexOf('=');
        if (eqSign === -1) {
            var f = gitConfig;
            if (!u.exists(f)) {
                var dir = process.cwd();
                f = path.join(dir, gitConfig);
                if (!u.exists(f)) {
                    u.die('Git configuration file not found. Please specify a valid git configuration file.'.red);
                } else {
                    result = u.readAndValidateGitConfig(f);
                    if (!result.success) {
                        u.die(result.message);
                    }
                    configObj = result.config;
                }
            } else {
                result = u.readAndValidateGitConfig(f);
                if (result.success === false) {
                    u.die(result.message);
                }
                configObj = result.config;
            }
        } else {
            var vars = program.git.split(',');
            for (var i = 0; i < vars.length; i++) {
                var arg = vars[i];
                eqSign = arg.indexOf('=');
                if (eqSign === -1) {
                    u.die('Invalid git configuration item: ' + arg);
                }
                var key = arg.substring(0, eqSign);
                if (key.length === 0) {
                    u.die('Invalid git configuration item: ' + arg);
                }
                var value = arg.substring(eqSign + 1, arg.length);
                if (value.length === 0) {
                    u.die('Invalid git configuration item: ' + arg);
                }
                configObj[key] = value;
            }
            if (!configObj.repo) {
                u.die('Invalid git configuration, should have \'repo\'');
            }
        }

        serverUrl += program.force ? 1 : 0;
        var parsedUrl = url.parse(serverUrl);
        parsedUrl.query = {};
        if (program.org) {
            parsedUrl.query.orgid = program.org;
        }
        if (program.delete_oldest) {
            parsedUrl.query.delete_oldest = program.delete_oldest;
        }
        serverUrl = url.format(parsedUrl);

        doPublish(serverUrl, configObj);

        function doPublish(serverUrl, configObj) {

            var options = {
                uri: encodeURI(serverUrl),
                method: 'POST',
                proxy: proxy,
                headers: {
                    'Cookie': cookie,
                    'Content-Type': 'application/json'
                }
            };

            var newConfigObj = _.clone(configObj);

            if (args.length === 2) {
                options.auth = {
                    user: args[0],
                    password: args[1]
                };
            }

            options.body = JSON.stringify(newConfigObj);

            var Request = request(options, function(error, response, body) {
                if (error) {
                    u.die(u.getConnectionErrorMsg(error, body));
                }
                if (response.statusCode === 503) {
                    u.die("Admin server is currently unavailable.");
                }
                if (response.statusCode === 502) {
                    u.die('Admin server ran into a problem when processing the request.');
                }
                if (response.statusCode === 404) {
                    u.die(body);
                }
            });

            var buf = '',
                progress = '';
            Request.on('data', function(b) {
                progress += b;
                var n, line;
                while ((n = progress.indexOf('|')) !== -1) {
                    if (n === 0) {
                        progress = progress.substring(1);
                    } else {
                        line = progress.substring(0, n);
                        progress = progress.substring(n);
                        if (line.indexOf('{') !== 0) {
                            console.log(line);
                        } else {
                            buf += line;
                        }
                    }
                }
            });

            Request.on('end', function() {
                buf += progress;
                var result = {};
                try {
                    result = JSON.parse(buf);
                } catch (e) {
                    u.die(buf);
                }
                if (result.success) {
                    handlePublishResult(null, buf);
                } else {
                    if (result.errcode === 201 || result.errcode === '201' ||
                        result.errcode === 'ENOEXISTS') {
                        var appname;
                        if (result.extend && result.extend.name) {
                            appname = result.extend.name;
                            if (result.extend.gitdir) {
                                newConfigObj.gitdir = result.extend.gitdir;
                            }
                        } else {
                            u.die("Can not get the name of app");
                        }
                        // prompt for creating a new app
                        program.confirm('It looks like you don\'t have this app created on Node.ACS yet. \nDo you want to create it for publishing now (yes/no)? ', function(ok) {
                            if (ok) {
                                console.log('Creating new Node.ACS app...');
                                var newAppURL = (globalConfig.publishHost || defaultConfig.publishHost) + ':' +
                                    (globalConfig.publishPort || defaultConfig.publishPort) +
                                    '/create/' + appname;
                                createNewApp(newAppURL, null, serverUrl, null, null, null, null, newConfigObj, 'git', doPublish);
                            } else {
                                process.exit();
                            }
                        });
                    } else if (result.errcode && result.errcode === 100) {
                        // stop spinner if current command is 'publish'
                        u.requireLogin(function() {
                            require('./' + publish).run(args, program);
                        });
                    } else if (result.errcode === 212 || result.errcode === '212') {
                        handleTooManyVersions(result, null, serverUrl, null, null, null, null, newConfigObj, 'git', doPublish);       
                    } else {
                        console.log();
                        u.die(result.message, result.errcode ? result.errcode : 1);
                    }
                }
            });
        }
    }

    function publishFromDir() {

        var dir = program.dir || process.cwd();
        var f = path.join(dir, 'package.json');
        if (!u.exists(f)) {
            u.die('Couldn\'t find app directory for publishing');
        }

        var config = {};
        // validate package.json

        var result = u.readAndValidateConfig(f);
        if (result.success === false) {
            u.die(result.message);
        }
        config = result.config;

        if (!config.version) {
            u.die('Please provide a valid version for your app in the package.json before continuing'.red);
        }
        var version = config.version;

        if (config.npmAuthentication === true) {
            var auth = u.getNPMAuth();
            if (auth && args.length === 0) {
                doPublish(auth.user, auth.password);
            } else {
                if (process.stdin.resume) {
                    process.stdin.resume();
                }
                u.getUsername(args, 'npm username:', function uncb(un) {
                    if (!un) {
                        u.getUsername(args, 'npm username:', uncb);
                        return;
                    }
                    u.getPassword(args, 'npm password:', function pwcb(pw) {
                        if (!pw) {
                            u.getPassword(args, 'npm password:', pwcb);
                            return;
                        }

                        doPublish(un, pw);
                    });
                });
            }
        } else {
            doPublish();
        }

        function doPublish(un, pw) {
            serverUrl += [config.name, config.version, (program.force ? 1 : 0)].join('/');
            var parsedUrl = url.parse(serverUrl);
            parsedUrl.query = {};
            if (program.org) {
                parsedUrl.query.orgid = program.org;
            }
            if (program.async) {
                parsedUrl.query.async = program.async;
            }
            if (program.delete_oldest) {
                parsedUrl.query.delete_oldest = program.delete_oldest;
            }
            if (program.inplace) {
                parsedUrl.query.inplace = program.inplace;
            }
            serverUrl = url.format(parsedUrl);

            cli.spinner('Preparing application for publish...');

            var dirs = [dir];

            var HR = new HandleResult();
            HR.cli = cli;
            HR.reqParams = ['publish', args, program];
            HR.checkResult = function(response, result) {
                if (result.success) {
                    cli.spinner('Preparing application for publish... done\n', true);
                    publish(dirs, serverUrl, config, cookie, version, un, pw);
                } else {
                    // TODO, the string comparison here can probably be dropped
                    if (result.errcode === 201 || result.errcode === '201' ||
                        result.errcode === 'ENOEXISTS') {
                        // prompt for creating a new app
                        cli.spinner('Preparing application for publish... \n', true);
                        program.confirm('It looks like you don\'t have this app created on Node.ACS yet. \nDo you want to create it for publishing now (yes/no)? ', function(ok) {
                            if (ok) {
                                console.log('Creating new Node.ACS app...');
                                var newAppURL = (globalConfig.publishHost || defaultConfig.publishHost) + ':' +
                                    (globalConfig.publishPort || defaultConfig.publishPort) +
                                    '/create/' + config.name;
                                createNewApp(newAppURL, dirs, serverUrl, config, version, un, pw, null, 'dir', publish);
                            } else {
                                process.exit();
                            }
                        });
                    } else if (result.errcode === 212 || result.errcode === '212') {
                        handleTooManyVersions(result, dirs, serverUrl, config, version, un, pw, null, 'dir', publish);        
                    } else {
                        console.log();
                        u.die(result.message, result.errcode ? result.errcode : 1);
                    }
                }
            };

            request({
                uri: encodeURI(serverUrl),
                method: 'GET',
                proxy: proxy,
                headers: {
                    'Cookie': cookie,
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
            }, HR.handler);
        }
    }

    function handleTooManyVersions(result, dirs, serverUrl, config, version, un, pw, configObj, where, callback) {
        var publishes = [], versions = []; 
        var separator = '\t';
        result.publishes.forEach(function(publish) {
            var tmpVersion = publish.version;
            versions.push(tmpVersion);
            if (publish.currentVersion === true) {
                tmpVersion += '\(*\)';
            }
            publishes.push(tmpVersion + separator + moment(publish.created_at).format() + separator + publish.publisher);
        });
        cli.spinner('Preparing application for publish... \n', true);
        console.log(result.message + ' You have to unpublish an old version to continue.');
        console.log('Please choose which version you want to unpublish(the one with * is the current version):');
        console.log('  Version\tPublished At\t\t\tPublished By');
        program.choose(publishes, function(i) {
            console.log('Unpublishing ' + versions[i] + ' of ' + config.name + '...');
            var unpublishURL = (globalConfig.publishHost || defaultConfig.publishHost) + ':' +
                (globalConfig.publishPort || defaultConfig.publishPort) +
                '/unpublish/' + config.name + '/' + versions[i];
            unpublishApp(unpublishURL, dirs, serverUrl, config, version, un, pw, configObj, where, callback);
        });
    }

    function createNewApp(newAppURL, dirs, serverUrl, config, version, un, pw, configObj, where, callback) {
        var HR2 = new HandleResult();
        HR2.errorMessage = 'Unable to create new app';
        HR2.checkResult = function(response, result) {
            if (!result.success) {
                // TODO, the string comparison here can probably
                // be dropped
                if (result.errcode === 265 ||
                    result.errcode === '265') {
                    // prompt for choose an organization
                    var orgs = [],
                        orgids = [],
                        orgid;
                    for (orgid in result.organizations) {
                        if (result.organizations.hasOwnProperty(orgid)) {
                            orgids.push(orgid);
                            var org = '';
                            org += result.organizations[orgid].name;
                            org += (' (' + orgid + ')');
                            orgs.push(org);
                        }
                    }

                    console.log('You belong to more than one organization. Please choose one for the app.');
                    program.choose(orgs, function(i) {
                        var orgid = orgids[i];
                        console.log('Creating new Node.ACS app for organization ' + orgs[i] + '...');
                        request({
                            uri: encodeURI(newAppURL),
                            method: 'POST',
                            proxy: proxy,
                            headers: {
                                'Cookie': cookie,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                orgid: orgid
                            })
                        }, HR2.handler);

                    });
                } else {
                    var message = result.extended || result.message;
                    u.die('Unable to create new app: ' + message, result.errcode ? result.errcode : 1);
                }
            } else {
                cli.spinner('Creating new Node.ACS app...done', true);
                cli.spinner('Preparing application for publish... done\n', true);
                if (where === 'dir') {
                    callback(dirs, serverUrl, config, cookie, version, un, pw);
                } else {
                    callback(serverUrl, configObj);
                }
            }
        };

        var body = {};
        if (program.org) {
            body.orgid = program.org;
        }

        request({
            uri: encodeURI(newAppURL),
            method: 'POST',
            proxy: proxy,
            headers: {
                'Cookie': cookie,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        }, HR2.handler);

    }

    function unpublishApp(unpublishURL, dirs, serverUrl, config, version, un, pw, configObj, where, callback) {
        var HR2 = new HandleResult();
        
        if (program.org) {
            unpublishURL += ('?orgid=' + program.org);
        }

        HR2.succeed = function(response, result) {
            cli.spinner(result.message, true);
            if (where === 'dir') {
                callback(dirs, serverUrl, config, cookie, version, un, pw);
            } else {
                callback(serverUrl, configObj);
            }
        };

        request({
            uri: encodeURI(unpublishURL),
            method: 'POST',
            proxy: proxy,
            headers: {
                'Cookie': cookie,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        }, HR2.handler);
    }
};

function publish(dirs, serverUrl, config, cookie, version, un, pw) {
    post.sendTarGz(dirs, serverUrl, config.version, un, pw, handlePublishResult, cookie);
}

function handlePublishResult(err, buf) {
    if (err) {
        u.die('Error publishing app. ' + err);
    }
    try {
        var result = {};
        try {
            result = JSON.parse(buf);
        } catch (e) {
            u.die(buf);
        }
        if (!result.success) {
            if (result.meta) {
                console.log();
                u.die('Publish Error: ' + result.meta.message, result.errcode ? result.errcode : 1);
            } else {
                u.die('Publish Error: ' + result.message, result.errcode ? result.errcode : 1);
            }
        } else if (result.async) {
            console.log('App ' + result.name.blue + ' version ' + result.version.blue + ' starts to publish on cloud side. Please list app to check result.');
            process.exit();
        } else {
            if (result.name && result.version) {
                console.log('App ' + result.name.blue + ' version ' + result.version.blue + ' published.');
            } else {
                console.log('App published.');
            }
            if (result.url) {
                console.log('App will be available at ' + result.url.cyan);
                process.exit();
            }
        }
    } catch (E) {
        u.die('Error retrieving result ' + E + '. Result was ' + buf);
    }
}
