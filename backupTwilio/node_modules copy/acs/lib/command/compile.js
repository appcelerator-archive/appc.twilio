'use strict';

/**
 * This command will compile our JS bindings for Titanium client into a specific directory
 * so that our serverside services can be automatically used in Titanium without having to
 * write a bunch of client side XHR/REST code.  This provides a nicer OO type interface to
 * Titanium developers by simply using a CommonJS code pattern for your ACS services.
 */
var fs = require('fs'),
    path = require('path'),
    u = require('../util.js'),
    logger = require('../logger.js'),
    syntaxCheck = require('../syntaxcheck'),
    _ = require('underscore')._;

var HEADER = '/**\n' +
             ' * This is generated code - it will be overwritten. Do not modify.\n' +
             ' * Copyright (c) 2012 by Appcelerator, Inc. All Rights Reserved.\n' +
             ' */\n\n';
var DEFAULT_URL = 'http://localhost:8080';
var BASE_KEY = 'acs-service-baseurl-';


function compileService(config, projectdir, cb) {
    var services = [];
    var multiplePathsCallbacks = {}; //for checking callbacks with multiple paths
    if(config && _.isArray(config.routes)) {
        var i;
        for(i in config.routes) {
            if(config.routes.hasOwnProperty(i)) {
                var service = {};
                var route = config.routes[i];
                if(!route.method) {
                    service.method = 'GET';
                } else {
                    switch(route.method.toLowerCase()) {
                    case 'get':
                        service.method = 'GET';
                        break;
                    case 'post':
                        service.method = 'POST';
                        break;
                    case 'put':
                        service.method = 'PUT';
                        break;
                    case 'delete':
                        service.method = 'DELETE';
                        break;
                    case 'options':
                        service.method = 'OPTIONS';
                        break;
                    }
                }
                if(service.method) {
                    if(route.path && route.callback) {
                        service.path = route.path;
                        service.name = route.callback.replace('#', '_');
                        if(!multiplePathsCallbacks[service.name]) {
                            multiplePathsCallbacks[service.name] = 1;
                        } else {
                            var times = multiplePathsCallbacks[service.name];   //time starts from 1
                            logger.warn('Callback ' + route.callback + ' has already ' + times + ' path' + (times>1?'s, ':', ') + 'name function as ' + service.name + times);
                            multiplePathsCallbacks[service.name] = times+1;
                            service.name = service.name + times;
                            times++;
                        }

                        checkFile(projectdir, route.callback.substring(0, route.callback.indexOf('#')), false);
                        services.push(service);
                    }
                }
            }
        }
    }
    cb(services);
}

function checkFile(projectdir, fileName, main) {
    var file;
    try {
        if(main) {
            file = path.resolve(projectdir, fileName);
        } else {
            file = path.resolve(projectdir, 'controllers', fileName + '.js');
        }
        var code = fs.readFileSync(file, "utf8");
        var err = syntaxCheck(code, file);
        if(err) {
            u.die(err);
        }
    } catch (E) {
        u.die(E);
    }
}

function genCode(entry) {

    var code = [], signature = [], body = [];

    signature.push('function(data');

    var params = u.parseUrlPath(entry.path);
    if(params.length > 0) {
        params.forEach(function(param) {
            signature.push(', ' + param.name);
            if(!param.optional) {
                body.push("   if(!" + param.name + ") throw '" + param.name + " is required!';\n");
            }
            param.index = entry.path.indexOf('/:' + param.name);
            param.length = ('/:' + param.name).length;
            if(param.optional) {
                param.length++; //count '?' in
            }
        });
    }
    signature.push(', cb) {');

    body.push('   var path = [];\n');
    var start = 0;
    if(params.length > 0) {
        for(var i = 0; i < params.length; i++) {
            var param = params[i];

            if(param.index > start) {
                body.push("   path.push('" + entry.path.substring(start, param.index) + "');\n");
            }
            body.push("   if(" + param.name + ") {\n");
            body.push("      path.push('/' + " + param.name + ");\n");
            body.push("   }\n");

            start = param.index + param.length;
        }

        if(entry.path.length > start) {
            body.push("   path.push('" + entry.path.substring(start) + "');\n");
        }

    } else {
        body.push("   path.push('" + entry.path + "');\n");
    }

    body.push("   InvokeService(path.join(''), ");
    body.push('"');
    body.push(entry.method);
    body.push('", data, cb);');

    code.push(signature.join(''));
    code.push(body.join(''));
    code.push('};\n');
    return code.join('\n');
}

function compile(project, cb) {
    var config = project.config;
    var projectdir = project.basedir;
    var key = project.key;

    compileService(config, projectdir, function(services) {
        if (services.length === 0) {
            cb('Project \'' + project.name + '\' does not expose any services');
        } else {
            var code = [];

            code.push('function InvokeService(path, method, data, cb) {');
            code.push('   if (typeof(data) == "function") {');
            code.push('      cb = data; data = null;');
            code.push('   }');
            code.push('   if (typeof(cb) !== "function")');
            code.push('      throw new Error("callback must be provided!");');
            code.push('   var xhr = Ti.Network.createHTTPClient();');
            code.push('   xhr.onerror = function(e) {');
            code.push('      cb(e.error);');
            code.push('   };');
            code.push('   xhr.onload = function(e) {');
            code.push('      var r = this.responseText;');
            code.push('      try {');
            code.push('         if (xhr.getResponseHeader("content-type").indexOf("json") != -1) {');
            code.push('             r = JSON.parse(r);');
            code.push('         }');
            code.push('      } catch (E) {}');
            code.push('      cb(null, r);');
            code.push('   };');
            code.push('   if(exports.URL.match(\'/$\') == \'/\' && path.indexOf(\'/\') == 0) {');
            code.push('       xhr.open(method, exports.URL + path.substring(1));');
            code.push('   } else {');
            code.push('       xhr.open(method, exports.URL + path);');
            code.push('   }');
            code.push('   xhr.send(data);');
            code.push('};\n');

            code.push('var url = Ti.App.Properties.getString("' + key + '");\n');
            code.push('if(!url) throw new Error("Url not found by ' + key + '.");');
            code.push('if(url.replace(/^\\s+|\\s+$/g, "")) {');
            code.push('   exports.URL = url.replace(/^\\s+|\\s+$/g, "");');
            code.push('} else {');
            code.push('   exports.URL = "' + DEFAULT_URL + '";');
            code.push('}\n');

            _.each(services, function(service) {
                code.push('exports.' + service.name + ' = ' + genCode(service));
            });

            var src = HEADER + code.join('\n');
            cb(null, src);
        }
    });
}

exports.run = function(args, opts) {
    if (args.length < 2) {
        u.die("You must provide an OUTDIR and ALIAS");
    }
    var outdir = path.resolve(args[0]);
    var alias = args[1];
    var projectdir = path.resolve(opts.dir || process.cwd());
    var cfg = u.readConfig(projectdir);

    if (!u.exists(outdir)) {
        fs.mkdirSync(outdir);
    }

    // trim off the trailing /
    var project = cfg;
    if(project && project.framework === u.framework_mvc) {
        checkFile(projectdir, project.main, true);
        var config = path.join(projectdir, 'config.json');
        if(!u.exists(config)) {
            u.die('Cannot load file \'config.json\'.');
        }
        try {
            project.config = JSON.parse(fs.readFileSync(config, "utf-8"));
        } catch(e) {
            u.die('Cannot load file \'config.json\'. ' + e);
        }

        project.key = BASE_KEY + alias;
        project.basedir = projectdir;
        var outfile = path.join(outdir, 'ti.cloud.' + project.name + '.js');

        if(u.exists(outfile)) {
            u.die("'" + outfile + "' already exists!");
        }

        compile(project, function(err, src) {
            if(err) {
                u.die(err);
            }
            fs.writeFileSync(outfile, src, 'utf-8');
            logger.info('Generated file: \'' + outfile + '\'');
            logger.info('Compile succeed!');
            process.stdout.write(project.key);
        });
    } else {
        u.die('Cannot compile project with framework is not \'mvc\'.');
    }
};