'use strict';

var u = require('../util.js'),
    logger = require('../logger.js'),
    program = require('commander'),
    moment = require('moment'),
    fs = require('fs'),
    path = require('path'),
    request = require('request'),
    _ = require('underscore')._,
    zlib = require('zlib'),
    util = require('util'),
    timer,
    lastLogDateTimeStamp = 'NODATETME';

exports.run = function(args, opts) {
    // console.log('Retrieves the latest log files from the server');

    var globalConfig = u.getGlobalConfig(),
        defaultConfig = u.getDefaultConfig(),
        proxy = u.getProxy();

    if(proxy) {
        logger.debug('ACS CLI is using proxy: ' + proxy.server);
        proxy = proxy.url;
    }
    if(globalConfig.publishHost && !opts.isCallback) {
        console.log(String(('Admin Hostname: ' + globalConfig.publishHost).grey));
    }

    var cookie = globalConfig.cookie ? String(globalConfig.cookie).split(';')[0] || [ 'connect-sid', '' ].join('=') : '';

    if (opts.build_log && (opts.server_id || opts.show_serverid)) {
        u.die('When retrieving build logs, cannot assign or show server_id');
    }
    if (opts.build_log) {
        console.log('Retrieving build log from the server');
    } else {
        console.log('Retrieving debug log from the server');
    }

	var name = null;
	if(opts.show_serverid) {
		name = opts.show_serverid === true ? null : opts.show_serverid;
	}

	var appname = u.getAppName(args, opts, name);

    /**
     * Nettle will fetch logs periodically by the interval intervalToGetLogs
     */
    var intervalToGetLogs = 5000; //the interval time is 5000 milseconds by default.

    try {
        if (opts.interval) {
            var re = /^[0-9]+.?[0-9]*$/;
            if (!re.test(opts.interval)) {
                u.die('Please enter a valid interval!'.red);
            } else if (opts.interval >= 5) {
                intervalToGetLogs = opts.interval * 1000;
            }
        }
    } catch (error) {
        u.die('Error occured:' + error);
    }

    var body = {};

    // Get server id variable
    var serverid = (opts.server_id === undefined ? 'NOSERVERID' : opts.server_id);

    var reqpath;
    if (appname) {
        if (opts.build_log) {
            reqpath = '/buildlog/' + appname + '/';
        } else {
            reqpath = '/log/' + appname + '/' + serverid + '/';
        }
    } else {
        u.die("App name is required.");
    }

    function getLogs() {

        var url = (globalConfig.publishHost || defaultConfig.publishHost) + ':' + (globalConfig.publishPort || defaultConfig.publishPort) + reqpath + lastLogDateTimeStamp + '/NODATETME/LATEST/100';

        if(opts.org) {
            url += ('?orgid=' + opts.org);
        }

        var rawResBody;
        request({
            uri: encodeURI(url),
            method: opts.build_log?'GET':'POST',
            proxy: proxy,
            encoding: null,
            headers: {
                'Cookie' : cookie,
                'Content-Type': 'application/json',
                'accept-encoding' : 'gzip'
            },
            body: JSON.stringify(body)
        }, function(error, response, body){
            if (error) {
                u.die(u.getConnectionErrorMsg(error, body));
            }
            if (response.statusCode === 503) {
                u.die("Admin server is currently unavailable.");
            }
            if (response.statusCode === 502) {
                u.die('Admin server ran into a problem when processing the request.');
            }
            rawResBody = body;
            zlib.gunzip(body, parseResult);
        });

        var parseResult = function(err, unzippedBody) {

            var resbody = unzippedBody;
            if(err) {
                if(err.code === 'Z_DATA_ERROR') { //in case the response body is not zipped
                    resbody = rawResBody;
                } else {
                    u.die(err);
                }
            }

            var result = {};
            try {
                result = JSON.parse(resbody);
            } catch (e) {
                logger.error(resbody);
                return;
            }
            if( result.errcode && result.errcode === 100 ) {
                clearInterval(timer);
                u.requireLogin(function() {
                    process.stdin.destroy();
                    opts.isCallback = true;
                    require('./logcat').run(args, opts);
                });
            } else {
                if (!result.success) {
                    u.die(result.message || util.inspect(result), result.errcode?result.errcode:1);
                    return;
                }
                var len = opts.build_log ? result.buildlogs.length : result.logmessages.length,
                    logmessage;

                for ( var i = len-1; i >= 0; i--) {
                    logmessage = opts.build_log ? result.buildlogs[i] : result.logmessages[i];
                    var msg = logmessage.message;
                    var d = msg.length - '\n'.length;
                    if(d >= 0 && msg.lastIndexOf('\n') === d) {
                        msg = msg.substring(0, d);
                    }
                    if (msg.lastIndexOf("|") === msg.length - 1 ) {
                        msg = msg.substring(0, msg.length - 1);
                    }
                    var output = (logmessage.time ? moment(logmessage.time).format() + ' | ' : '') + ((opts.show_serverid && logmessage.serverid)?'['+logmessage.serverid+'] ':'') + msg;
                    console.log(output);
                }
                if (len > 0) {
                    lastLogDateTimeStamp = opts.build_log ? result.buildlogs[0].time : result.logmessages[0].time;
                }
            }
        };

    }

    getLogs();
    timer = setInterval(getLogs, intervalToGetLogs);
};