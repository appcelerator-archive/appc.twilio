'use strict';

var u = require ('../util.js'),
    querystring = require('querystring'),
    request = require('request'),
    HandleResult = require('./handleResult'),
    logger = require('../logger.js');

var customHost = null, customPort = null;
var hostname_port = null, hostname;
if(process.stdin.resume) {
    process.stdin.resume();
}

/**
 * @param callback perform subsequent task after user login if callback is provided
 */
function login(cfg,un,pw,mid,period,callback) {
    cfg.mid = mid;
    cfg.username = un;
    // u.saveGlobalConfig(cfg);
    var defaultConfig = u.getDefaultConfig(),
        proxy = u.getProxy();

    if(proxy) {
        logger.debug('ACS CLI is using proxy: ' + proxy.server);
        proxy = proxy.url;
    }

    var jsonData = {
        login : un,
        password : pw,
        mid : mid
    };
    if(period) {
        jsonData.period = period;
    }

    var postData = querystring.stringify(jsonData);

    var url = hostname_port + '/login';

    var HR = new HandleResult();
    HR.errorMessage = 'Login failed';
    HR.errorCode = 107;

    HR.errorHandler = function() {
        logger.error('Can not connect to ' + hostname_port + '.');
    };

    HR.succeed = function(response, result) {

        var cookie = response.headers['set-cookie'];

        cfg.cookie = cookie;
        //save the host and port originally configured in .acs. It will be restored when user logout from the custom host.
        if(customHost) {
            if(cfg.publishHost && !cfg.defaultEP) {
                cfg.defaultEP = {};
                cfg.defaultEP.publishHost = cfg.publishHost;
                cfg.defaultEP.publishPort = cfg.publishPort;
            }
            cfg.publishHost = customHost;
            cfg.publishPort = customPort;
        }
        u.saveGlobalConfig(cfg);

        console.log(result.message);
        //perform subsequent task after user login if callback is provided
        if(callback) {
            return callback();
        } else {
            process.exit();
        }
    };

    var cookie = cfg.cookie ? String(cfg.cookie).split(';')[0] || [ 'connect-sid', '' ].join('=') : '';

    request({
        uri: encodeURI(url),
        method: 'POST',
        proxy: proxy,
        headers: {
            'Cookie': cookie,
            'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: postData
    }, HR.handler);

}


exports.run = function(args, opts, callback) {
    if (!u.isOnline()) {
        u.die('You must be connected to the Internet to login. No valid ' +
            'network interface detected.');
    }

    var cfg = u.getGlobalConfig();
    var defaultConfig = u.getDefaultConfig();
    var defaultHost = cfg.publishHost || defaultConfig.publishHost;

    customHost = opts && opts.host && opts.host.trim();
    hostname = customHost;
    //if 'acs login' is issued directly and no custom host specified don't ask for host confirmation
    if(!customHost && !callback) {
        console.log(String(('Admin Hostname: ' + defaultHost).grey));
        hostname = defaultHost;
    }

    u.getHost(args, hostname, function hostcb(host) {

        if(host !== hostname) {
            customHost = host;  //user entered new host when login is required while running other commands
        }
        if(customHost) {
            normalizeCustomHostPort(cfg);
        }

        hostname_port = (customHost || cfg.publishHost || defaultConfig.publishHost) + ':' +
                        (customPort || cfg.publishPort || defaultConfig.publishPort);

        var username = cfg.username;
        u.getUsername(args, username, function uncb(un) {
            if(!un) {
                if(!username) {
                    return u.getUsername(args, username, uncb);
                } else {
                    un = username;
                }
            }
            u.getPassword(args,function pwcb(pw) {
                if(!pw) {
                    return u.getPassword(args, pwcb);
                }
                var period;
                if (args && args.length > 2) {
                    if(!u.isPositiveInt(args[2])) {
                        u.die('Illegal session period!');
                    }
                    period = args[2];
                }
                // only destroy when callback is not provided,
                // or this will break the possible stdin, such as program.confirm in publish.js
                if(!callback) {
                    process.stdin.destroy();
                }
                if (cfg.mid) {
                    if(period) {
                        login(cfg,un,pw,cfg.mid,period,callback);
                    } else {
                        login(cfg,un,pw,cfg.mid,null,callback);
                    }
                } else {
                    u.getMacAddress(function(err,mid) {
                        if(period) {
                            login(cfg,un,pw,mid,period,callback);
                        } else {
                            login(cfg,un,pw,mid,null,callback);
                        }
                    });
                }
            });
        });
    });
};

/**
 * Get the port according to protocol, 80 and 443 are predefined ports.
 */
function normalizeCustomHostPort() {
    if(customHost.indexOf('https') === 0) {
        customPort =  443;
    } else if(customHost.indexOf('http') === 0) {
        customPort =  80;
    } else {
        customHost = 'https://' + customHost;
        customPort = 443;
    }
}
