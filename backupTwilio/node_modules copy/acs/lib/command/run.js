'use strict';

var fs = require('fs'),
    path = require('path'),
    logger = require('../logger'),
    vm = require('vm'),
    wrench = require('wrench'),
    _ = require('underscore')._,
    u = require('../util.js'),
    urllib = require('url'),
    express = require('express'),
    connect = require('connect'),
    uuid = require('node-uuid'),
    program = require('commander'),
    socketio = require('socket.io'),
    http = require('http'),
    realRequire = require,
    npm = require('npm'),
    syntaxCheck = require('../syntaxcheck'),
    S = require('string'),
    domain = require('../domain'),
    io,
    server,
    app = null,
    main_exts = ['.js'],
    global_objects = ['ArrayBuffer', 'Int8Array', 'Uint8Array', 'Uint8ClampedArray', 'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array', 'Float32Array', 'Float64Array', 'DataView', 'Buffer', 'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval'];

var globalProxy = require('../proxy')(global);

var expressMainVersion = express.version.split('.')[0];
if (expressMainVersion > '2') {
    // Use new syntax for express 3.x
    app = express();
} else {
    // Use older one for express 1.x, 2.x
    app = express.createServer();
}

//prepare stacktrace injection code
var code_stub = '';
try {
    var acs_path = path.resolve(__dirname + '/../../');
    code_stub = fs.readFileSync(acs_path + '/lib/stacktrace.js', "utf8");
    code_stub = code_stub.replace('<ACS_PATH>', acs_path);
    code_stub = S(code_stub).replaceAll('\n', '').s;
} catch(e) {
    u.die('Something wrong. Please try reinstall a new Node.ACS CLI.');
}

var controllers = {};
var filters = {};
var websockets = {};

// start from here
exports.run = function(port, dir, config) {
    if(config.framework === u.framework_mvc) {
        u.installDepends(dir, config.dependencies, function(err) {
            if(err) {
                u.die(err.stack);
            }
            runManagedApp(port, dir, config);
        });
    } else if(config.framework === u.framework_none) {
        u.installDepends(dir, config.dependencies, function(err) {
            if(err) {
                u.die(err.stack);
            }
            runFreeApp(dir, config);
        });
    } else {
        u.die('Invalid \'framework\' field in package.json. Available value is \'mvc\' or \'none\'.');
    }
};

function runFreeApp(dir, config) {

    if(!config.main || u.trim(config.main) === '') {

        logger.warn('App does not specify a main script. Will try to use "npm start"');
        if(!config.scripts || !config.scripts.start || config.scripts.start.length === 0) {
            u.die('Neither main nor start script is specified. App cannot be started.');
        }

        var loadOpts = {
            prefix: dir,
            loglevel : 'warn'
        };

        npm.load(loadOpts, function(err) {
            if (err) {
                u.die('npm load err for starting app. ' + err);
            } else {
                npm.start(function(err) {
                    //the callback called only when there is an error
                    if (err) {
                        u.die('npm start err for starting app. ' + err);
                    }
                });
            }
        });
        return;
    }

    dir = path.resolve(dir);
    if(dir.charAt(dir.length - 1) !== '/') {
        if(u.isWin()) {
            dir += '\\';
        } else {
            dir += '/';
        }
    }

    var main = path.resolve(dir, config.main);
    if (!main || main.indexOf(dir) !== 0) {
        u.die("Invalid main script path: '" + config.main + "'. Main script has to be under project root directory.");
    }

    if(u.isDirectory(main)){
        main = path.join(main, 'index.js');
    }

    var mainName = main.replace(dir, '');

    if(!u.exists(main)) {
        var isFound = false;
        for(var i in main_exts) {
            if(u.exists(main + main_exts[i])) {
                isFound = true;
                main += main_exts[i];
                break;
            }
        }
        if(!isFound) {
            u.die('Cannot load main script. \'' + mainName + '\' doesn\'t exist.');
        }
    }

    try {
        var proc = _.clone(process);
        proc.exit = function() {
            //do nothing
        };
        try {
            // create a new script context to run the service
            var baseSandbox =  { process: proc, console: logger, RegExp: RegExp };
            var sandbox = getSandbox(baseSandbox, {dir: path.dirname(main), file: main, projectDir: dir});
            sandbox.global = sandbox.GLOBAL = globalProxy;
            var context = vm.createContext(sandbox);
            var code = fs.readFileSync(main, "utf8");
            var err = syntaxCheck(code, mainName);
            if (err) {
                u.die('Syntax error detected. ' + err);
            }
            vm.runInContext(getCompileCode(code), context, mainName);
        } catch(e) {
            if(e.stack) {
                u.die('Error occurred. ' + e.stack);
            } else {
                u.die('Error occurred. ' + e);
            }
        }
    } catch(e) {
        u.die(e);
    }
}

// start managed app
function runManagedApp(port, dir, config) {
    if(!config.main || u.trim(config.main) === '') {
        u.die('Main script is not defined in package.json!');
    }
    if(u.isDirectory(config.main)){
        u.die('The main script should be a file, instead of a directory.');
    }
    dir = path.resolve(dir);

    // FIXME: this seems to cause problems a lot
    // app.use(connect.compress());

    //app.use(domain());
    app.use(express.methodOverride());
    app.use(express.cookieParser());
    app.use(connect.query());
    app.use(connect.limit('75mb'));
    app.use(express.bodyParser());
    app.use(express.errorHandler({dumpExceptions: true, showStack: true}));
    app.use(function(req, res, next) {
        res.setHeader('X-Powered-By', 'Appcelerator Node.ACS/' + program.version());
        next();
    });

    // set views path
    var viewPath = path.join(dir, 'views');
    app.set('views', viewPath);
    app.set('view engine', 'jade');
    app.set('view engine', 'ejs');

    // set public path
    var publicPath = path.join(dir, 'public');
    app.use(express.static(publicPath));

    if (logger.isColorEnabled()) {
        app.use(express.logger({ format: '[PERF]  '.green + ':method '.white + ':url'.cyan + ' :response-time ms'.yellow }));
    } else {
        app.use(express.logger({ format: '[PERF]  :method  :url :response-time ms'}));
    }

    var proc = _.clone(process);
    proc.exit = function() {};
    var baseSandbox =  {
            process: proc,
            console: logger,
            RegExp: RegExp
    };

    // load main
    var funcs = {};
    try {
        funcs = loadMain(config, dir, baseSandbox);
    } catch(e) {
        if(e.stack) {
            u.die('Error occurred. ' + e.stack);
        } else {
            u.die('Error occurred. ' + e);
        }
    }

    server = http.createServer(app);

    // setup socket.io
    io = socketio.listen(server, {logger: logger});
    io.enable('browser client etag');           // apply etag caching logic based on version number
    io.enable('browser client minification');   // send minified client
    io.enable('browser client gzip');           // gzip the file
    io.set('log level', 1);                     // reduce logging
    io.set('transports', [ 'websocket', 'htmlfile', 'xhr-polling', 'jsonp-polling' ]);
    io.set("polling duration", 10);

    if(funcs.start) {
        try {
            funcs.start(app, express, io);
        } catch(e) {
            if(e.stack) {
                u.die('Error occurred. ' + e.stack);
            } else {
                u.die('Error occurred. ' + e);
            }
        }
    }

    try {
        // load config.js and setup
        loadConfig(dir, app, io, baseSandbox);
    } catch(e) {
        logger.error('Error loading config.json. ' + e);
    }

    // shutdown server
    process.on('exit', function() {
        if(funcs.stop) {
            funcs.stop();
        }
        if (server) {
            if (io) {
                try {
                    io.server.close();
                } catch (err) {
                    if (err.toString() !== 'Error: Not running') {
                        logger.error(err);
                    }
                }
            }
            try {
                server.close();
            } catch(err) {
                if (err.toString() !== 'Error: Not running') {
                    logger.error(err);
                }
            }
            server = null;
            io = null;
        }
    });

    //start listening on port
    server.listen(port);

    logger.info('ACS started on port ' + port);
}

//load main script defined in package.json and return 'start' and 'stop' function handlers if defined
function loadMain(config, projectDir, baseSandbox) {
    var funcs = {};
    if(config && config.main) {
        if(projectDir.charAt(projectDir.length - 1) !== '/') {
            if(u.isWin()) {
                projectDir += '\\';
            } else {
                projectDir += '/';
            }
        }

        var main = path.resolve(projectDir, config.main);
        if (!main || main.indexOf(projectDir) !== 0) {
            u.die("Invalid main script path: '" + config.main + "'. Main script has to be under project root directory.");
        }

        var mainName = main.replace(projectDir, '');

        if(!u.exists(main)) {
            var isFound = false;
            for(var i in main_exts) {
                if(u.exists(main + main_exts[i])) {
                    isFound = true;
                    main += main_exts[i];
                    break;
                }
            }
            if(!isFound) {
                u.die('Cannot load main script. \'' + mainName + '\' doesn\'t exist.');
            }
        }

        var sandbox = getSandbox(baseSandbox, {dir: path.dirname(main), file: main, projectDir: projectDir});
        sandbox.global = sandbox.GLOBAL = globalProxy;
        var context = vm.createContext(sandbox);
        var code = fs.readFileSync(main, "utf8");
        var err = syntaxCheck(code, mainName);
        if (err) {
            u.die('Syntax error detected. ' + err);
        }
        vm.runInContext(getCompileCode(code), context, mainName);
        if(context.start && _.isFunction(context.start)) {
            funcs.start = context.start;
        }

        if(context.stop && _.isFunction(context.stop)) {
            funcs.stop = context.stop;
        }
    }
    return funcs;
}

//load config.json and setup routing, filters and websockets
function loadConfig(projectDir, app, io, baseSandbox) {
    var controllersPath = path.join(projectDir, 'controllers');
    var filtersPath = path.join(projectDir, 'filters');
    var websocketsPath = path.join(projectDir, 'websockets');
    var configure = path.join(projectDir, 'config.json');
    var files, i, name, filePath, sandbox, context, code, err, funcs, key;
    if(u.exists(configure)) {
        // load controllers
        if(u.exists(controllersPath)) {
            files = fs.readdirSync(controllersPath);
            for(i = 0; i < files.length; i++) {
                try {
                    name = files[i].substring(0, files[i].indexOf('.js'));
                    filePath = path.join(controllersPath, files[i]);
                    sandbox = getSandbox(baseSandbox, {dir: controllersPath, file: filePath, projectDir: projectDir});
                    sandbox.global = sandbox.GLOBAL = globalProxy;
                    context = vm.createContext(sandbox);
                    code = fs.readFileSync(filePath, "utf8");
                    err = syntaxCheck(code, '/controllers/' + files[i]);
                    if (err) {
                        u.die('Syntax error detected. ' + err);
                    }
                    vm.runInContext(getCompileCode(code), context, '/controllers/' + files[i]);
                    funcs = {};
                    for(key in context) {
                        if(context.hasOwnProperty(key)) {
                            if(_.isFunction(context[key])) {
                                funcs[key] = context[key];
                            }
                        }
                    }
                    controllers[name] = funcs;
                } catch(e) {
                    if(e.stack) {
                        logger.error('Failed to load controller "' + files[i] + '". ' + e.stack);
                    } else {
                        logger.error('Failed to load controller "' + files[i] + '". ' + e);
                    }
                }
            }
        }

        // load filters
        if(u.exists(filtersPath)) {
            files = fs.readdirSync(filtersPath);
            for(i = 0; i < files.length; i++) {
                try {
                    name = files[i].substring(0, files[i].indexOf('.js'));
                    filePath = path.join(filtersPath, files[i]);
                    sandbox = getSandbox(baseSandbox, {dir: filtersPath, file: filePath, projectDir: projectDir});
                    sandbox.global = sandbox.GLOBAL = globalProxy;
                    context = vm.createContext(sandbox);
                    code = fs.readFileSync(filePath, "utf8");
                    err = syntaxCheck(code, '/filters/' + files[i]);
                    if (err) {
                        u.die('Syntax error detected. ' + err);
                    }
                    vm.runInContext(getCompileCode(code), context, '/filters/' + files[i]);
                    funcs = {};
                    for(key in context) {
                        if(context.hasOwnProperty(key)) {
                            if(_.isFunction(context[key])) {
                                funcs[key] = context[key];
                            }
                        }
                    }
                    filters[name] = funcs;
                } catch(e) {
                    if(e.stack) {
                        logger.error('Failed to load filter "' + files[i] + '". ' + e.stack);
                    } else {
                        logger.error('Failed to load filter "' + files[i] + '". ' + e);
                    }
                }
            }
        }

        // load websockets
        if(u.exists(websocketsPath)) {
            files = fs.readdirSync(websocketsPath);
            for(i = 0; i < files.length; i++) {
                try {
                    name = files[i].substring(0, files[i].indexOf('.js'));
                    filePath = path.join(websocketsPath, files[i]);
                    sandbox = getSandbox(baseSandbox, {dir: websocketsPath, file: filePath, projectDir: projectDir});
                    sandbox.global = sandbox.GLOBAL = globalProxy;
                    context = vm.createContext(sandbox);
                    code = fs.readFileSync(filePath, "utf8");
                    err = syntaxCheck(code, '/websockets/' + files[i]);
                    if (err) {
                        u.die('Syntax error detected. ' + err);
                    }
                    vm.runInContext(getCompileCode(code), context, '/websockets/' + files[i]);
                    funcs = {};
                    for(key in context) {
                        if(context.hasOwnProperty(key)) {
                            if(_.isFunction(context[key])) {
                                funcs[key] = context[key];
                            }
                        }
                    }
                    websockets[name] = funcs;
                } catch(e) {
                    if(e.stack) {
                        logger.error('Failed to load websocket service "' + files[i] + '". ' + e.stack);
                    } else {
                        logger.error('Failed to load websocket service "' + files[i] + '". ' + e);
                    }
                }
            }
        }

        // setup path mappings
        var config = JSON.parse(fs.readFileSync(configure, 'utf8'));
        var routesConfig = config.routes;
        var filtersConfig = config.filters;
        var websocketsConfig = config.websockets;
        var index, map, func, filter, ctrl;

        // we should load filters before routes
        if(filtersConfig && _.isArray(filtersConfig)) {
            for(index in filtersConfig) {
                if(filtersConfig.hasOwnProperty(index)) {
                    map = filtersConfig[index];
                    if(map && map.path && map.callback) {
                        name = map.callback.split('#')[0];
                        func = map.callback.split('#')[1];
                        filter = filters[name];
                        if(filter) {
                            if(filter[func]) {
                                app.use(map.path, filter[func]);
                            }
                        }
                    }
                }
            }
        }

        if(routesConfig && _.isArray(routesConfig)) {
            for(index in routesConfig) {
                if(routesConfig.hasOwnProperty(index)) {
                    map = routesConfig[index];
                    if(map && map.path && map.callback) {
                        var method = '';
                        if(!map.method) {
                            method = 'get';
                        } else {
                            method = map.method.toLowerCase();
                        }
                        name = map.callback.split('#')[0];
                        func = map.callback.split('#')[1];
                        ctrl = controllers[name];
                        if(ctrl) {
                            if(ctrl[func]) {
                                switch(method) {
                                case 'get':
                                    app.get(map.path, ctrl[func]);
                                    break;
                                case 'post':
                                    app.post(map.path, ctrl[func]);
                                    break;
                                case 'put':
                                    app.put(map.path, ctrl[func]);
                                    break;
                                case 'delete':
                                    app.delete(map.path, ctrl[func]);
                                    break;
                                case 'options':
                                    app.options(map.path, ctrl[func]);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        if(websocketsConfig && _.isArray(websocketsConfig) && websocketsConfig.length > 0) {
            io.on('connection', function(socket) {
                if (!socket) {
                    logger.error('Error in socket connection.');
                }
                // var sessionid = socket.sessionid = uuid.v4().replace('-', '0');
                // logger.debug('websocket connected for session ' + sessionid);

                var index, map, name, func, websocket;
                for(index in websocketsConfig) {
                    if(websocketsConfig.hasOwnProperty(index)) {
                        map = websocketsConfig[index];
                        if(map && map.event && map.callback) {
                            name = map.callback.split('#')[0];
                            func = map.callback.split('#')[1];
                            websocket = websockets[name];
                            if(websocket) {
                                if(websocket[func]) {
                                    registerWebsocketEvent(socket, map.event, websocket[func]);
                                }
                            }
                        }
                    }
                }
            });
        }
    }
}

function registerWebsocketEvent(socket, event, callback) {
    socket.on(event, function(data) {
        try {
            callback(data, socket);
        } catch(e) {
            if(e.stack) {
                logger.error(e.stack);
            } else {
                logger.error(e);
            }
        }
    });
}

function getSandbox(base, data) {
    var sandbox = {};
    var exports = {};
    var module = {exports: exports};
    var key;
    if(base && data) {
        for (key in base) {
            if(base.hasOwnProperty(key)) {
                sandbox[key] = base[key];
            }
        }

        for (key in global_objects) {
            if(global_objects.hasOwnProperty(key)) {
                sandbox[global_objects[key]] = global[global_objects[key]];
            }
        }

        sandbox.__dirname = data.dir;
        sandbox.__filename = data.file;
        sandbox.exports = exports;
        sandbox.module = module;
        sandbox.require = _.bind(safeRequire, {dirname: data.dir, projectDir: data.projectDir});
    }
    return sandbox;
}

function safeRequire(name) {
    return wrappedRequire.call(this, name);
}

function wrappedRequire(name) {
    // force the path relative to the service directory
    if (name.charAt(0) === '.') {
        name = path.join(this.dirname, name);
        return realRequire(name);
    }

    if (name.charAt(0) === '/') {
        name = path.join(this.projectDir, name);
        return realRequire(name);
    }

    /*
    switch (name) {
    case 'vm':
    case 'repl':
    case 'tty':
    case 'readline':
        logger.error('Unsafe require "' + name + '"');
        return null;	// return null to deny loading the module
        break;
    }
    */

    var r;
    try {
        // turn to absolute path for correct reference
        r = realRequire(path.join(this.projectDir, 'node_modules', name));
    } catch(e) {
        //logger.debug('Cannot find module "' + name + '" under node_modules, try global. ' + e);
        try {
            r = realRequire(name);
        } catch(e) {
            logger.error('Cannot find module. "' + name + '". ' + e);
        }
    }
    return r;
}

function getCompileCode(code) {
    return code_stub + code;
}
