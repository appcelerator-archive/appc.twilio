<h1 id="heading-api-reference"><a name="heading-api-reference">API Reference</a></h1><p>This section covers the basics for creating API endpoints.  API endpoints are automatically generated for all Arrow models, but there may be cases where you will want to create your own custom API.  The following section describe how to do that.</p>
<h2 id="heading-endpoint-definition"><a name="heading-endpoint-definition">Endpoint Definition</a></h2><p>The sample code below demonstrates how to create an API endpoint in Javascript.  API endpoint definitions should be placed in the <code>apis</code> directory of your project.</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> TestAPI = Arrow.API.extend({
    <span class="hljs-attr">name</span>: <span class="hljs-string">'test'</span>,
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/api/test/:id'</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">'this is an api that shows how to implement an API'</span>,
    <span class="hljs-attr">model</span>: <span class="hljs-string">'user'</span>,
    <span class="hljs-attr">before</span>: <span class="hljs-string">'formatRequestBlock'</span>,  <span class="hljs-comment">// you can specify a single block to execute</span>
    after: [<span class="hljs-string">'cachingBlock'</span>, <span class="hljs-string">'analyticsBlock'</span>], <span class="hljs-comment">// you can specify an array of blocks to execute</span>
    parameters: {
        <span class="hljs-comment">// 'id' is required to execute this endpoint</span>
        id: { <span class="hljs-attr">description</span>:<span class="hljs-string">'the user id'</span>}
    },
    <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, resp, next</span>) </span>{
        <span class="hljs-comment">// call the 'find' method on our model to get the data passing the incoming path value id</span>
        resp.stream(req.model.find, req.params.id, next);
    }
});

<span class="hljs-built_in">module</span>.exports = TestAPI;</pre><h2 id="heading-api-properties"><a name="heading-api-properties">API Properties</a></h2><p>The table below outlines the properties supported by an API endpoint.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>group</td>
<td>true</td>
<td>The logical name for grouping API endpoints.</td>
</tr>
<tr>
<td>path</td>
<td>true</td>
<td>Request path (e.g., ‘/api/user/:id’).</td>
</tr>
<tr>
<td>method</td>
<td>true</td>
<td>HTTP verb (‘GET’, ‘POST’, ‘PUT’, or ‘DELETE’).</td>
</tr>
<tr>
<td>enabled</td>
<td>false</td>
<td>Whether or not the API is enabled. If not, it won’t be registered, and won’t accept requests.</td>
</tr>
<tr>
<td>sort</td>
<td>false</td>
<td>An integer determining the order in which the APIs will be registered. APIs with a higher “sort” value will be prioritized, and will this be registered earlier. For example, say you have /api/:id and /api/foo. If the API with the wildcard has a higher sort than the static API, the static API will never get to run. So create the first with a lower sort, and /api/foo will route properly, as will /api/bar.</td>
</tr>
<tr>
<td>documented</td>
<td>false</td>
<td>Used to determine whether to generate API documentation.  The default value is <code>true</code>.</td>
</tr>
<tr>
<td>description</td>
<td>true</td>
<td>Description of the endpoint, which is used in the generation of the API endpoint documentation.</td>
</tr>
<tr>
<td>model</td>
<td>true</td>
<td>The model to use for the response.  An API endpoint can only specify <strong>one</strong> model, but model’s can be composed of other models and fields.  </td>
</tr>
<tr>
<td>response</td>
<td>false</td>
<td>The response model for the API.  This should only be used if your request and response models are different.</td>
</tr>
<tr>
<td>plural</td>
<td>false</td>
<td>A string used as the property name when your API endpoint returns an array.  By default, the plural value is the plural of the model name.  For example, if your model is named <strong>car</strong>, the default plural would be <strong>cars</strong>.  Note: this value can be set on an API or a model.</td>
</tr>
<tr>
<td>singular</td>
<td>false</td>
<td>A string used as the property name when your API endpoint returns a single record.  By default, the singular value is the name of the model. Note: this value can be set on an API or a model.</td>
</tr>
<tr>
<td>before</td>
<td>false</td>
<td>One or more blocks to be executed before the request.  Blocks are referenced by their <code>name</code> property.  If you want to execute multiple blocks, you should specify them as an array of block names.  If multiple blocks are specified, they are executed in the order specified.</td>
</tr>
<tr>
<td>after</td>
<td>false</td>
<td>One or more blocks to be executed after the request.  Blocks are referenced by their <code>name</code> property.  If you want to execute multiple blocks, you should specify them as an array of block names.  If multiple blocks are specified, they are executed in the order specified.</td>
</tr>
<tr>
<td>parameters</td>
<td>false</td>
<td>Input parameters required to execute the API endpoint.  This value should be an object of key/value pairs.  The supported keys for each parameter are:  <code>optional</code> (is the parameter always required: true or false), <code>type</code> (the type of input parameter: ‘query’ (default), ‘path’ or ‘body’), and <code>description</code> (used for generating API documentation).</td>
</tr>
<tr>
<td>action</td>
<td>true</td>
<td>Function that is called to execute the API endpoint’s logic.</td>
</tr>
</tbody>
</table>
<p>The <code>action</code> function should implement your API’s logic.  You can use this function to make programmatic calls to your model’s methods for reading or writing data (e.g., <code>req.model.findByID</code>, <code>req.model.findAll</code>, <code>req.model.update</code>, etc.) and to do other things related to the custom business logic of your API endpoint including making calls to other node modules that your API endpoint requires.</p>
<h2 id="heading-custom-api-logic"><a name="heading-custom-api-logic">Custom API Logic</a></h2><p>The <code>action</code> function of an API definition is the place where you can perform custom business logic for your API.  This is also where you can leverage the programmatic CRUD interfaces on your model.</p>
<p>It receives two or three arguments. The first two will always be <code>req</code> and <code>res</code>.</p>
<p><code>req</code> is short for Request, which is equivalent to the ExpressJS <code>Request</code> object, defined here: <a href="http://expressjs.com/en/api.html#req">http://expressjs.com/en/api.html#req</a><br><code>res</code> is short for Response, which is equivalent to the ExpressJS <code>Response</code> object, defined here: <a href="http://expressjs.com/en/api.html#res">http://expressjs.com/en/api.html#res</a></p>
<p>If you add a third argument to your <code>action</code> function definition, it should be named <code>next</code>. This flags your action as<br>being async. In this case, you should always make sure that your <code>action</code> function calls the <code>next</code> function regardless<br>of if the result is a success or an error.</p>
<p>Here is an example:</p>
<pre class="highlight javascript">action: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) </span>{

    <span class="hljs-comment">// setup query options</span>
    <span class="hljs-keyword">var</span> options = {
        <span class="hljs-attr">where</span>: { <span class="hljs-attr">fname</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">'%custom%'</span> } }
    };
    <span class="hljs-comment">// execute query</span>
    model.query(options, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, coll</span>) </span>{
        <span class="hljs-keyword">if</span> (e) {
            req.log.error(<span class="hljs-string">'ERROR on query:'</span>,e);
            <span class="hljs-keyword">return</span> next(e); <span class="hljs-comment">// call next with with a new Javascript Error object or a error String</span>
        }
        req.log.info(<span class="hljs-string">'query successful'</span>);
        next(<span class="hljs-literal">null</span>, coll); <span class="hljs-comment">// call next with our result set.  The first argument is the error object, which is null for success</span>
    });

}</pre><p>In the above example, we query our model. In the case of an error, we call <code>next(e)</code>.  In the case of success, we<br>call <code>next(null, coll)</code>.  The first argument of the <code>next</code> function is error (either a Javascript Error object or<br>an error message String), which should be null for success.</p>
<p>Alternatively, you can provide a synchronous definition of an action:</p>
<pre class="highlight javascript">action: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>{
    req.log.info(<span class="hljs-string">'query successful'</span>);
    res.json({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> });
}</pre>