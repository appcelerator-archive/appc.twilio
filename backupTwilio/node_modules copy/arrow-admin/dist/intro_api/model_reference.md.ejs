<h1 id="heading-model-reference"><a name="heading-model-reference">Model Reference</a></h1><p>This section covers the basics for creating and using models.</p>
<h2 id="heading-model-definition"><a name="heading-model-definition">Model Definition</a></h2><p>Model definitions should be placed in the <code>models</code> directory of your project.  By default, API endpoints are automatically generated for any models that you create.  For example, if I create a model named ‘user’, the following endpoints would be generated if <code>autogen</code> is true for the model (which it is by default).  </p>
<ul>
<li><code>GET /api/user</code> : Return all users (the first 1000 records).</li>
<li><code>GET /api/user/query</code> : Return all users that satisfy a query.  See <code>Querying interface</code> below for more detail.</li>
<li><code>GET /api/user/:id</code> : Return a specific user by id</li>
<li><code>GET /api/user/distinct/:field</code> : Find distinct users</li>
<li><code>GET /api/user/count</code> : Count users</li>
<li><code>PUT /api/user/:id</code> : Update a specific user by id</li>
<li><code>PUT /api/user/findAndModify</code> : Find and modify a user</li>
<li><code>POST /api/user</code> : Create a new user</li>
<li><code>POST /api/user/upsert</code> : Create or update a user</li>
<li><code>DELETE /api/user/:id</code> : Delete a specific user by id</li>
<li><code>DELETE /api/user</code> : Delete all users</li>
</ul>
<p>The model will automatically call the corresponding methods on its configured connector to complete these requests.  When endpoints are generated for your models, no additional coding is necessary.</p>
<p>The <code>autogen</code> property can be set to false in the model definition (see Model Properties below for more detail).  If it’s set to false, API endpoints will not be automatically generated for your model.</p>
<p>Here’s a simple example of a Model definition:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> SampleModel = Arrow.createModel(<span class="hljs-string">'sample'</span>, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">first_name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">'the first name'</span> },
        <span class="hljs-attr">last_name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">'the last name'</span> },
        <span class="hljs-attr">email</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">'the email'</span> }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'memory'</span>
});

<span class="hljs-built_in">module</span>.exports = SampleModel;</pre><h2 id="heading-model-properties"><a name="heading-model-properties">Model Properties</a></h2><p>The table below outlines the properties supported by Models.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>fields</td>
<td>true</td>
<td>An object that represents the model’s schema.  In the example above, there are three model fields.  The <code>fields</code> object also supports a number of sub-properties defined the next table.</td>
</tr>
<tr>
<td>connector</td>
<td>true</td>
<td>Connector to which the model is bound (string).  Each model can only have <strong>one</strong> connector.  Connectors are responsible for reading and writing data from/to their data source.</td>
</tr>
<tr>
<td>metadata</td>
<td>false</td>
<td>Used to provide connector specific configuration (e.g., mapping the model to a specific database table for the MySQL connector or defining the join properties (see Composite Models for more information).</td>
</tr>
<tr>
<td>autogen</td>
<td>false</td>
<td>Used to determine whether to generate API endpoints directly from the model.  The default value is <code>true</code>.  If the endpoint is auto-generated, you do not need to create an API endpoint definition.</td>
</tr>
<tr>
<td>actions</td>
<td>false</td>
<td>An array of data operations supported by the model.  The valid values are: ‘create’, ‘read’, ‘update’, and ‘delete’.  By default all are supported by the model.</td>
</tr>
<tr>
<td>disabledActions</td>
<td>false</td>
<td>An array of data operations not supported by the model.  The valid values are: ‘create’, ‘read’, ‘update’, and ‘delete’. Placing a value here will prevent matching auto-generated endpoints from being created.</td>
</tr>
<tr>
<td>plural</td>
<td>false</td>
<td>A string used as the property name when your API endpoint returns an array.  By default, the plural value is the plural of the model name.  For example, if your model is named <strong>car</strong>, the default plural would be <strong>cars</strong>.  Note: this value can be set on an API or a model.</td>
</tr>
<tr>
<td>singular</td>
<td>false</td>
<td>A string used as the property name when your API endpoint returns a single record.  By default, the singular value is the name of the model. Note: this value can be set on an API or a model.</td>
</tr>
<tr>
<td>cache</td>
<td>false</td>
<td>A boolean or object value defining a cache. If set to true or a plain object, then findAll, findByID, and simple counts will be cached. Create will cache findByID, and other writes or deletes will invalidate either all or some of the cache. Cached results will last for 10 minutes, by default. Provide <code>cache: { maxAge: timeInMS }</code> to customize this.   </td>
</tr>
<tr>
<td>before</td>
<td>false</td>
<td>One or more blocks to be executed before the request.  Blocks are referenced by their <code>name</code> property.  If you want to execute multiple blocks, you should specify them as an array of block names.  If multiple blocks are specified, they are executed in the order specified.</td>
</tr>
<tr>
<td>after</td>
<td>false</td>
<td>One or more blocks to be executed after the request.  Blocks are referenced by their <code>name</code> property.  If you want to execute multiple blocks, you should specify them as an array of block names.  If multiple blocks are specified, they are executed in the order specified.</td>
</tr>
<tr>
<td>pre</td>
<td>false</td>
<td>alias for before; see documentation above for more information.</td>
</tr>
<tr>
<td>post</td>
<td>false</td>
<td>alias for after; see documentation above for more information.</td>
</tr>
<tr>
<td>before$METHOD$</td>
<td>false</td>
<td>One or more blocks to be executed before the request to a particular method. This could be “beforeQuery”, “beforeDelete”, etc. See “before” above for more information.</td>
</tr>
<tr>
<td>after$METHOD$</td>
<td>false</td>
<td>One or more blocks to be executed after the request to a particular method. This could be “afterQuery”, “afterDelete”, etc. See “after” above for more information.</td>
</tr>
<tr>
<td>beforeEvent</td>
<td>false</td>
<td>event name, when specified, will fire an event using the value to the Appcelerator PubSub Server where the payload if the value of the incoming request parameters (same as <code>req.params</code>)</td>
</tr>
<tr>
<td>afterEvent</td>
<td>false</td>
<td>event name, when specified, will fire an event using the value to the Appcelerator PubSub Server where the payload if the value of the outgoing response payload (same as <code>resp.body</code>)</td>
</tr>
<tr>
<td>eventTransformer</td>
<td>false</td>
<td>function, when specified, will be called to transform the data payload sent to the Appcelerator PubSub Server (only applicable for beforeEvent and afterEvent).</td>
</tr>
<tr>
<td>before$METHOD$Event</td>
<td>false</td>
<td>same as beforeEvent above, except for a particular Method.</td>
</tr>
<tr>
<td>after$METHOD$Event</td>
<td>false</td>
<td>same as afterEvent above, except for a particular Method.</td>
</tr>
<tr>
<td>$METHOD$EventTransformer</td>
<td>false</td>
<td>same eventTransformer above, except for a particular Method.</td>
</tr>
<tr>
<td>documented</td>
<td>false</td>
<td>Used to determine whether to generate API documentation.  The default value is <code>true</code>.</td>
</tr>
<tr>
<td>description</td>
<td>false</td>
<td>The description of the model (used for API documentation).</td>
</tr>
<tr>
<td>createDescription</td>
<td>false</td>
<td>The description of the create API (used for API documentation); defaults to “Create a {singular}”.</td>
</tr>
<tr>
<td>updateDescription</td>
<td>false</td>
<td>The description of the update API (used for API documentation); defaults to “Update a specific {singular}”.</td>
</tr>
<tr>
<td>deleteDescription</td>
<td>false</td>
<td>The description of the delete one API (used for API documentation); defaults to “Delete a specific {singular}”.</td>
</tr>
<tr>
<td>deleteAllDescription</td>
<td>false</td>
<td>The description of the delete all API (used for API documentation); defaults to “Deletes all {plural}”.</td>
</tr>
<tr>
<td>distinctDescription</td>
<td>false</td>
<td>The description of the distinct API (used for API documentation); defaults to “Find distinct {plural}”.</td>
</tr>
<tr>
<td>findByIDDescription</td>
<td>false</td>
<td>The description of the find one API (used for API documentation); defaults to “Find one {singular}”.</td>
</tr>
<tr>
<td>findAndModifyDescription</td>
<td>false</td>
<td>The description of the find and modify API (used for API documentation); defaults to “Find and modify {plural}”.</td>
</tr>
<tr>
<td>findAllDescription</td>
<td>false</td>
<td>The description of the find all API (used for API documentation); defaults to “Find all {plural}”.</td>
</tr>
<tr>
<td>countDescription</td>
<td>false</td>
<td>The description of the count API (used for API documentation); defaults to “Count {plural}”.</td>
</tr>
<tr>
<td>upsertDescription</td>
<td>false</td>
<td>The description of the upsert API (used for API documentation); defaults to “Create or update a {singular}”.</td>
</tr>
<tr>
<td>queryDescription</td>
<td>false</td>
<td>The description of the query API (used for API documentation); defaults to “Query {plural}”.</td>
</tr>
</tbody>
</table>
<p>You can also define custom properties on the model.  The most common use case is to define business logic methods on your model (e.g., calculate sales tax).</p>
<h2 id="heading-field-properties"><a name="heading-field-properties">Field Properties</a></h2><p>The <code>fields</code> property (mentioned above) supports a number of sub-properties as well.  The table below outlines these properties.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>true</td>
<td>The field type (e.g., ‘string’).  Type can be any valid Javascript primitive type.  Type can be specified as a string (e.g., ‘string’) or by the type class (e.g., String).</td>
</tr>
<tr>
<td>required</td>
<td>false</td>
<td>Specifies whether the field is required.  The default value is <code>false</code>.</td>
</tr>
<tr>
<td>validator</td>
<td>false</td>
<td>A function or regular expression that validates the value of the field.  The function should return <code>null</code> or <code>undefined</code> if the validation succeeds.  Any other return value means the validation failed, and the return value will be used in the exception message.  If a regular expression is used, it should evaluate to true or false.</td>
</tr>
<tr>
<td>name</td>
<td>false</td>
<td>Used if the model field name is different than the field name in the connector’s model or the underlying data source for the field name.  For example, if my model field is <code>first_name</code> and the column in a MySQL database is <code>fname</code>, the value of the <code>name</code> property should be <code>&#39;fname&#39;</code>.</td>
</tr>
<tr>
<td>default</td>
<td>false</td>
<td>The default value for the field.</td>
</tr>
<tr>
<td>description</td>
<td>false</td>
<td>The description of the field (used for API documentation).</td>
</tr>
<tr>
<td>readonly</td>
<td>false</td>
<td>Either <code>true</code> or <code>false</code>.  If <code>true</code> the field will be readonly and any attempt to write the field value will fail.</td>
</tr>
<tr>
<td>maxlength</td>
<td>false</td>
<td>The max length of the field (specified as an integer)</td>
</tr>
<tr>
<td>get</td>
<td>false</td>
<td>A function used to set the value of a property that will be sent to the client.  This property is useful if you want to define a custom field where the value is derived.</td>
</tr>
<tr>
<td>set</td>
<td>false</td>
<td>A function used to set the value of a property that will be sent to the connector.</td>
</tr>
<tr>
<td>custom</td>
<td>false</td>
<td>This property should be specified and set to <code>true</code> if you are defining a custom field.  A custom field is one that does not exist in the underlying data source for the connector you specified.</td>
</tr>
<tr>
<td>model</td>
<td>false</td>
<td>Model name of the field property.  This is either the logical name of a custom model or a connector model name in the form <strong>connector/model_name</strong> (e.g., appc.mysql/employee)</td>
</tr>
</tbody>
</table>
<h2 id="heading-class-methods"><a name="heading-class-methods">Class Methods</a></h2><p>Each model has several class methods. These are called on the <code>Model</code> itself, not on a particular instance of a model.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Arguments</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>extend</td>
<td>sourceModel, newModel, props</td>
<td>If <code>sourceModel</code> is specified, a new model is created based on this model.  If <code>sourceModel</code> is omitted, then an empty model is created.  <code>props</code> can be any of the properties supported by a model.</td>
</tr>
<tr>
<td>reduce</td>
<td>sourceModel, newModel, props</td>
<td>If <code>sourceModel</code> is specified, a new model is created based on this model based on the fields defined in the <code>fields</code> property.  If <code>sourceModel</code> is omitted, then an empty model is created.  <code>props</code> can be any of the properties supported by a model.</td>
</tr>
<tr>
<td>getConnector</td>
<td>dontRaiseException</td>
<td>Retrieves the connector for this model; the optional argument <code>dontRaiseException</code> allows you to control if exceptions should be thrown during the connector load process.</td>
</tr>
<tr>
<td>setConnector</td>
<td>connector</td>
<td>Sets the connector that this model will use.</td>
</tr>
<tr>
<td>instance</td>
<td>values, skipNotFound</td>
<td>Creates an instance of the model from the provided values. Provide the optional argument <code>skipNotFound</code> to skip fields in the <code>values</code> that aren’t in the <code>fields</code> definition for the model.</td>
</tr>
<tr>
<td>create</td>
<td>values, callback</td>
<td>Creates a new Model or Collection object.</td>
</tr>
<tr>
<td>update</td>
<td>instance, callback</td>
<td>Updates a Model instance.  You can optionally provide a <code>callback</code> function that will be called after the update is executed. Instead of an instance, you can provide a partial object that has, minimally, <code>{ id: aRowID, andAnyFields: youWantToUpdate }</code>.</td>
</tr>
<tr>
<td>delete</td>
<td>instance, callback</td>
<td>Deletes the model instance.</td>
</tr>
<tr>
<td>deleteAll</td>
<td>callback</td>
<td>Deletes all instances.</td>
</tr>
<tr>
<td>distinct</td>
<td>field, options, callback</td>
<td>Finds unique values using the provided field.</td>
</tr>
<tr>
<td>findByID</td>
<td>id, callback</td>
<td>Finds a model instance using the primary key.</td>
</tr>
<tr>
<td>findAndModify</td>
<td>options, doc, args, callback</td>
<td>Finds one model instance and modifies it. <code>options</code> should be a query to identify the instances to update, <code>doc</code> should be a set of updates, and <code>args</code> optionally controls what to do with new and existing matches; specify “upsert” or “insert” as true to create records when none exist, and “update” as true to update records. </td>
</tr>
<tr>
<td>findAll</td>
<td>callback</td>
<td>Finds all model instances.  A maximum of 1000 models are returned.</td>
</tr>
<tr>
<td>count</td>
<td>options, callback</td>
<td>Gets a count of instances. <code>options</code> is optional, but should be a query to identify matching instances when provided.</td>
</tr>
<tr>
<td>upsert</td>
<td>id, doc, callback</td>
<td>Updates a model or creates the model if it cannot be found.</td>
</tr>
<tr>
<td>query</td>
<td>options, callback</td>
<td>Queries for particular model instances.</td>
</tr>
</tbody>
</table>
<h2 id="heading-instance-methods"><a name="heading-instance-methods">Instance Methods</a></h2><p>Each model has a number of instance methods.  The table below outlines the supported methods:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Arguments</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>set</td>
<td>key, value</td>
<td>Set a field value.  The key is the field name and the value is the new value.</td>
</tr>
<tr>
<td>get</td>
<td>key</td>
<td>Get a field value.  The key is the field name.</td>
</tr>
<tr>
<td>getConnector</td>
<td>none</td>
<td>Get the connector instance for the model.</td>
</tr>
<tr>
<td>setPrimaryKey</td>
<td>key, value</td>
<td>Set the primary key for the model.  The key is the field name and the value is the new value. Note: this is only used by a connector</td>
</tr>
<tr>
<td>getPrimaryKey</td>
<td>none</td>
<td>Get the primary key value for the model.</td>
</tr>
<tr>
<td>setMeta</td>
<td>key,default</td>
<td>Set a metadata key/value pair.  The key is the property name and the value is the new value.  Note: this method is only used by a connector.</td>
</tr>
<tr>
<td>getMeta</td>
<td>key</td>
<td>Return a meta data object where <code>key</code> is the property you want to retrieve.  Note: this method is only used by a connector.</td>
</tr>
<tr>
<td>toPayload</td>
<td>none</td>
<td>Returns the payload that will be passed to a connector’s data source.  Note: this method is only used by a connector.</td>
</tr>
<tr>
<td>isUnsaved</td>
<td>none</td>
<td>Returns true if the model has unsaved changes.</td>
</tr>
<tr>
<td>isDeleted</td>
<td>none</td>
<td>Returns true if the model instance has been deleted from the root data source.</td>
</tr>
<tr>
<td>getChangedFields</td>
<td>none</td>
<td>Returns an array of field names that have been changed but not saved.</td>
</tr>
<tr>
<td>keys</td>
<td>none</td>
<td>Returns an array field names that are the primary keys for the model.</td>
</tr>
<tr>
<td>update</td>
<td>callback</td>
<td>Save changes you have made to the model via <code>set</code>.  You can optionally provide a <code>callback</code> function that will be called after the update is executed.</td>
</tr>
<tr>
<td>delete</td>
<td>callback</td>
<td>Delete the model instance.  You can optionally provide a <code>callback</code> function that will be called after the delete is executed.</td>
</tr>
<tr>
<td>extend</td>
<td>name</td>
<td>Extend an existing model.  The method takes a <code>name</code> argument which should be the model that is being extended.  Extending a model creates a new model with all of the fields from the extended model plus any new fields you add.</td>
</tr>
<tr>
<td>reduce</td>
<td>name</td>
<td>Reduce an existing model.  The method takes a <code>name</code> argument which should be the model that is being reduced.  Reducing a model creates a new model with only the fields you specify in the <code>fields</code> property.  You can also add custom fields to the new model.</td>
</tr>
</tbody>
</table>
<h2 id="heading-model-creation"><a name="heading-model-creation">Model Creation</a></h2><p>There are two ways models are created: <code>custom</code> and <code>generated</code>.  A custom model is one that you define using the Model Definition syntax or using the Model Wizard.  Generated models are created automatically by connectors that integrate with a data source that has a well-known schema.  For example, the Salesforce, MySQL and Microsoft Azure MSSQL connectors all generate models from their underlying schema.  The benefit of this is that you can either turn these models into API endpoints automatically or you can use them to create new custom models.  To do this, you would either <code>extend</code> or <code>reduce</code> one of these existing models.  Any model (custom or generated) can be extended or reduced.  </p>
<p>The next few sections demonstrate how to do this.</p>
<h2 id="heading-reduce-a-model"><a name="heading-reduce-a-model">Reduce a Model</a></h2><p>Here are some examples of creating new models from existing models using the <code>reduce</code> function, which allows you to specify a subset of the underlying properties or columns of a object, table or model.</p>
<h3 id="heading-mysql-example"><a name="heading-mysql-example">MySQL Example</a></h3><p>The following example creates a model based an <strong>employee</strong> table in MySQL.  It uses <code>reduce</code> to use a subset of the table’s columns.</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> baseEmp = Arrow.Model.reduce(<span class="hljs-string">'appc.mysql/employee'</span>,<span class="hljs-string">'baseEmp'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">fname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'First name'</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'first_name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>},
        <span class="hljs-attr">lname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Last name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'last_name'</span>},
        <span class="hljs-attr">email</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Email address'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'email_address'</span>}
    }
});

<span class="hljs-built_in">module</span>.exports = baseEmp;</pre><p>The first argument of <code>reduce</code> should be the model that you are extending.  In this case, we are reducing a MySQL generated model.  The syntax for addressing an underlying connector model is: <strong>connector_name/model_name</strong> (e.g., appc.mysql/employee).  The second argument is the name of your new model.  The other thing to note is that the <code>name</code> property for each field definition is used to map the model’s property names to MySQL column names.  This is optional, but it allows you to have model property names that are different than the property (or column) names of the underlying model.</p>
<p>This model uses the MySQL connector.  In this case, the model does not need to explicitly set the connector property (e.g., <code>connector: &#39;appc.mysql&#39;</code>) since the connector is implied through the first argument of reduce (<code>appc.mysql/employee</code>).</p>
<h3 id="heading-salesforce-example"><a name="heading-salesforce-example">Salesforce Example</a></h3><p>The following example creates a model based the <strong>Account</strong> object in Salesforce.</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> myAcct = Arrow.Model.reduce(<span class="hljs-string">'appc.salesforce/Account'</span>,<span class="hljs-string">'myAcct'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Name'</span> },
        <span class="hljs-attr">type</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Type'</span> }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.salesforce'</span>
});

<span class="hljs-built_in">module</span>.exports = myAcct;</pre><p>This example is similar to the previous MySQL example.  We are creating a new model based on the Salesforce Account object.  This new model only contains two properties: name and type - hence the use of the <code>reduce</code> function.</p>
<h2 id="heading-extend-a-model"><a name="heading-extend-a-model">Extend a Model</a></h2><p>The <code>extend</code> Model function allows you to create a new model that inherits everything from the source model with the ability to change it and/or add to it.</p>
<h3 id="heading-extend-mysql-example"><a name="heading-extend-mysql-example">Extend MySQL Example</a></h3><p>This example takes our first MySQL employee model and adds a custom property to it (tax_rate):</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> extendedEmp = Arrow.Model.extend(<span class="hljs-string">'appc.mysql/employee'</span>, <span class="hljs-string">'extendedEmp'</span>, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">tax_rate</span>: {
            <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>,
            <span class="hljs-attr">custom</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, key, model</span>) </span>{
                <span class="hljs-keyword">var</span> state = model.get(<span class="hljs-string">'state'</span>);
                <span class="hljs-keyword">switch</span> (state) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'CA'</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0.129</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'TX'</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'GA'</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0.07</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'NY'</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0.09</span>;
                    <span class="hljs-keyword">default</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                }
            }
        }
    }
});

<span class="hljs-built_in">module</span>.exports = extendedEmp;</pre><p>In this example, the model will contain all of the columns from the MySQL employee table plus the <code>tax_rate</code> property which is set based on the value of state property for each employee record.  There are a few concepts to understand here.  First, we are using the <code>custom</code> property to indicate that this model contains a property (tax_rate) that is derived in some way (i.e., not stored in the underlying data source).  We are also using the <code>get</code> property to define a function that sets the value of the custom property.  You should use <code>get</code> to set the value of a property when sending a response to the client, and use <code>set</code> to set the value of a property when sending data back to the data source.</p>
<h3 id="heading-extend-an-existing-model"><a name="heading-extend-an-existing-model">Extend an Existing Model</a></h3><p>You can also use <code>extend</code> on an custom (i.e., not generated by a connector) model.  The next example extends the previous model and adds a headquarters property.</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> fullEmp = Arrow.Model.extend(<span class="hljs-string">'extendedEmp'</span>, <span class="hljs-string">'fullEmp'</span>, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">headquarters</span>: {
            <span class="hljs-attr">type</span>: <span class="hljs-built_in">Boolean</span>,
            <span class="hljs-attr">custom</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, key, model</span>) </span>{
                <span class="hljs-keyword">return</span> model.get(<span class="hljs-string">'state'</span>) === <span class="hljs-string">'CA'</span>;
            }
        }
    }
});

<span class="hljs-built_in">module</span>.exports = fullEmp;</pre><p>The first arugment is the name of the model to be extended (<strong>extendedEmp</strong>).  The second argument is the name of the new model.  This model will have everything in the <strong>extendedEmp</strong> model plus a new property named <strong>headquarters</strong>.  Like tax_rate, headquarters is a custom property whose value is set based on the value of the state column for each employee record.</p>
<h2 id="heading-schema-less-models"><a name="heading-schema-less-models">Schema-less Models</a></h2><p>If you are creating a model for a schema-less data source like MongoDB, Appcelerator’s Cloud Database or the Memory connector, you should use the <code>createModel</code> function. Here’s an example:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> employeeCity = Arrow.createModel(<span class="hljs-string">'employeeCity'</span>, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">employeeId</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">Number</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">'This employee id'</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },
        <span class="hljs-attr">city</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">'Favorite city'</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> }
    }
    connector: <span class="hljs-string">'appc.mongo'</span>
});

<span class="hljs-built_in">module</span>.exports = employeeCity;</pre><p>This model will allow you to create, read, update and delete employeeCity objects in a MongoDB instance.</p>
<h2 id="heading-composite-models"><a name="heading-composite-models">Composite Models</a></h2><p>Composite models allow you create a single model that is composed of two or more models based on the same or different connectors.  Composite models can be joined together via a common set of properties (e.g., primary or foreign keys) or they can have no properties in common at all.  The power of composite models is that you can represent multiple data sources and entities as a single API endpoint, which is ideal for many mobile use cases.</p>
<h3 id="heading-left-join-using-two-models"><a name="heading-left-join-using-two-models">Left Join Using Two Models</a></h3><p>Let’s say we have a model “employee”, which contains a list of all employees and their “manager_id”. We also have a<br>model “manager” which contains a list of all managers. We can do a left join from employees to managers to fetch the<br>employee and their manager in one go. A left join will return results from the main model along with any matching<br>records resulting from the join. Here is a simple example of this using two models backed by MySQL tables:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-built_in">module</span>.exports = Arrow.createModel(<span class="hljs-string">'employeeWithManager'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">employee_name</span>: { <span class="hljs-attr">model</span>: <span class="hljs-string">'employee'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'first_name'</span>, <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> },
        <span class="hljs-attr">manager_name</span>: { <span class="hljs-attr">model</span>: <span class="hljs-string">'manager'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'first_name'</span>, <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.composite'</span>,
    <span class="hljs-attr">metadata</span>: {
        <span class="hljs-attr">left_join</span>: {
            <span class="hljs-attr">model</span>: <span class="hljs-string">'manager'</span>,
            <span class="hljs-attr">join_properties</span>: {
                <span class="hljs-attr">employee_id</span>: <span class="hljs-string">'id'</span>
            }
        }
    }
});</pre><p>The first thing to notice is that the model uses the <strong>appc.composite</strong> connector.  All composite models <strong>must</strong> use<br>the appc.composite connector.</p>
<p>The example above creates a single model composed of properties from two different models. The property<br><code>employee_name</code> comes from the <code>employee</code> model below:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-built_in">module</span>.exports = Arrow.Model.reduce(<span class="hljs-string">'appc.mysql/employee'</span>, <span class="hljs-string">'employee'</span>, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">first_name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.mysql'</span>
});</pre><p>And the <code>manager_name</code> property comes from the <code>manager</code> model below:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-built_in">module</span>.exports = Arrow.Model.reduce(<span class="hljs-string">'appc.mysql/employee_manager'</span>, <span class="hljs-string">'manager'</span>, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">first_name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> },
        <span class="hljs-attr">employee_id</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span> }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.mysql'</span>
});</pre><p>The join configuration is specified in the <code>metadata</code> property of the composite model. It specifies a left join with<br>the <strong>manager</strong> model (so <strong>employee</strong> is the main model and <strong>manager</strong> is the joined model) and the composite model<br>is joining employees by <strong>manager_id</strong> with the primary key of managers (<strong>id</strong>).</p>
<p><strong>NOTE:  When creating composite models with join properties, you can currently only specify WHERE clause properties on<br>the main model when performing a query against it.</strong></p>
<h3 id="heading-left-join-using-connector-models-objects"><a name="heading-left-join-using-connector-models-objects">Left Join Using Connector Models/Objects</a></h3><p>The previous example created a composite model using two existing custom models.  You can also create composite models<br>directly from connector generated models.  Here’s an example of the same composite model as above but it uses the<br>connector’s models directly:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-built_in">module</span>.exports = Arrow.createModel(<span class="hljs-string">'employeeWithManager'</span>, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">employee</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'first_name'</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mysql/employee'</span> },
        <span class="hljs-attr">manager</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'first_name'</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mysql/employee_manager'</span> }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.composite'</span>,
    <span class="hljs-attr">metadata</span>: {
        <span class="hljs-attr">left_join</span>: {
            <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mysql/employee_manager'</span>,
            <span class="hljs-attr">join_properties</span>: {
                <span class="hljs-attr">employee_id</span>: <span class="hljs-string">'id'</span>
            }
        }
    }
});</pre><p>The only difference between this model and the previous composite model is that we directly address the connector’s<br>models via the <code>model</code> property.  You can see that we are pulling <code>first_name</code> from the <code>appc.mysql/employee</code> model and<br><code>manager</code> from the <code>appc.mysql/employee_manager</code> model.  The result is the same, it’s just a different way to do it.</p>
<h3 id="heading-left-join-0-to-many-"><a name="heading-left-join-0-to-many-">Left Join (0-to-many)</a></h3><p>In many cases, you will want to join a parent and child model where there are potentially many child records for each<br>parent record.  For example, let’s say we have a list of employees and a list of habits. Each employee can have zero or<br>more habits. We want to join from employees to habits, based on the employee_id each habit has.</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-built_in">module</span>.exports = Arrow.createModel(<span class="hljs-string">'employeeHabits'</span>, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">first_name</span>: { <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mysql/employee'</span>, <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> },
        <span class="hljs-attr">habit</span>: { <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mysql/employee_habit'</span>, <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span> }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.composite'</span>,
    <span class="hljs-attr">metadata</span>: {
        <span class="hljs-attr">left_join</span>: {
            <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mysql/employee_habit'</span>,
            <span class="hljs-attr">join_properties</span>: {
                <span class="hljs-attr">employee_id</span>: <span class="hljs-string">'id'</span>
            }
        }
    }
});</pre><p>In the example above, there are two key things to note.  First, the <strong>habit</strong> property type is <code>Array</code>, so for our<br>example each <strong>employee</strong> may have 0-to-many <strong>habits</strong>.  The second thing to notice is that the connector’s <code>metadata</code><br>configuration contains the setting <code>multiple: true</code>.  This tells the composite connector that there are potentially<br>multiple records for each employee record.</p>
<h3 id="heading-left-join-from-different-data-sources"><a name="heading-left-join-from-different-data-sources">Left Join from Different Data Sources</a></h3><p>What if we have data spread across multiple data sources? For example, we store some information about employees in<br>MySQL, and other information about them in Mongo. We want to join this data together. This is possible because they<br>share a common join property (<strong>employee_id</strong>).</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-built_in">module</span>.exports = Arrow.createModel(<span class="hljs-string">'employee'</span>, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">first_name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mysql/employee'</span> },
        <span class="hljs-attr">cities</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'city'</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'employeeCity'</span> }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.composite'</span>,
    <span class="hljs-attr">metadata</span>: {
        <span class="hljs-attr">left_join</span>: {
            <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mongo/employee_cities'</span>,
            <span class="hljs-attr">multiple</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">join_properties</span>: {
                <span class="hljs-attr">employeeId</span>: <span class="hljs-string">'id'</span>
            }
        }
    }
});</pre><p>In the example above, we create a composite model with one property (<strong>first_name</strong>) from a MySQL table and another<br>property from a model that is backed by the MongoDB model below:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-built_in">module</span>.exports = Arrow.createModel(<span class="hljs-string">'employeeCity'</span>, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">employeeId</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },
        <span class="hljs-attr">city</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.mongo'</span>
});</pre><p>This composite model will return zero-or-more cities from Mongo for each matching employee record from MySQL.</p>
<h3 id="heading-inner-join"><a name="heading-inner-join">Inner Join</a></h3><p>Inner joins are syntactically identical to left joins except you use the <code>inner_join</code> property in the connector’s<br>metadata configuration instead of <code>left_join</code>.  Also, inner joins only return records that match for all joined models<br>whereas left joins will return all matching records from the main model regardless of whether they have matching records<br>in the joined model.  Here’s an example of an inner join between three models all backed by MySQL. It augments the data<br>from our “employee” table with a manager, and a list of habits.</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-comment">// create a model from a mysql table</span>
<span class="hljs-built_in">module</span>.exports = Arrow.createModel(<span class="hljs-string">'empComposite'</span>, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">fname</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'employee'</span> },
        <span class="hljs-attr">manager</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'employee_manager'</span> },
        <span class="hljs-attr">habit</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'employee_habit'</span> }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.composite'</span>,
    <span class="hljs-attr">metadata</span>: {
        <span class="hljs-attr">inner_join</span>: [
            {
                <span class="hljs-attr">model</span>: <span class="hljs-string">'employee_manager'</span>,
                <span class="hljs-attr">join_properties</span>: {
                    <span class="hljs-attr">employee_id</span>: <span class="hljs-string">'id'</span>
                }
            },
            {
                <span class="hljs-attr">model</span>: <span class="hljs-string">'employee_habit'</span>,
                <span class="hljs-attr">multiple</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">join_properties</span>: {
                    <span class="hljs-attr">employee_id</span>: <span class="hljs-string">'id'</span>
                }
            }
        ]
    }
});</pre><p>The composite model above brings three MySQL custom models together (employee, employee_manager and employee_habit) and<br>performs an inner join with employee_id (and id for employee).  The resulting dataset will only contain records that<br>have data in all three models. So if an employee exists, but there is no record of who their manager is, or what habits<br>they have, that employee will not be returned in the results.</p>
<h3 id="heading-no-join"><a name="heading-no-join">No Join</a></h3><p>There may be cases where you want to create a composite model where the other models have no join properties. This<br>allows you to create a single endpoint that can orchestrate multiple data sources regardless of whether they have any<br>data in common.  Here’s an example that combines a MySQL table and a Salesforce object. There isn’t a relationship<br>between the two models, we simply want them returned together.</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-built_in">module</span>.exports = Arrow.createModel(<span class="hljs-string">'empAccts'</span>, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">employees</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mysql/employee'</span> },
        <span class="hljs-attr">accounts</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.salesforce/Account'</span> }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.composite'</span>,
});</pre><p>As you can see, no join configuration is provided.  This composite model will return all records from both models. You<br>can, however, provide query criteria for each model in the same API request.  Here’s a simple example of how you could<br>filter both models using the query endpoint for the model.  </p>
<pre class="highlight javascript"><span class="hljs-string">"where"</span>: {
    <span class="hljs-string">"employees"</span>: { <span class="hljs-string">"where"</span>: { <span class="hljs-string">"email_address"</span>: { <span class="hljs-string">"$like"</span>: <span class="hljs-string">"%smith.com"</span> } } },
    <span class="hljs-string">"accounts"</span>: { <span class="hljs-string">"where"</span>: { <span class="hljs-string">"Name"</span>: { <span class="hljs-string">"$like"</span>: <span class="hljs-string">"%foo%"</span> } } }
}</pre><p>By passing the data above along with your HTTP request, you can independently filter each model in your composite model.</p>
<p>Here’s another example that creates a composite model using five different connectors.</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-built_in">module</span>.exports = Arrow.createModel(<span class="hljs-string">'bigcomposite'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">employees</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mysql/employee'</span> }, <span class="hljs-comment">// MySQL model</span>
        teams: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mssql/team'</span> },  <span class="hljs-comment">// Azure MSSQL model</span>
        cities: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mongo/employeeCity'</span> }, <span class="hljs-comment">// Mongo Model</span>
        accounts: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.salesforce/Account'</span> }, <span class="hljs-comment">// Salesforce model</span>
        empLikes: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">'empfavorites'</span> }  <span class="hljs-comment">// ArrowDB model</span>
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.composite'</span>
});</pre><p>The above example creates a single model from five different models (MySQL, Azure MSSQL, Mongo, Salesforce, and ArrowDB)<br>all from different data sources with no join columns.</p>
<p>The model below <strong>empfavorites</strong> shows the definition of the model using Arrow DB - the connector name is <code>appc.arrowdb</code>.</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> empfavorites = Arrow.createModel(<span class="hljs-string">'empfavorites'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">employeeId</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">Number</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'This employee foreign key'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>},
        <span class="hljs-attr">car</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'employee car'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>},
        <span class="hljs-attr">favoriteLunch</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'employee favorite lunch'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>}
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.arrowdb'</span>
});

<span class="hljs-built_in">module</span>.exports = empfavorites;</pre><p>The composite model above also supports querying each model independently in a single HTTP call.  Here’s an example:</p>
<pre class="highlight javascript"><span class="hljs-string">"where"</span>: {
    <span class="hljs-string">"employees"</span>: { <span class="hljs-string">"where"</span>: { <span class="hljs-string">"email_address"</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">"%smith.com"</span>}}},
    <span class="hljs-string">"accounts"</span>: { <span class="hljs-string">"where"</span>: { <span class="hljs-string">"Name"</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">"%foo%"</span>}}},
    <span class="hljs-string">"cities"</span>: { <span class="hljs-string">"where"</span>: { <span class="hljs-string">"city"</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">"%o%"</span>}}},
    <span class="hljs-string">"teams"</span>: { <span class="hljs-string">"where"</span>: { <span class="hljs-string">"name"</span>: { <span class="hljs-attr">$like</span>:<span class="hljs-string">"%ns%"</span>}}},
    <span class="hljs-string">"empLikes"</span>: { <span class="hljs-string">"where"</span>: { <span class="hljs-string">"car"</span>:<span class="hljs-string">"Prius"</span>}}
}</pre><h2 id="heading-query-interface"><a name="heading-query-interface">Query Interface</a></h2><p>When API endpoints are auto-generated for models, a <strong>/api/model_name/query</strong> endpoint is also generated.  This query interface allows you to perform SQL-like queries against your model.  The query interface is supported for single connector models as well as composite models.  Query parameters can be specified via an HTTP client request or programmatically using the model’s programatic CRUD interface.  The latter would be executed on the server.  Here is a list of the support query parameters:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>limit</td>
<td>10</td>
<td>The number of records to fetch. The value must be greater than 0, and no greater than 1000.</td>
</tr>
<tr>
<td>skip</td>
<td>N/A</td>
<td>The number of records to skip. The value must not be less than 0.</td>
</tr>
<tr>
<td>where</td>
<td>N/A</td>
<td>Constrains values for fields. The value should be encoded JSON.</td>
</tr>
<tr>
<td>order</td>
<td>N/A</td>
<td>A dictionary of one or more fields specifying sorting of results. In general, you can sort based on any predefined field that you can query using the where operator, as well as on custom fields.  A value of 1 means ascending and -1 means descending. The value should be encoded JSON.</td>
</tr>
<tr>
<td>sel</td>
<td>N/A</td>
<td>Selects which fields to include from the query result. Others are excluded. The value should be encoded JSON.</td>
</tr>
<tr>
<td>unsel</td>
<td>N/A</td>
<td>Selects which fields to exclude from the query result. Others are included. The value should be encoded JSON.</td>
</tr>
<tr>
<td>page</td>
<td>1</td>
<td>Request page number starting from 1.</td>
</tr>
<tr>
<td>per_page</td>
<td>10</td>
<td>Number of results per page</td>
</tr>
</tbody>
</table>
<h3 id="heading-example-usage"><a name="heading-example-usage">Example Usage</a></h3><p>The following are example of how to use the query interface both as a client and programmatically on the server.</p>
<h4 id="heading-programmatic-query"><a name="heading-programmatic-query">Programmatic Query</a></h4><pre class="highlight javascript"><span class="hljs-keyword">var</span> options = {
    <span class="hljs-attr">where</span>: { <span class="hljs-attr">content</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">'Hello%'</span> } },
    <span class="hljs-attr">sel</span>: { <span class="hljs-attr">content</span>: <span class="hljs-number">1</span> },
    <span class="hljs-attr">order</span>: { <span class="hljs-attr">title</span>: <span class="hljs-number">-1</span>, <span class="hljs-attr">content</span>: <span class="hljs-number">1</span> },
    <span class="hljs-attr">limit</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">skip</span>: <span class="hljs-number">0</span>
};
Model.query(options, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, collection</span>) </span>{
    <span class="hljs-comment">// process results</span>
});</pre><p>In the above example, the <code>where</code> clause is looking for any records where the <strong>content</strong> property starts with ‘Hello’.  The <code>sel</code> property is set to only return the <strong>content</strong> property - all other model properties will be excluded.  The <code>order</code> property is set to order first by <strong>title</strong> descending (1) then <strong>content</strong> ascending (-1).  The <code>limit</code> property is set to only return 3 records at the most, and the <code>skip</code> property is set to skip no records (start at the beginning of the matching result set).</p>
<h4 id="heading-http-client-query"><a name="heading-http-client-query">HTTP Client Query</a></h4><p>Performing a query from the client is very similar to using the programmatic interface.  You simply need to ensure that your HTTP request contains the right query data.  Here’s a simple example using JQuery’s data property:</p>
<pre class="highlight javascript">url:<span class="hljs-string">'<%=ENDPOINT_URL%>/api/my_model/query'</span>,
<span class="hljs-attr">data</span>: {
    <span class="hljs-string">"skip"</span>:<span class="hljs-number">5</span>,
    <span class="hljs-string">"where"</span>: { <span class="hljs-string">"email"</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">"%@smith%"</span> }}
}</pre><p>In the above example, you can see the URL maps to the query endpoint for the model.  The query is set to skip the first 5 records and return results where the <strong>email</strong> is like <strong>“%@smith%”</strong>.  This would work the same for any HTTP client request (Titanium or Native).</p>
<h3 id="heading-querying-composite-models"><a name="heading-querying-composite-models">Querying Composite Models</a></h3><p>One of the more powerful features of the query interface is the ability to filter data for composite models (models that are comprised of two or more models from the same or different connectors).</p>
<h4 id="heading-composite-models-with-joins"><a name="heading-composite-models-with-joins">Composite Models with Joins</a></h4><p>Currently, there is a limitation with queries on composite models that contain joins.  You can only use properties from the main model in a <code>where</code> clause.  You would have to programmatically filter the secondary model’s results.  Here’s an example model that is based on two MySQL tables</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> mycomposite = Arrow.createModel(<span class="hljs-string">'mycomposite'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">fname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'First name'</span>, <span class="hljs-attr">model</span>:<span class="hljs-string">'appc.mysql/employee'</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'first_name'</span>},
        <span class="hljs-attr">habit</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">Array</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Habit of employee'</span>,<span class="hljs-attr">model</span>:<span class="hljs-string">'appc.mysql/employee_habit'</span>}
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.composite'</span>,
    <span class="hljs-attr">metadata</span>: {
        <span class="hljs-attr">left_join</span>: {
            <span class="hljs-attr">model</span>: <span class="hljs-string">'appc.mysql/employee_habit'</span>,
            <span class="hljs-attr">multiple</span>:<span class="hljs-literal">true</span>,
            <span class="hljs-attr">join_properties</span>: {
                <span class="hljs-attr">employee_id</span>: <span class="hljs-string">'id'</span>
            }
        }
    }
});

<span class="hljs-built_in">module</span>.exports = mycomposite;</pre><p>This model joins the <strong>employee</strong> and <strong>employee_habit</strong> models.  The <strong>employee</strong> model is the main model and <strong>employee_habit</strong> is the secondary model.  The following is <strong>valid</strong> query:</p>
<pre class="highlight javascript">url:<span class="hljs-string">'<%=ENDPOINT_URL%>/api/mycomposite/query'</span>,
<span class="hljs-attr">data</span>: {
    <span class="hljs-string">'where'</span>: { <span class="hljs-string">"fname"</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">'Jo%'</span> }}
}</pre><p>The next query is <strong>invalid</strong> because it’s trying to build a where clause that uses properties from both tables in the case of a join.  To be clear, you can specify multiple properties in your where clause from the first table.  The restriction only applies to using properties in the <code>where</code> clause from the secondary table/model.</p>
<pre class="highlight javascript">url:<span class="hljs-string">'<%=ENDPOINT_URL%>/api/mycomposite/query'</span>,
<span class="hljs-attr">data</span>: {
    <span class="hljs-string">'where'</span>: { <span class="hljs-string">"fname"</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">'Jo%'</span> }, <span class="hljs-string">"habit"</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">'%keys%'</span>}}
}</pre><h4 id="heading-composite-models-with-no-joins"><a name="heading-composite-models-with-no-joins">Composite Models with NO Joins</a></h4><p>Composite models with no joins do not have any restrictions.  You can execute a single query that can specify properties from each model in your composite model.  Here’s a example of a composite model that consists of a model from MySQL, MongoDB, Salesforce and Azure’s MSSQL:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> bigModel = Arrow.createModel(<span class="hljs-string">'bigModel'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">employees</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">Array</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'employees'</span>, <span class="hljs-attr">model</span>:<span class="hljs-string">'appc.mysql/employee'</span>},
        <span class="hljs-attr">teams</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">Array</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'team name'</span>,  <span class="hljs-attr">model</span>:<span class="hljs-string">'appc.mssql/team'</span>},
        <span class="hljs-attr">cities</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">Array</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'cities'</span>, <span class="hljs-attr">model</span>:<span class="hljs-string">'empCity'</span>},
        <span class="hljs-attr">accounts</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">Array</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'accounts'</span>,<span class="hljs-attr">model</span>:<span class="hljs-string">'appc.salesforce/Account'</span>}
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.composite'</span>,
});

<span class="hljs-built_in">module</span>.exports = bigModel;</pre><p>The <strong>empCity</strong> model is the Mongo model, which is defined here:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> empCity = Arrow.createModel(<span class="hljs-string">'empCity'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">employeeId</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">Number</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'This employee foreign key'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>},
        <span class="hljs-attr">city</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Favorite city'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>}
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.mongo'</span>
});

<span class="hljs-built_in">module</span>.exports = empCity;</pre><p>Given this composite model, you can perform a query that filters each individual model like so:</p>
<pre class="highlight javascript">url:<span class="hljs-string">'<%=ENDPOINT_URL%>/api/model/query'</span>,
<span class="hljs-attr">data</span>: {
    <span class="hljs-string">'limit'</span>:<span class="hljs-number">100</span>,
    <span class="hljs-string">'where'</span>: {
        <span class="hljs-string">'employees'</span>: { <span class="hljs-string">'where'</span>: { <span class="hljs-string">"email_address"</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">'%smith.com'</span>}}},
        <span class="hljs-string">'accounts'</span>: { <span class="hljs-string">'where'</span>: { <span class="hljs-string">"Name"</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">'%foo%'</span>}}},
        <span class="hljs-string">'cities'</span>: { <span class="hljs-string">'where'</span>: { <span class="hljs-string">"city"</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">'%o%'</span>}}},
        <span class="hljs-string">'teams'</span>: { <span class="hljs-string">'where'</span>: { <span class="hljs-string">"teamName"</span>: { <span class="hljs-attr">$like</span>:<span class="hljs-string">'%ee%'</span>}}}
    }
}</pre><p>As you can see from the above example, you can specify separate <code>where</code> clauses for each model in the composite model.</p>
<h2 id="heading-field-name-mappings"><a name="heading-field-name-mappings">Field Name Mappings</a></h2><p>You will often want the ability to use a field property name in your model that is different from its name in an existing model.  The example below shows how you can use the <code>name</code> sub-property of a field to map a model property name to a specific property name of an existing custom model or connector generated model.  For example, the <strong>employee</strong> model has a property called <strong>first_name</strong>, but the new model wants that property to be called <strong>fname</strong>.  The Arrow framework ensures that this mapping occurs in a bi-directional fashion.</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> emp = Arrow.Model.reduce(<span class="hljs-string">'appc.mysql/employee'</span>,<span class="hljs-string">'emp'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">fname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'First name'</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'first_name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>},
        <span class="hljs-attr">lname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Last name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'last_name'</span>},
        <span class="hljs-attr">email</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Email address'</span>, <span class="hljs-attr">readonly</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'email_address'</span>}
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.mysql'</span>
});

<span class="hljs-built_in">module</span>.exports = emp;</pre><h2 id="heading-field-input-validation"><a name="heading-field-input-validation">Field Input Validation</a></h2><p>There may be cases where you will need to perform validation on a field when creating or updating a record.  Each<br>property in your model definition can specify a validation function using the <code>validator</code> field property.  This<br>function is called prior to sending data to your model’s connector.  The <code>validator</code> function is passed the value<br>of the property.  If the value is valid, the function should return <code>null</code> or <code>undefined</code>.  If it’s not valid, the<br>function should return a message indicating why the validation failed.  Here’s an example of a validator function on<br>a field.</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> emp = Arrow.Model.reduce(<span class="hljs-string">'appc.mysql/employee'</span>,<span class="hljs-string">'emp'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">fname</span>: {
            <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'First name'</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'first_name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>,
            <span class="hljs-attr">validator</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
                <span class="hljs-keyword">if</span> (val.length &lt; <span class="hljs-number">5</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-string">'First name must be greater than 5 characters'</span>
                }
            }
        },
        <span class="hljs-attr">lname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Last name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'last_name'</span>},
        <span class="hljs-attr">email</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Email address'</span>, <span class="hljs-attr">readonly</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'email_address'</span>}
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.mysql'</span>
});

<span class="hljs-built_in">module</span>.exports = emp;</pre><h2 id="heading-model-input-validation"><a name="heading-model-input-validation">Model Input Validation</a></h2><p>There may be cases where you will need to perform validation on a whole model. Specify in your model definition a<br>validation function using the <code>validator</code> model property.  This function is called prior to sending data to your<br>model’s connector.  The <code>validator</code> function is passed the instance of the model.  If the value is valid, the function<br>should return <code>null</code> or <code>undefined</code>.  If it’s not valid, the function should return a message indicating why the<br>validation failed, or throw an exception.  Here’s an example of a validator function on a model.</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> emp = Arrow.Model.reduce(<span class="hljs-string">'appc.mysql/employee'</span>,<span class="hljs-string">'emp'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">fame</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span> },
        <span class="hljs-attr">lname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span> }
    },
    <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">instance</span>) </span>{
        <span class="hljs-keyword">var</span> errors = [];
        <span class="hljs-keyword">if</span> (instance.get(<span class="hljs-string">'fame'</span>) === <span class="hljs-string">"Rick"</span>) {
            errors.push(<span class="hljs-string">'Sorry, Rick is not allowed to play here.'</span>);
        }
        <span class="hljs-keyword">if</span> (instance.get(<span class="hljs-string">'lname'</span>).length &lt; <span class="hljs-number">5</span>) {
            errors.push(<span class="hljs-string">'The lname must be at least 5 characters long.'</span>);
        }
        <span class="hljs-keyword">if</span> (errors.length) {
            <span class="hljs-keyword">return</span> errors.join(<span class="hljs-string">'\n'</span>);
        }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.mysql'</span>
});

<span class="hljs-built_in">module</span>.exports = emp;</pre><h2 id="heading-customizing-generated-model-apis"><a name="heading-customizing-generated-model-apis">Customizing Generated Model APIs</a></h2><p>The generated APIs for your models can be customized.</p>
<p>For example, by default the create API will only return a status 201 with a header “Location” pointing to the newly created instance. No body content is returned. If you want to directly receive the newly created instance in the body of the request, add the <code>includeResponseBody: true</code> metadata to your model:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> emp = Arrow.Model.reduce(<span class="hljs-string">'appc.mysql/employee'</span>,<span class="hljs-string">'emp'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">fname</span>: {
            <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'First name'</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'first_name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>
        },
        <span class="hljs-attr">lname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Last name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'last_name'</span>},
        <span class="hljs-attr">email</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Email address'</span>, <span class="hljs-attr">readonly</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'email_address'</span>}
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.mysql'</span>,
    <span class="hljs-attr">metadata</span>: {
        <span class="hljs-attr">includeResponseBody</span>: <span class="hljs-literal">true</span>
    }
});

<span class="hljs-built_in">module</span>.exports = emp;</pre><h2 id="heading-programatic-crud-interface"><a name="heading-programatic-crud-interface">Programatic CRUD Interface</a></h2><p>All models inherit the CRUD interfaces supported by their underlying connector.  As a result, you can programmatically call these interfaces.  The main use case for using a model’s CRUD interface is when you want to have more control of an APIs functionality.  In this case, you can place logic in your API endpoint’s <code>action</code> function to handle both custom business functionality and to control execution of data access.</p>
<p>Here are the main interfaces supported by most connectors:</p>
<pre class="highlight javascript"><span class="hljs-comment">// delete all records for a model</span>
Model.deleteAll(callback);

<span class="hljs-comment">// query a model.</span>
Model.query(options, callback);

<span class="hljs-comment">// find all records for a model</span>
Model.findAll(callback);

<span class="hljs-comment">// find a record by id for a model</span>
Model.findByID(id, callback);

<span class="hljs-comment">// delete a record for a model</span>
Model.delete(instance, callback);

<span class="hljs-comment">// update a record</span>
Model.update(instance, callback);

<span class="hljs-comment">// create a record</span>
Model.create(object, callback);</pre><p>And here are some example uses given the following model:</p>
<pre class="highlight javascript"><span class="hljs-comment">// example model</span>
Model = Arrow.Model.extend(testTableName, {
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">title</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> },
        <span class="hljs-attr">content</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> }
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.mssql'</span>
});</pre><h3 id="heading-delete-all-records"><a name="heading-delete-all-records">Delete All Records</a></h3><p>Use the <code>deleteAll</code> function on a model to delete all of its records.</p>
<pre class="highlight javascript">Model.deleteAll(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
    <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-keyword">return</span> next(err);
    }
    next();
});</pre><h3 id="heading-create-update-and-delete-a-record"><a name="heading-create-update-and-delete-a-record">Create, Update, and Delete a Record</a></h3><p>Here’s an example of how to create a record, then update it then delete it.  It’s not necessarily a practical example, but it demonstrates how to use some additional interfaces available on a model.</p>
<pre class="highlight javascript"><span class="hljs-comment">// setup record object</span>
<span class="hljs-keyword">var</span> title = <span class="hljs-string">'Test'</span>,
    content = <span class="hljs-string">'Hello world'</span>,
    object = {
        <span class="hljs-attr">title</span>: title,
        <span class="hljs-attr">content</span>: content
    };

<span class="hljs-comment">// create record then update then delete</span>
Model.create(object, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, instance</span>) </span>{
    <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-comment">// do something</span>
    }

    <span class="hljs-comment">// update instance</span>
    instance.set(<span class="hljs-string">'content'</span>, <span class="hljs-string">'foo'</span>);

    <span class="hljs-comment">// save instance</span>
    instance.update(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>{
        <span class="hljs-comment">// logic here</span>
    });

    <span class="hljs-comment">// delete instance</span>
    instance.delete(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err,result</span>)</span>{
        <span class="hljs-comment">// logic here</span>
    });
});</pre><h3 id="heading-run-a-query"><a name="heading-run-a-query">Run a Query</a></h3><p>Here’s a simple example of how to programmatically perform a query against a model.</p>
<pre class="highlight javascript"><span class="hljs-comment">// setup query options</span>
<span class="hljs-keyword">var</span> options = {
    <span class="hljs-attr">where</span>: { <span class="hljs-attr">content</span>: { <span class="hljs-attr">$like</span>: <span class="hljs-string">'Hello%'</span> } },
    <span class="hljs-attr">sel</span>: { <span class="hljs-attr">content</span>: <span class="hljs-number">1</span> },
    <span class="hljs-attr">order</span>: { <span class="hljs-attr">title</span>: <span class="hljs-number">-1</span>, <span class="hljs-attr">content</span>: <span class="hljs-number">1</span> },
    <span class="hljs-attr">limit</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">skip</span>: <span class="hljs-number">0</span>
};
<span class="hljs-comment">// execute query</span>
Model.query(options, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, coll</span>) </span>{
    <span class="hljs-comment">// process results</span>
});</pre><h2 id="heading-restricting-crud-endpoints"><a name="heading-restricting-crud-endpoints">Restricting CRUD Endpoints</a></h2><p>By default, models support the basic CRUD methods (CREATE, READ, UPDATE, and DELETE).  You can limit the methods supported by a model by using the <code>actions</code> property.  Here’s an example:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> emp = Arrow.Model.reduce(<span class="hljs-string">'appc.mysql/employee'</span>,<span class="hljs-string">'emp'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">fname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'First name'</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'first_name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>},
        <span class="hljs-attr">lname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Last name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'last_name'</span>},
        <span class="hljs-attr">email</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Email address'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'email_address'</span>}
    },
    <span class="hljs-attr">actions</span>:[<span class="hljs-string">'create'</span>,<span class="hljs-string">'read'</span>],
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.mysql'</span>
});

<span class="hljs-built_in">module</span>.exports = emp;</pre><p>In the example above, the model will only allow <code>create</code> (POST) or <code>read</code> (GET).  DELETE and PUT will not be allowed and will fail.</p>
<p>The valid values for the <code>action</code> property are: <code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>, and <code>deleteAll</code>.</p>
<h2 id="heading-disable-endpoint-generation"><a name="heading-disable-endpoint-generation">Disable Endpoint Generation</a></h2><p>By default, API endpoints will be generated for any model you create, but there will be cases where you will want to create an API definition for your model (e.g., you want to use <strong>blocks</strong> or specify a custom endpoint path or perform custom business logic).  In these cases, you will want to set <code>autogen</code> to <code>false</code> for your model.  Here’s an example:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> emp = Arrow.Model.reduce(<span class="hljs-string">'appc.mysql/employee'</span>,<span class="hljs-string">'emp'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">fname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'First name'</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'first_name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>},
        <span class="hljs-attr">lname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Last name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'last_name'</span>},
        <span class="hljs-attr">email</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Email address'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'email_address'</span>}
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.mysql'</span>,
    <span class="hljs-attr">autogen</span>: <span class="hljs-literal">false</span>
});

<span class="hljs-built_in">module</span>.exports = emp;</pre><p>In this example, you can see that the <code>autogen</code> property is set to false, which means that no endpoints will be generated for this model.  You can then use this model in an API definition.  Here’s an example:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> empAPI = Arrow.API.extend({
    <span class="hljs-attr">group</span>: <span class="hljs-string">'empAPIs'</span>,
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/api/emp/:id'</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">'This API finds one employee record'</span>,
    <span class="hljs-attr">model</span>: <span class="hljs-string">'emp'</span>,
    <span class="hljs-attr">before</span>: <span class="hljs-string">'preBlock'</span>,
    <span class="hljs-attr">after</span>:<span class="hljs-string">'postBlock'</span>,
    <span class="hljs-attr">parameters</span>: {
        <span class="hljs-attr">id</span>: { <span class="hljs-attr">description</span>:<span class="hljs-string">'the employee id'</span>}
    },
    <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, resp, next</span>) </span>{
        resp.stream(req.model.find, req.params.id, next);
    }
});

<span class="hljs-built_in">module</span>.exports = empAPI;</pre><h2 id="heading-generate-custom-models"><a name="heading-generate-custom-models">Generate Custom Models</a></h2><p>You can use the <code>appc</code> command-line interface to generate new models or new model projects.</p>
<pre class="highlight shell">appc generate</pre><p>Make sure you follow the prompts for generating a new model.</p>
<p>There are two ways to generate a model.  First, you can create a standalone model project. To do this, run the above command outside of an API project directory. The main reason to create a standalone model project is that you eventually plan to publish it to the Platform Marketplace.  Second, you can generate a model into an existing API project. To do this, run the above command inside of a API project directory.  This will create a new model inside the <code>models</code> directory of your API project.</p>
<h2 id="heading-generate-connector-models"><a name="heading-generate-connector-models">Generate Connector Models</a></h2><p>Some connectors support the ability to generate models from their underlying schemas.  For example, the MySQL and Salesforce connectors will generate model definitions for each of their tables/objects.  This allows you to directly extend or reduce them like so:</p>
<pre class="highlight javascript"><span class="hljs-keyword">var</span> Arrow = <span class="hljs-built_in">require</span>(<span class="hljs-string">'arrow'</span>);

<span class="hljs-keyword">var</span> emp = Arrow.Model.reduce(<span class="hljs-string">'appc.mysql/employee'</span>,<span class="hljs-string">'emp'</span>,{
    <span class="hljs-attr">fields</span>: {
        <span class="hljs-attr">fname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'First name'</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'first_name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>},
        <span class="hljs-attr">lname</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Last name'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'last_name'</span>},
        <span class="hljs-attr">email</span>: { <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-attr">description</span>:<span class="hljs-string">'Email address'</span>, <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">'email_address'</span>}
    },
    <span class="hljs-attr">connector</span>: <span class="hljs-string">'appc.mysql'</span>,
    <span class="hljs-attr">autogen</span>: <span class="hljs-literal">false</span>
});

<span class="hljs-built_in">module</span>.exports = emp;</pre><p>To set this property for Salesforce (as an example), go to the <code>conf</code> directory and open <code>appc.salesforce.default.js</code> - this is the default configuration for the Salesforce connector.  This configuration file is created when you install the Salesforce connector into your project.</p>
<p>Here’s an example of a Salesforce connector’s configuration (found in <strong>conf/appc.salesforce.default.js</strong>)</p>
<pre class="highlight javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-string">"connectors"</span>: {
    <span class="hljs-string">"appc.salesforce"</span>: {
      <span class="hljs-string">"generateModelsFromSchema"</span>:<span class="hljs-literal">false</span>,
      <span class="hljs-string">"requireSessionLogin"</span>: <span class="hljs-literal">false</span>,
       <span class="hljs-string">"url"</span>: <span class="hljs-string">'https://test.salesforce.com/'</span>,
       <span class="hljs-string">"username"</span>: <span class="hljs-string">'myemail@mydomain.com'</span>,
       <span class="hljs-string">"password"</span>: <span class="hljs-string">'yourpass'</span>,
       <span class="hljs-string">"token"</span>: <span class="hljs-string">'yourtoken'</span>
    }
  }
};</pre><p>To disable the automatic generation of models for a connector, set <code>generateModelsFromSchema</code> to <code>false</code>. A value of <code>true</code> means connector models will be generated for that connector. The default value is <code>true</code>.</p>
