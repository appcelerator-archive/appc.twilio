// jscs:disable jsDoc

var marked = require('marked'),
	fs = require('fs'),
	path = require('path'),
	ejs = require('ejs'),
	_ = require('lodash'),
	highlight = require('highlight.js'),
	langShell = /^(curl|shell|sh)$/i,
	asideClass = /^(warning|notice|error|success)$/,
	langJS = /^(json|javascript|js|node|node\.js|nodejs|node\-js|js|web|titanium|ti)$/i,
	langHTML = /^(html)$/i,
	langXML = /^xml$/,
	langCSS = /^(css|style|styles)$/i,
	renderer = new marked.Renderer();

// setup the renderer
marked.setOptions({
	renderer: renderer,
	gfm: true,
	tables: true,
	breaks: true,
	pedantic: false,
	sanitize: false,
	smartLists: true,
	smartypants: true
});

/**
 * render code using highlight.js and also do some wrapping
 * that this code template requires from a css standpoint
 */
function code(_code, lang) {
	if (!lang) {
		return '<blockquote class="unformat">\n' + marked(_code) + '\n</blockquote>';
	}
	if (asideClass.test(lang)) {
		return '<aside class="' + asideClass.exec(lang)[1] + '">' + _code + '</aside>';
	}
	lang = lang.replace(/\./, '-');
	var html = '<pre class="highlight ' + lang + '">',
		result;
	if (langJS.test(lang)) {
		result = highlight.highlight('javascript', _code).value;
	} else if (langHTML.test(lang)) {
		result = highlight.highlight('html', _code).value;
	} else if (lang === 'bash' || lang === 'sh') {
		result = highlight.highlight('bash', _code).value;
	} else if (langShell.test(lang)) {
		// command line doesn't seem to colorize as well
		result = _code;
	} else if (langXML.test(lang)) {
		result = highlight.highlight('xml', _code).value;
	} else if (langCSS.test(lang)) {
		result = highlight.highlight('css', _code).value;
	} else {
		console.error('WARNING: Auto highlighting code with marked lang "' + lang + '". arrow-util needs to be updated to choose the correct language based on this specification!');
		result = highlight.highlightAuto(_code).value;
	}
	html += result;
	html += '</pre>';

	// remember the languages used
	if (lang && this.languages.indexOf(lang) === -1) {
		this.languages.push(lang);
	}

	return html;
}

function makeAnchor(text) {
	return text.toLowerCase().replace(/[^\w]+/g, '-');
}

function heading(text, level) {
	var escapedText = makeAnchor(text);
	return '<h' + level + ' id="heading-' + escapedText + '"><a name="heading-' + escapedText + '">' + text + '</a></h' + level + '>';
}

/**
 * replace any $NAME variables found in the source
 */
function replaceVars(str, vars) {
	return str.replace(/(\$[\w]+)/g, function (value) {
		var name = value.substring(1),
			result = vars && vars[name];
		return result || value;
	});
}

function generate(content, tokens, opts) {
	renderer.code = code;
	renderer.heading = heading;
	renderer.languages = [];
	var doejs = (opts && opts.ejs === undefined) || (opts && opts.ejs) || !opts,
		domd = (opts && opts.markdown === undefined) || (opts && opts.markdown) || !opts,
		transformed = transform(content, tokens, doejs),
		markup = domd ? marked(transformed) : transformed,
		languages = _.reject(_.compact(_.without(renderer.languages, 'json', 'javascript')), function (n) {return n === 'undefined';});
	if (!doejs) {
		// if skipping ejs, we need to turn them back
		markup = markup.replace(/&lt;%/g, '<%').replace(/%&gt;/g, '%>');
	}
	return {
		markup: cleanup(markup),
		languages: languages
	};
}

function cleanup(html) {
	html = html
		.replace(/<p><\/p>/mg, '')
		.replace(/<p>(<h1 id="[^"]*">[^<]*<\/h1>)<\/p>/ig, function (val, inner) {
			return inner;
		});
	return html;
}

function transform(content, tokens, doejs) {
	var result = doejs ? ejs.render(content, tokens) : content;
	return replaceVars(result, tokens);
}

exports.generate = generate;
exports.makeAnchor = makeAnchor;
