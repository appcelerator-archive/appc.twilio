// jscs:disable jsDoc

var _ = require('lodash'),
	path = require('path'),
	fs = require('fs'),
	Model = require('./model'),
	Connector = require('./connector'),
	Block = require('./block'),
	API = require('./api');

const SPEC = '1';

function ObjectModel(arrow) {
	var models = arrow.getModels(),
		blocks = arrow.getBlocks(),
		connectors = arrow.getConnectors(),
		apis = arrow.getAPIs();

	this.models = {};
	this.connectors = {};
	this.blocks = {};
	this.apis = {};
	this.config = arrow.config;
	this.server = {
		port: arrow.port,
		auth: {}
	};

	this.metadata = {type: 'unknown'};

	// pull out the package json details
	var pkg = path.join(arrow.config.dir, 'package.json');
	if (fs.existsSync(pkg)) {
		pkg = require(pkg);
		var kre = /(arrow|apibuilder)-(.*)/;
		this.metadata = _.pick(pkg, 'name', 'description', 'version', 'author', 'repository', 'license', 'dependencies', 'appcelerator', 'readme');
		pkg.keywords && _.each(pkg.keywords).forEach(function (keyword) {
			if (kre.test(keyword)) {
				this.metadata.type = kre.exec(keyword)[1];
			}
		}.bind(this));
	}

	var index_doc = path.join(arrow.config.dir, 'docs', 'index.md');
	if (fs.existsSync(index_doc)) {
		this.metadata.documentation = fs.readFileSync(index_doc).toString();
	}

	// allow dev to set their own menu icon for API docs that are public
	var menulogo = path.join(arrow.config.dir, 'docs', 'menulogo.png');
	if (fs.existsSync(menulogo)) {
		this.metadata.menulogo = menulogo;
	}

	if (this.config.apikey_production && this.config.apikey_development) {
		this.server.auth.apikey_production = this.config.apikey_production;
		this.server.auth.apikey_development = this.config.apikey_development;
		this.server.auth.apikey = this.config.apikey || this.config['apikey_' + this.config.env];
		this.server.auth.type = this.config.APIKeyAuthType || 'apikey'; // for backwards compat
	} else if (this.config.apikey) {
		this.server.auth.apikey_production = this.config.apikey;
		this.server.auth.apikey_development = this.config.apikey;
		this.server.auth.apikey = this.config.apikey;
		this.server.auth.type = this.config.APIKeyAuthType || 'apikey'; // for backwards compat
	}

	Object.keys(models).forEach(function (name) {
		var object = models[name];
		var model = new Model(arrow, object);
		this.models[name] = model.toJSON();
	}.bind(this));

	Object.keys(blocks).forEach(function (name) {
		var object = blocks[name];
		var block = new Block(arrow, object);
		this.blocks[name] = block.toJSON();
	}.bind(this));

	Object.keys(connectors).forEach(function (name) {
		var object = connectors[name];
		var connector = new Connector(arrow, object);
		this.connectors[name] = connector.toJSON();
	}.bind(this));

	apis.forEach(function (object) {
		var name = object.group || object.name,
			group = this.apis[name];
		if (!group) {
			var docfn = path.join(arrow.config.dir, 'docs', name + '.md'),
				doc = fs.existsSync(docfn) && fs.readFileSync(docfn).toString();
			group = this.apis[name] = {
				endpoints: [],
				description: doc
			};
		}
		var api = new API(arrow, object);
		group.endpoints.push(api.toJSON());
	}.bind(this));
}

ObjectModel.prototype.toJSON = function () {
	return {
		spec: SPEC,
		metadata: this.metadata,
		server: this.server,
		config: this.config,
		apis: this.apis,
		connectors: this.connectors,
		models: this.models,
		blocks: this.blocks
	};
};

ObjectModel.prototype.inspect = function () {
	return JSON.stringify(this.toJSON(), null, '\t');
};

module.exports = ObjectModel;
